= Ternary Diagrams in KDChart = 
A ternary diagram display the relative shares of three variables in a total. To normalize the display, totals are always considered 1 (100%), and the relative values need to add up to 100%. Wikipedia has a nice overview of [[http://en.wikipedia.org/wiki/Ternary_plot ternary plots]].

The KDChart implementation of ternary plots covers the functionality described in the Wikipedia article.

= Main Components =
As usual, the components of a chart are separated into 
* a coordinate plane (KDChart::TernaryCoordinatePlane) that holds the pieces together, 
* a grid class (KDChart::TernaryGrid), which draws the grid, 
* an axis class (KDChart::TernaryAxis), altough in this case, axes are actually drawn into the diagram space, because the diagram is triangularily chaped
* two diagram classes (so far, because of the special kind of assumption, not many diagram types make sense): 
** a TernaryPointDiagram, and 
** a TernaryLineDiagram. 

= Ternary Diagrams = 
Two kinds of ternary diagrams are provided by kdchart - point and line
diagrams. Both use the data retrieved from the model to initialize a
TernaryPoint object (see below), and then translate this ternary value
to diagram and then widget coordinates. 

It is unclear at the moment what the best data set dimension for
ternary points is: 
* it could be one, and the retrieved value could be a
QPair<double,double> (the remaining value can be calculated)
* it could be two, then the two rows provide a and b, and c could be
calculated, or
* it could be three, and a, b, and c would be provided by the
model. In that case, conflicts are possible (the sum of a, b, and c
could be 1.5, now what?)

I tend to use two as the data set dimension. 

= Ternary Grid = 
The Ternary Grid object draws the grid lines (rulers), and also the
axis tick marks. 

Axis tick marks are drawn by the grid since there are no different
axis decorations for multiple diagrams. The "background" of the
diagram looks the same for every instance. 

There is only one grid per ternary coordinate system, which is why
overlaying multiple grids is not supported. 

= Ternary Axes = 
The axis objects mostly take care of placing the axis header text and
the 50% labels at the right position. Ternary axes are not horizontal
or vertical, but can relate to three different directions - north,
west and east. 

At the moment, only one axis per direction is supported, I simply
cannot think of how multiple axes per direction could be
displayed. This may be revisited in case a customer requests it. 

= Ternary Coordinate Plane =
== Coordinate Systems Used ==
Ternary diagrams have one major advantage - their coordinate space is
constant. All points are plotted into a diagram that is comprised of
a triangle with sides of equal length. We defined this length to 1,
and where thus able to use floating point constants for all relative
sizes. See the file TernaryConstants.h for details. 

At all, three coordinate systems are used to draw any ternary point:
* the ternary coordinate system, which specifies the relative weights
of the A, B anc C axis for the point, 
* the diagram cartesian coordinate system, which represents the
cartesian coordinates within the triangle space for a ternary point,
and 
* the widget coordinate system, which in the end represents the widget
coordinates of each drawn point. 
The ternary coordinate plane calculates in diagram cartesian
coordinates, and translates those to widget coordinates. The diagrams
operate on ternary points, and translate them to diagram cartesian
coordinates. 

Zooming and panning is not supported yet, since ternary diagrams only
seem to make sense if the whole triangle is visible. If there are
customer requests for zooming and panning, it can be added. The
ternary coordinate plane is internally a cartesian one, so zooming and
panning is similar to CartesianCoordinatePlane. 

The idea of the ternary diagrams allows for some very interesting simplifications, which in turn allows us to use the same logical (diagram) coordinate system, no matter what the size of the diagram in widget coordinates is. Basically, we alwys treat the diagram as a even-sided triangle with a width of 1.0 for every side. This means the height of the diagram is always 0.5 * sqrt (3). All interesting constants are defined in Ternary/TernaryConstants, for example: 

<pre>
extern const double Sqrt3 = sqrt( 3.0 );
extern const double TriangleWidth = 1.0;
extern const double TriangleHeight = 0.5 * Sqrt3;
extern const QPointF TriangleTop( 0.5, TriangleHeight );
extern const QPointF TriangleBottomLeft( 0.0, 0.0 );
extern const QPointF TriangleBottomRight( 1.0, 0.0 );
extern const QPointF AxisVector_C_A( TriangleTop - TriangleBottomRight );
extern const QPointF Norm_C_A( -AxisVector_C_A.y(), AxisVector_C_A.x() );
</pre>

These never change (duh). The translation of those 2D coordinates to widget coordinates is done by the TernaryCoordinatePlane object.

== TernaryPoint ==
Internally, the diagrams use a class TernaryPoint to handle each
individual ternary value. TernaryPoint is not part of the exported
API. TernaryPoint supports deriving the third part out of two known
values (a, b, and c always add up to one, so to determine the system,
only two values need to be known). 

= Prerendered Labels =
The ternary diagrams (the axes, in fact) are the first classes to use
the new PrerenderedLabel class. Prerendered labels are specified by a
text, a pen and brush, a font and a rotation angle. when requested,
they paint the text onto a completely transparent pixmap, and cache
this pixmap until any of the attributes that change the appearance
change. This way, the rather expensive text drawing operations (with
transparency and rotation) can be reused, which seems to be a lot
faster, especially for smaller text labels. 

The structure of prerendered labels is a first implementation of
prerendered elements, that could comprise all kinds of elements
(markers, handles, ...). In the long term, they could be used in
different KDAB projects. 
