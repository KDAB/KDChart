<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/xml/docbook/schema/dtd/4.2/docbookx.dtd" [
        <!ENTITY auml "&#x00E4;">
        <!ENTITY mdash "&#x2014;">
        <!ENTITY nbsp "&#x00A0;">
        <!ENTITY kdchart "KD&#x00A0;Chart">
]>
<book>
    <bookinfo>
	<title>&kdchart; Programmer's Manual</title>
	<corpauthor>The &kdchart; Team</corpauthor>
	<corpname>Klar&auml;lvdalens Datakonsult AB</corpname>
        <releaseinfo>Version 2.0</releaseinfo>
        <legalnotice>
            <para>
                The contents of this manual and the associated &kdchart;
                software are the property of Klar&auml;lvdalens Datakonsult AB
                and are copyrighted. Any reproduction in whole or in part is
                strictly prohibited without prior written permission by
                Klar&auml;lvdalens Datakonsult AB.
            </para>    
	    <para>
                &kdchart; and the &kdchart; logo are trademarks or registered
                trademarks of Klar&auml;lvdalens Datakonsult AB in the European
                Union, the United States, and/or other countries. Other
                product and company names and logos may be trademarks or 
		registered trademarks of their respective companies.
            </para>
        </legalnotice>
        <copyright>
            <year>2001&mdash;2006</year>
            <holder>Klar&auml;lvdalens Datakonsult AB</holder>
        </copyright>
    </bookinfo>

    <!-- =====================Introduction============================== -->

    <chapter id="chapter_introduction">
        <title id="chtxt_introduction">Introduction</title>
        <titleabbrev id="chnum_introduction">Chapter 1</titleabbrev>

        <para>
	    &kdchart; is Klar&auml;lvdalens Datakonsult AB's charting package 
	    for Qt applications.
            This is the &kdchart; Programmer's Manual. It will get you
            started with creating your charts and provides lots of pointers
	    to the many advanced features in &kdchart;.
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Depending on your &kdchart; version, you will find
                    different <filename>INSTALL</filename> files that explain
                    how to install &kdchart; on your platform and a step by 
		    step description about how to build  it from sources.
                </para>
            </listitem>
            <listitem>
                <para>
                    &kdchart; also comes with an extensive Reference Manual
                    generated directly from the source code itself.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            You should refer to it in conjunction with this Programmer's
            Manual.
        </para>
        <itemizedlist>
         <listitem>
                <para>
                    What is &kdchart;?
                </para>
		<para>
		    &kdchart; is a tool for creating business and scientific
		    charts, and is the most powerful Qt component of its kind.
		    Besides having all the standard features, it also enables 
		    the developer to design and manage a large number of axes 
		    and provide sophisticated means of layout customization.
		    Since all configuration settings have reasonable defaults
		    you can usually get by with setting only a handful of 
		    parameters and relying on the defaults for the rest.
		</para>    
            </listitem>
            <listitem>
                <para>
                    What can we use &kdchart; for?
		</para>
		<para>
		    &kdchart; is used by a variety of programs for many 
		    different purposes. 
		</para>
		<!-- Pending Michel: insert screen-shot -->
		<!--
                 * Demonstrate in short sentences associated to screen-shots
                    that kdc can be used for both business charts and
                    engineering charts.
		-->
		<para>
		    The above example shows how &kdchart; is used for 
		    visualizing flood events in a river; other samples on our 
		    web site at <filename>http://www.kdab.net/kdchart</filename>
		    show how &kdchart; is used for monitoring seismic activity.
                    It is no coincidence that the current version of the 
		    KOffice productivity suite uses our library.
		</para>
		<para>    
		    <!-- Pending Michel -->
                    * Display a view with small diagrams and arrows showing
                    how the main classes work together
                </para>
            </listitem>
        </itemizedlist>
        <sect1>
            <title id="prerequisites">What You Should Know</title>
            <para>
                You should be familiar with writing Qt applications, as
                well as have a working C++ knowledge. When you are in
                doubt about how a Qt class mentioned in this Programmer's 
		Guide works, please check the Qt reference documentation or 
		a good book about Qt. A more in-depth introduction to the 
		API can be found in the file 
		<filename>doc/KDChart-2.0-API-Introduction</filename>.
                Also to browse &kdchart; API Reference documentation start 
		with this file: <filename>doc/refman/index.html</filename>.
            </para>
        </sect1>
        <sect1>
            <title id="structure">The Structure of This Manual</title>
            <para>
                How we will proceed to present &kdchart;?
            </para>
            <para>
		This manual starts with an introduction to the &kdchart; 2.0 API
		before going through the basic steps and methods for the user 
		to create her own chart.
            </para>
	    <para>
		<!--Pending(Michel) Cross-Refs, here and elsewhere  -->
		The following Chapter 4 <filename>Coordinate planes and 
		Diagrams</filename> will provide the reader with more details 
		about the different chart types supported and the information 
		you need to know in order to use &kdchart;'s features in the 
		best possible way.
	    </para>
	    <para>
		The subsequent chapters contain more advanced customizing 
		material like how to specify colors, fonts and other attributes
		if you don't want to use &kdchart;'s default settings. How to 
		create and display headers, footers and legends as well as how
		to configure your chart axes is also a part of these chapters.
	    </para>
	    <para>
		Chapter 9 <filename>Advanced Charting</filename>, will guide 
		you through &kdchart; other more advanced features and 
		describe the way to use them (frames and backgrounds, 
		data values, axis and grid manipulations etc...). It will also
		show in details a number of interesting features like 
		Interactive and Multiple charts or Zooming.		
	    </para>        
	    <para>
                We provide you with lots of sample code combined with 
		screenshots that show the resulting display. 
                We recommend our readers to try and run the sample code and
                experiment with the various settings.
            </para>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                In the next chapter we introduce you to the &kdchart; 2.0 new API.
            </para>
       </sect1>
    </chapter>

    <!-- ============ Kd Chart 2.0 Api Introduction ============= -->

    <chapter id="chapter_api">
        <title id="chtxt_api">KD Chart 2 API Introduction</title>
        <titleabbrev id="chnum_api">Chapter 2</titleabbrev>
        <para>
            Version 2.0 of KD Chart fully supports and builds on the 
	    technologies introduced with Qt 4. The charting engine makes use 
	    of the Arthur and Scribe painting and text rendering frameworks 
	    to achieve high quality visual results. KD Chart 2.0 also 
	    integrates with the Interview framework for model/view separation 
	    and, much like Qt 4 itself, provides a convenience Widget class 
	    for those cases where that is too complex to use.
        </para>
        <sect1>
            <title id="apioverview">Overview</title>
            <para>
		&kdchart; 2.0  API strives for maximum consistency with 
		the concepts and API style found in Qt 4. Of course, this 
		means breaking source compatibility in several places, but 
		like Trolltech, we have made a conscious decision that it 
		would be better to clean up the API now, than to carry it 
		with us into the next &kdchart; generation. 
	    </para>
	    <note>
		<para>
		    Wherever possible, compatibility methods and classes have 
		    been, or will be, provided.		
		</para>
	    </note>
	    <para>
		The core of &kdchart;'s 2.0 API is the 
		<classname>KDChart::Chart</classname> class.
		It encapsulates the canvas onto which the individual 
		components of a chart are painted, manages them and provides 
		access to them. There can be more than one 
		<classname>KDChart::Diagram</classname> on a 
		<classname>KDChart::Chart</classname>. How they are laid out
		is determined by which axes, if any, they share (more on axes 
		below).
	    </para>
	    <para>
		<classname>KDChart::Diagram</classname> subclasses for the 
		various types of charts are provided, such as 
                <classname>KDChart::PieDiagram</classname>, and users can 
		subclass <classname>KDChart::AbstractDiagram</classname> (or 
		one of the other Diagram classes starting with Abstract, 
		which are designed to be base classes) to implement custom 
		chart types. A typical use of a simple Bar Diagram looks like 
		this:
	    </para>
            <sect2>
                <title id="apisample" xreflabel="codesample">Code Sample</title>
		<programlisting>
using namespace KDChart;
......
BarDiagram *bars = new BarDiagram;
bars->setModel( &amp;m_model );
chart->coordinatePlane()->replaceDiagram( bars );
.....
		</programlisting>
<!-- not relevant
		<para>
		    You Could Also Use The Following Way, To Prevent Your 
		    Compiler From Complaining About Instance Bars Not Being 
		    Free'ed:
		</Para>
                <Programlisting>
		    Bardiagram *Bars = Static_Cast &Lt;Bardiagram *&Gt;
		    (Mychart->Replacediagram( New Bardiagram ));
		    //Now Call The Setter Methods ... 
		</Programlisting>
-->
                <para>
                    In Chapter 3 
		    <filename>Basic steps: Create a Chart</filename> we will 
		    make this somewhat abstract description more concrete by 
		    looking at some complete examples (Widget and Charts), 
		    which we recommend you to compile and run.
		</para>
		<para>
		    For now, in order for you to get an overview about the 
		    KD Chart 2.0 API and its features you need to understand
		    the following base concepts:   
		</para> 
		<itemizedlist>
		    <listitem>
			<para>
			    Each diagram has an associated Coordinate Plane 
			    (Cartesian by default), which is responsible for 
			    the translation of data values into pixel 
			    positions. It defines the scale of the diagram, 
			    and all axes that are associated with it. This 
			    makes implementing diagram subclasses (types) much
			    easier, since the drawing code can delegate the
			    complete coordinate calculation work to the 
			    coordinate plane. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Each coordinate plane can have one or more diagram 
			    associated to it. Those diagrams will share the scale 
			    provided by the plane. A chart can also have more than 
			    one coordinate plane. This makes it possible to have 
			    multiple diagrams (e.g a line and a bar chart) using the 
			    same or different scales and displayed next to, or on top 
			    of each other in the same chart. 
			</para>
		    </listitem>		
		    <listitem>
			<para>
			    In order to share an axis among two planes (and also diagrams)
			    we just need to add it to both diagrams. The Chart 
			    lay-outing engine will take care of adjusting positions 
			    accordingly.
			</para>
		    </listitem>
		    </itemizedlist>
		 <!--
                Pending Michel Link:
		(See Src/Kdchartabstractcoordinateplane.H And
		Examples/Sharedabscissa/Mainwindow.Cpp)
                <Programlisting Linenumbering="Numbered" Id="">
                    <Textobject>
                        <Textdata Fileref="../../Examples/..."/>
                    </Textobject>
                </Programlisting>
                -->
		<para>
		    A chart can also have a number of optional components
		    such as Legends, Headers/Footers or custom 
		    <classname>KDChart::Area</classname> subclasses that
		    implement user-defined elements. The API for manipulating 
		    these is similar for all of them.
		</para>
		<para>
		    For example, in order to add an additional header you can
		    use code like this:
		</para>
		<programlisting>
HeaderFooter * additionalHeader = new HeaderFooter;
additionalHeader->setPosition( NorthWest );
chart->addHeaderFooter( additionalHeader  );
		</programlisting>
		<para>
		    In the next section, we will explain further how ownership
		    of such components is maintained.
		</para>
		<!--
                Pending Michel: point to those files
		(see src/{KDChartChart.h|KDChartLegend.h|KDChartHeaderFooter.h)
		-->
		<para>
		    Finally, and concluding this overview, all classes in the 
		    KD Chart 2 API are in the "KDChart" namespace, to allow 
		    concise class names, while still avoiding name clashes. 
		    Unless you prefer to use the "KDChart::" prefix on all 
		    class names in your code, you can add the following
		    line at the top of your implementation files, to make all 
		    names in the "KDChart" namespace available in that file:
		</para>
		<programlisting>
using namespace KDChart;
		</programlisting>
		<para>
		    Like Qt, KD Chart provides STL-style forwarding headers, 
		    allowing you to omit the ".h" suffix when including 
		    headers. To bring the bar diagram header into your 
		    implementation file, you could therefore write:
		</para>
        <programlisting>
#include &lt;KDChartBarDiagram&gt;
or
#include &lt;KDChartBarDiagram.h&gt;
        </programlisting>
		<note>
		    <para>
			File names of header and implementation files all
			have the "KDChart" prefix in the name. The definition 
			of <classname>KDChart::BarDiagram</classname> is 
			thus located in the file 
			<filename>KDChartBarDiagram.h</filename>.
		    </para>	
		</note>    
            </sect2>
        </sect1>
<!-- Pending Michel: No much to say here for now - Shall we remove this section? Kalle: No, this is a key concept, we should definitely have it.
        <sect1>
            <title id="apihandling">Ownership and Parameters Handling</title>
            <para>
                Text: Shift the following sections: Handling of value
                parameters (e.g Text Attributes) vs Pointer classes.
            </para>
            <sect2>
                <title id="handlingsample" xreflabel="codexample">Code Example</title>
		<para>
                    Let us make this more concrete by looking at the following
                    lines of code........                  
                </para>
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
-->
        <sect1>
            <title id="apiinterview">KD Chart and Interview </title>
            <para>
		
		KD Chart 2.0 follows the Interview model/view paradigm 
		introduced by Qt 4:
	    </para>	
	    <para>
		Any <classname>KDChart::AbstractDiagram</classname> subclass 
		(which in turn inherits 
		<classname>QAbstractItemView</classname>) can display data 
		originating from any <classname>QAbstractItemModel</classname>
		object. In order to use your data with KD Chart diagrams, you 
		need to either use one of Qt's built-in models to manage it, 
		or provide the <classname>QAbstractItemModel</classname> 
		interface on top of your already existing data storage by 
		implementing your own model that talks to that underlying 
		storage. 
            </para>
	    <para>
		<classname>KDChart::Widget</classname> is a convenience class 
		that provides a simpler, but less flexible way of displaying 
		data in a chart. It stores the data it displays itself, and 
		thus does not need a <classname>QAbstractItemModel</classname>.
		It should be sufficient for many basic charting needs but it 
		is not meant to handle very large amounts of data or to make 
		use of user-supplied chart types.
	    </para>
	    <para>
		<classname>KDChart::Widget</classname> is provided in order to 
		get started quickly without having to master the complexities 
		of the new Interview framework in Qt 4. We would still advise 
		to use KDChart::Chart so that you can make use of all the 
		benefits that Interview brings you once you have a good 
		undertanding of it.
	    </para>
	    <para>
		In order to better understand the relationship between 
		<classname>KDChart::View</classname>
		and <classname>KDChart::Widget</classname> better, compare for
		example <classname>KDChart::View</classname> and
		<classname>KDChart::Widget</classname> to 
		<classname>QListView</classname> and 
		<classname>QListWidget</classname> in the Qt 4 documentation. 
		You will clearly notice the similarities.
	    </para>	   
             <sect2>
                <title id="interviewsample" xreflabel="codesample">Code Sample</title>
                <para>		  
                    Let us make this more concrete by looking at the following
                    lines of code where we are using  
		    <classname>QStandardItemModel</classname> to store the 
		    data which will be displayed by the diagram in a 
		    <classname>KDChartChart</classname> widget. 
                </para>                
                <programlisting>
// set up your model
m_model.insertRows( 0, 2, QModelIndex() );
m_model.insertColumns(  0,  3,  QModelIndex() );
for (int row = 0; row &lt; 3; ++row) {
    for (int column = 0; column &lt; 3; ++column) {
        QModelIndex index =
        m_model.index(row, column, QModelIndex());
        m_model.setData(index, QVariant(row+1 * column) );
    }
}
                </programlisting>                
                <para>
                    In order to assign the model above to your diagram and 
		    display it you would proceed as follow:
                </para>
		<programlisting>
KDChart::BarDiagram* diagram = new KDChart::BarDiagram;
diagram->setModel(&amp;m_model);
m_chart.coordinatePlane()->replaceDiagram(diagram);
        </programlisting>
		<para>
		    Using <classname>KDChartWidget</classname> we would use 
		    code as follow:
		</para>
		<programlisting>
KDChartWidget widget;
QVector&lt; double &gt; vec0,  vec1;
vec0 &lt;&lt; -5 &lt;&lt; -4 &lt;&lt; -3 &lt;&lt; -2 &lt;&lt; -1 &lt;&lt; 0 ...;
vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0 ...;
widget.setDataset( 0, vec0, "Linear" );
widget.setDataset( 1, vec1, "Quadratic" );
widget.show();
        </programlisting> 
		<para>
		    We recommend you to read 
		    <filename>KDChartChart.h</filename> and 
		    <filename>KDChartWidget.h</filename> to learn more about 
		    those classes and what they can do. Also compile and run 
		    the complete examples that describe very simply the two 
		    ways you can use to display a Chart.
		</para>
	    </sect2>
        </sect1>
        <sect1>
            <title id="apiattribute">Attribute sets</title>
            <para>
                The various components of a chart such as legends or axes have
		attribute sets associated with them that define the way they 
		are laid out and painted. For example, both the chart itself 
		and all areas have a set of 
		<classname>KDChart::BackgroundAttributes</classname>, which 
		control whether there should be a background pixmap, or a solid
		background color. Other attribute sets include frame attributes
		or grid attributes. The default attributes provide reasonable, 
		unintrusive settings, such as no visible background and no 
		visible frame.
            </para>
	    <para>
		These attribute sets are passed by value, they are intended to
		be used much like Qt's QPen or QBrush. As shown below:
	    </para>
        <sect2>
            <title id="attributesample" xreflabel="codesample">Code Sample</title>
            <programlisting>
KDChart::TextAttributes ta;
ta.setPen( Qt::red );
ta.setFont( QFont( "Helvetica" ) );
chart->legend()->setTextAttributes( ta );
            </programlisting>
                <para>
		    All attribute sets can be set per cell, per column or per 
		    model, and only be queried per cell. Access at the cell 
		    level only ensures that the proper fallback hierarchy can 
		    be observed. If there is a value set at cell level, it 
		    will be used, otherwise the dataset (column) level is 
		    checked. If nothing was found at the dataset level, either
		    the model wide setting is used, and if there is none 
		    either, the default values will be applied. 
		    All of this happens automatically, so that the code using
		    these values only has to ask the cell for its attributes, 
		    and will get the correct values. This avoids duplicating 
		    the fallback logic all over the library and 
		    the application, and avoids thus (expensive) error handling.
                </para>
                <para>
                    When using attributes sets, you need to be aware of this 
		    fallback hierarchy, because e.g. per-cell changes will 
		    hide per-column changes.
		    <!-- Pending Michel: Add some code sample here -->
		    (see files /src/KDChart*Attributes.h)
                </para>
                </sect2>
        </sect1>
        <sect1>
            <title id="apimemory">Memory Management</title>
            <para>
                As a general rule, everything in a KDChart::Chart is owned by 
		the chart. Manipulation of the built-in components of a chart,
		such as for example a legend, happens through mutable pointers
		provided by the view, but those components can also be 
		replaced. 
            </para>
             <sect2>
                <title id="memorysample" xreflabel="codesample">Code Sample</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.                   
                </para>
		<programlisting>
// set the built-in (default) legend visible
m_chart->legend()->setPosition( North );

// replace the default legend with a custom one
//the chart view will take ownership of the allocated
//memory and free the old legend
KDChart::Legend *myLegend =
m_chart->replaceLegend( new Legend );
                </programlisting>
                <para>
		    Similarly, inserting new components into the view
transfers ownership to the chart. Notice that the same procedure has to be 
		    applied for a diagram, too. 		    
                </para>
		<programlisting>
// add an additional legend, chart takes ownership
chart->addLegend( Legend );
                </programlisting>
		<para>
		    Removing a component does not de-allocate it. If you "take"
		    a component from a chart or diagram, you are responsible 
		    for freeing it as appropriate.
		</para> 
		<para>
		    (see files /src/{KDChartChart.h, KDChartLegend.h})
		</para>
		<para>
		    Notice how this pointer-based access to the components of a
		    chart is different from the value-based usage of the 
		    attribute classes; the latter can be copied around freely, 
		    and are meant to be transient in your code; they will be 
		    copied internally as necessary. The reason for the 
		    difference, of course, is polymorphism.
		</para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's Next</title>
            <para>
                Basic steps: Create a Chart or a Widget.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_basicsteps">
        <title id="chtxt_basicsteps">Basic steps: Create a Chart</title>
        <titleabbrev id="chnum_basicsteps">Chapter 3</titleabbrev>
	<para>
	    As described in the previous chapter, there are two ways to create a chart:
	</para>
	<itemizedlist>
	    <listitem>
		<para>
		    <classname>KDChart::Widget</classname> is providing a limited set of 
		    functions as listed in <filename>KDChartWidget.h</filename>. Its 
		    purpose is to provide a convenient and simple way of displaying a chart for people 
		    who do not want to learn about the new Qt Interview system, or who do 
		    not care about more complicated details like the Coordinate Plane and 
		    other classes provided by the &kdchart; 2 API.
		</para>
	    </listitem>
	    <listitem>
		<para>
		   The purpose of
<classname>KDChart::Chart</classname> is to give the user access to
the full power of both the new Qt and the new KD Chart.		
		</para>
	    </listitem>
	 </itemizedlist>
	<para>
	    Basically, <classname>KDChart::Widget</classname> has been designed for 
	    beginners, while <classname>KDChart::Chart</classname> is designed for 
	    experienced users and/or users who need more features and flexibility.
	    Once again, we recommend you to check out both interfaces for those classes in order
	    to give yourself a idea about which of the classes better
matches your needs.( See <filename>KDChartWidget.h</filename> and 
	    <filename>KDChartChart.h</filename> ).
<!-- PENDING(michel) What about changing all those references to
header files to references to the reference documentation?  -->	</para>
	<sect1>          
	    <title id="basicprerequiste">Prerequisites</title>
            <para>
		As described above (Section KD Chart and Interview), a
		prerequisite for using the full KD Chart API is that the data to
		be charted is made available through a class implementing the
		<classname>QAbstractItemModel</classname> interface.
		Before looking at some code, let us show you a few
top-level classes of the KD Chart 2 API:
            </para>
	    <para>
		<itemizedlist>
		    <listitem>
			<para>
			    The "chart" is the central widget acting as a 
			    container for all the charting elements, 
			    including the diagrams themselves, its class is 
			    called <classname>KDChart::Chart</classname>.
			</para>
			<para>
			    A "chart" can hold several coordinate planes
			    (Cartesian and polar coordinates are supported
			    at the moment) each of which can hold several 
			    diagrams.
			</para>    
		    </listitem>
		    <listitem>
			<para>
			    The "coordinate plane" (often called the "plane")
			    represents the entity that is responsible for 
			    mapping the values to positions on the widget.
			    The plane is also showing the (sub-)grid lines.
			    There can be several planes per chart.
			</para>	
		    </listitem>
		    <listitem>
			<para>
			    The "diagram" is the actual plot (bars, lines and 
			    other chart types) representing the
data. There can
			    be several diagrams per coordinate plane.
			</para>	
		    </listitem>
		</itemizedlist>
	    </para>	
        </sect1>
        <sect1>
            <title id="basicprocedure">The Procedure</title>
            <para>
		Let us go through the general procedure for creating a chart, 
		without drilling down into the details too much at
this point. We will then build  a
		complete example and create a small application displaying a 
		chart using <classname>KDChartWidget</classname> and 
		<classname>KDChartChart</classname> respectively.
	    </para>
	    <para>
		First of all, we need to include the appropriate headers, and 
		bring in the "KDChart" namespace:
	    </para>
	    <programlisting>
#include &lt;KDChartChart&gt;
#include &lt;KDChartLineDiagram&gt;
using namespace KDChart;

//Add the widget to your layout like any other QWidget:
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );
	    </programlisting>
	    <para>
		In this example, we will create a single line diagram,
		and use the default Cartesian coordinate plane, which is 
		already contained in an empty Chart object.
	    </para>
	    <programlisting>
// Create a line diagram and associate the data model to it
m_lines = new LineDiagram();
m_lines->setModel( &amp;m_model );

// Replace the default diagram of the default coordinate
// plane with your newly created one.
// Note that the plane takes ownership of the diagram,
// so you are not allowed to delete it.
m_chart->coordinatePlane()->replaceDiagram( m_lines );
	    </programlisting>
	    <para>
		Adding elements such as axes or legends is 
		straightforward as well:
	    </para>
	    <programlisting>
CartesianAxis *yAxis = new CartesianAxis ( m_lines );
yAxis->setPosition ( KDChart::CartesianAxis::Left );

// the diagram takes ownership of the Axis
m_lines->addAxis( yAxis );

legend = new Legend( m_lines, m_chart );
m_chart->addLegend( legend );
	    </programlisting> 
	    <para>
		You can adjust and fine-tune various aspects of the 
		diagrams, planes, legends, etc...
	    </para>
	    <para>
		Much like Qt itself, KD Chart uses a value-based approach 
		to these attributes. In the case of diagrams, most aspects
		can be adjusted at different levels of granularity.
		The QPen that is used for drawing datasets (lines, bars, 
		etc...) can be set either for one data point within a 
		dataset, for a dataset or for the whole diagram. See the file 
		<filename>KDChartAbstractDiagram.h</filename>:
	    </para>
	    <programlisting>
void setPen( const QModelIndex&amp; index, const QPen&amp; pen );
void setPen( int dataset, const QPen&amp; pen );
void setPen( const QPen&amp; pen );
	    </programlisting> 
	    <para>
		To use a dark gray color for all lines in your example 
		chart, you would write:
	    </para>
	    <programlisting>
QPen pen;
pen.setColor( Qt::darkGray );
pen.setWidth( 1 );
m_lines->setPen( pen );
	    </programlisting> 
	    <para>
		Attributes that form logical groupings are combined into
		collection classes, such as 
		<classname>GridAttributes</classname>, 
		<classname>DataValueAttributes</classname>,
		<classname>TextAttributes</classname>, etc....
	    </para>
	    <para>
		This makes it possible to keep sets of such properties 
		around and swap them in one step, based on program state.
		However, you might often want to adjust just one or a few 
		of the default settings, rather than specifying a complete
		new set. Thus in most cases, using the copy constructor of
		the settings class might be appropriate, so in order to use a 
		special font for drawing a legend, for example, you would 
		just write:    
	    </para>    
	    <programlisting>
TextAttributes ta( legend->textAttributes() );
ta.setFont( myfont );
legend->setTextAttributes( ta );
	    </programlisting>
	    <para>
		We will continue with more examples and more detailed 
		information about all those points in the next sections
		and chapters.
		Also, we recommend you to check out and run the examples 
		shipped together with your &kdchart; package.
	    </para>
	</sect1>
	<sect1>
	    <title id="basictwoways">Two Ways To Your Chart</title> 
	    <para>
		We will now go through the basic steps of creating a simple 
		chart widget, first using <classname>KDChart::Widget</classname>
		and then <classname>KDChart::Chart</classname>. This will give
		us an overview about how to proceed in both cases.
	    </para>
	    <sect2>
                <title id="basicwidget" xreflabel="codexample">Widget Example</title>
		<para>
		    We recommend you to read, compile and run the following example.
		    It is available at the following location of your &kdchart; 
		    installation: <filename>examples/Widget/Simple</filename>.
		</para>
		<programlisting linenumbering="numbered" id="widget_simple">
<textobject><textdata fileref="../../examples/Widget/Simple/main.cpp"/></textobject>
		</programlisting>
		<para>
		    The result of the code above will display the simple 
		    widget presented in the screenshot below.
		</para>	
		<para>
		    As you can see, the code is straightforward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Include the headers and bring in the Chart namespace.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Declare your <classname>KDChartWidget</classname>
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Use a <classname>QVector</classname> to store the data to be displayed.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign the stored data to the widget, using one of
			    the available <methodname>setDataset()</methodname> 
			    methods.
			</para>
		    </listitem>	
		</itemizedlist>
		<figure float="0" id="fig-simplewidget">
		    <title>A Simple Widget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplewidget.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Of course, it is possible to add new elements like Title, Headers, Footers,
		    Legends, or Axes to this simple widget as we will
see later in greater 
		    detail. Notice also that the default diagram displayed by  
		    <classname>KDChartWidget</classname> is a 
		    <classname>KDChartLineDiagram</classname>.
		    In the following example, we will look at how to display a Chart widget using
		    <classname>KDChartChart</classname>.
		</para>
	    </sect2>
	    <sect2>	
                <title id="basicchart" xreflabel="codexample">Chart Example</title>
		<para>
		    We recommend you to read, compile and run the following example. It is available
		    at the following location of your KD Chart installation: 
		    <filename>/examples/Widget/Simple</filename>
		</para>
		<programlisting linenumbering="numbered" id="chart_main">
<textobject><textdata fileref="../../examples/Widget/Simple/main.cpp"/></textobject>
		</programlisting>                
		<para>
		    In this example, we are making use of 
		    <classname>QStandardItemModel</classname> in order to insert and 
		    store the data to be displayed by the diagram. We are also
		    implicitly using a <classname>KDChartBarDiagram</classname>
		    to which we assign the model. See below the resulting chart 
		    widget created by this example. 
		</para>
		<figure float="0" id="fig-simplechart">
		    <title>A Simple Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We can of course add more elements to this chart and change its default 
		    attributes as described above. 
		</para>		
		<para>
		    We will see in more detail how to configure those attributes 
		    (Pen, Color, etc ...)and add the various elements (Axes, Legend, Headers 
		    etc...) later.
		</para>
	    </sect2>
        </sect1>
        <sect1>
            <title>What's Next</title>
            <para>
                In the next chapter, we will describe the different
available chart types (diagrams) 
		and their coordinate planes. For each chart type, we
will look at 
		the attributes available for this particular type, and
give you a few examples.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_planesanddiagrams">
        <title id="chtxt_planesanddiagrams">Planes and Diagrams</title>
        <titleabbrev id="chnum_planesanddiagrams">Chapter 4</titleabbrev>
	<para>
	    At the moment, KD Chart supports two types of planes in order to display 
	    the different types of diagrams it supports.
        </para>
        <para>
	 <itemizedlist>
            <listitem>
                <para>
                    A Cartesian coordinate plane, determined by a horizontal axis and a vertical 
		    axis, often called the x axis and y axis. 
                </para>
            </listitem>
            <listitem>
                <para>
                    A Polar coordinate plane which makes use of the radius or the polar angle 
		    which defines the position of a point on a plane.
                </para>
            </listitem>
	</itemizedlist>
	</para>
	<para>
	    This chapter tells you how to change the chart type from the default to any
	    one of the other types. All of the chart types provided by &kdchart; are 
	    presented here with the help of some sample code and/or small programs and their 
	    screenshots.
	</para>
	<para>
	    It will also give us an idea about which chart type could be appropriate for a 
	    specific purpose, and provides information about the features that are available for 
	    each type of chart. Let us first go through some important concept concerning the 
	    planes and their relation to the diagrams and the chart view itself.
	</para>
      	<para>
	    Each coordinate plane can have one or more diagram associated to it. Those diagrams 
	    will share the scale provided by the plane. A chart can also have more than 
	    one coordinate plane. This makes it possible to have multiple diagrams using different 
	    scales and displayed next to, or on top of each other in the same chart. 
	</para>
        <note>
	    <para>
		There are two ways in which planes can be caused to interact in where they are 
                positionned layouting wise: The first is the reference plane.
           </para>		
            <para>
                By using <methodname>AbstractCoordinatePlane::setReferenceCoordinatePlane()</methodname> 
		the user force the calling plane to be layouted in the same cell in as the plane it is 
		referenced too (overLaying).
	    </para>
	    <para>
		Also when planes share an axis they will be layed out in relation to each other as 
		suggested by the position of the axis. If, for example Plane1 and Plane2 share an axis 
		at position Left, that will result in the layout: Axis Plane1 Plane 2, vertically. 
		If Plane1 also happens to be Plane2's reference plane, both planes are drawn over each 
		other. 
	    </para>
	    <para>
		The reference plane concept allows two planes to share the same space even if none has 
		axis, and in case there are shared axis, it is used to decide whether the planes should be 
		painted on top of each other or layed out vertically or horizontally next to each other.
	    </para>
	    <para>
		The above concept is illustrated in 
		<filename>examples/SharedAbscissa/OverlayedDiagrams</filename> and 
		<filename>examples/SharedAbscissa/SeparateDiagrams</filename>, we recommend you
                to study those examples.
	    </para>
	</note>  
        <sect1>
            <title id="cartesianplane">Cartesian Coordinate Planes</title>
            <para>
                &kdchart; uses the Cartesian coordinate system, and in particular its 
		<classname>KDChart::CartesianCoordinatePlane</classname> class for displaying 
		chart types such as lines, bars, points, etc.
            </para>
	    <para>
		In this section, we will describe and present all of
the chart types using the default 
		Cartesian coordinate plane.
	    </para>
	    <para>
		In general, in order to implement a particular type of chart, just create an object of this  
		type by calling <classname>KDChart<replaceable>[type]</replaceable>Diagram</classname>, or if your are using 
		<classname>KDChartWidget</classname>, call its 
		<methodname>setType()</methodname> method and specify
the appropriate chart type (e.g. Widget::Bar, Widget::Line, etc.)		
	    </para>
	    <sect2>
		<title id="bars">Bar Charts</title>
		<tip>
		    <para>
			Bar charts are the most common type of charts
and can be used for 
			visualizing almost any kind of data. Like the Line Charts, the bar 
			charts can be the ideal choice to compare multiple series of data.
		    </para>
		    <para>
			A good example for using a bar chart would be a comparison of the sales 
			figures in different departments, perhaps accompanied by a 
			High/Low Chart showing the key figures of each day.
		    </para>
		</tip>		
		<para>
		    Your Bar Chart can be configured with the following (sub-)types as described in 
		    detail in the following sections: 
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Normal
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Stacked
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Percent
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="barnormal">Normal Bar Charts</title>
		<tip>
		    <para>
			In a normal bar chart, each individual value is displayed as a bar by 
			itself. This flexibility allows you to compare both the values in one series, 
			and values of different series.
                    </para>
		</tip>
		<figure float="0" id="fig-barnormal">
		    <title>A Normal Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplebar.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart;'s default type is the normal bar chart, so no method needs to be 
		    called in order to get one when using 
		    <classname>KDChartBarDiagram</classname>. After
displaying another sub type,
		    you can return to the normal one by calling 
		    <methodname>setType( Normal )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="barstacked">Stacked Bar Charts</title>
		<tip>
		    <para>
			Stacked bar charts focus on comparing the sums of the individual values in 
			each data series, but also show how much each individual value contributes 
			to its sum.
                    </para>
		</tip>
		<figure float="0" id="fig-barstacked">
		    <title>A Stacked Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barstacked.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Stacked mode for bar charts is activated by calling the 
		    <classname>KDChartBarDiagram</classname> function
		    <methodname>setType( Stacked  )</methodname>.
		</para>
	    </sect2>
	    <sect2>
		<title id="barpercent">Percent Bar Charts</title>    
		<tip>
		    <para>
			Unlike stacked bar charts, percent bar charts are not suitable for 
			comparing the sums of the data series, but rather focus on the respective 
			contributions of their individual values.
                    </para>
		</tip>
		<figure float="0" id="fig-barpercent">
		    <title>A Percent Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barpercent.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Percent: Percentage mode for bar charts is activated by calling
		    the <classname>KDChartBarDiagram</classname> function
		    <methodname>setType( Percent )</methodname>.
		</para>		
		<note>
		    <para>
			Three-dimensional look of the bars does not
require a separate diagram type; you can enable it
			for all types (<literal>Normal</literal>,
<literal>Stacked</literal>, and
			<literal>Percent</literal>) by setting its ThreeD attributes; we will 
			describe this in the "Bars Attributes" section further on.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="barsample" xreflabel="codesample">Code Sample</title>	
		<para>
		    For now, let us make the above description more concrete by looking at the 
		    following code sample based on the
<filename>Simple Widget</filename> example you have already seen. In
this example, we show you how to configure your 
		    bar diagram and change its attributes when working with a 
		    <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First, include the appropriate headers and bring in the "KDChart" namespace:
		</para>	    	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;QPen&gt;

using namespace KDChart;
		</programlisting>                
		<para>
		    We need to include <classname>KDChartBarDiagram</classname> in order to be able
		    to configure some of its attributes as we will see later. 
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );
    Widget widget;
    // our widget can be configured
    // as any Qt Widget
    widget.resize( 600, 600 );
    // store the data and assign it
    QVector&lt; double &gt; vec0,  vec1;
    vec0 &lt;&lt; 5 &lt;&lt; 4 &lt;&lt; 3 &lt;&lt; 2 &lt;&lt; 1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5;
    vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 4 &lt;&lt; 9 &lt;&lt; 16 &lt;&lt; 25;
    widget.setDataset( 0, vec0, "vec0" );
    widget.setDataset( 1, vec1, "vec1" );
		</programlisting>
		<para>
		    We want to change the default line chart type to a bar chart type. In this
		    case, we also want to display it in stacked mode. 
		    <classname>KDChartWidget</classname> with its <methodname>setType</methodname>
		    and <methodname>setSubType</methodname> methods
            allow us to achieve that in a very simple way.		    
		</para>
		<programlisting>
    widget.setType( Widget::Bar , Widget::Stacked );
		</programlisting>
		<para>
		    The default type being Normal type for the widget, we need to implicitely pass 
		    the second parameter when calling <methodname>KDChartWidget::setType()</methodname>
		    We can also change the sub type of our bar chart
later, e.g. by calling 
		    <methodname>setSubType( Widget::Percent )</methodname>.		    
		</para>
		<programlisting>
    //Configure a pen and draw a line
    //surrounding the bars
    QPen pen;
    pen.setWidth( 2 );
    pen.setColor(  Qt::darkGray );
    // call your diagram and set the new pen
    widget.barDiagram()->setPen(  pen );
		</programlisting>
		<para>
		    In the above code, our intention is to draw a grey line around the bars to make them
		    look nicer. This technique is called configuring the attributes in a diagram.
		    To do so, we configure a QPen and then assign it to our diagram. 
		    <methodname>KDChartWidget::barDiagram()</methodname> lets get a pointer to 
		    our widget diagram. As you can see, it is very easy to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method.
		</para>
		<programlisting>
    //Set up your ThreeDAttributes
    //display in ThreeD mode
    ThreeDBarAttributes td;
    td.setDepth(  15 );
    td.setEnabled(  true );
    widget.barDiagram()->setThreeDBarAttributes( td );
		</programlisting>
		<para>
		    We want our bar chart to be displayed in 3D mode and need to configure some 
		    ThreeDBarAttributes and assign them to our diagram. Here we are configuring the 
		    depth of the 3D bars and enable 3D mode.
		    Depth is an attribute only available to bar
charts, and its setter and getter methods are implemented 
		    in the <classname>KDChartThreeDBarAttributes</classname>, whereas the 
		    <methodname>KDChartAbstractThreeDAttributes::setEnabled()</methodname> is a generic 
		    attribute available to all chart types. Both of
those attributes are made available at different levels in order to
provide a better attribute structure.
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting>
		<para>
		    See the screenshot below to view the resulting
chart displayed by the code shown above. 
		</para>
		<figure float="0" id="fig-widgetbar">
		    <title>A Simple Bar ChartWidget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/widgetparameters.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Widget/Parameters</filename>
		</para>
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartBarDiagram</classname> making use
			of a <classname>KDChartChart</classname> is
done in the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your bar diagram and assign it to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="barsattributes">Bars Attributes</title>
		<para>
		    By "Bars attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Bar Chart type.
		    The "getters" and "setters" for those attributes can be consulted by looking at
		    <filename>KDChartBarAttributes.h</filename> to get an idea about what can be 
		    configured there. 
		</para>
		<note>
		    <para>
			KD Chart 2.0 API separates the attributes specifics to a chart type itself and
			the generic attributes which are common to all chart types as for example the 
			setters and getters for a brush or a pen and that are accessible from the
			<classname>KDChartAbstractDiagram</classname> interface.  		    
		    </para>
		</note>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartBarDiagram::setBarAttributes()</methodname> or 
		    for example (to change the default Pen) directly by calling the 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname> method.
		</para>
		<para>
		    The procedure is straight forward on both cases. Let us discuss the types 
		    specifics attributes first:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::BarAttributes</classname> object by 
			    calling <methodname>KDChartBarDiagram::barAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::BarDiagram</classname>. All the attributes can be
			    configured to be applied for the whole diagram, for a column, or at a 
			    specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Bar chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    BarWidth: Specifies the width of the bars
			</para>
		    </listitem>
		    <listitem>
			<para>
			    GroupGapFactor: Configure the gap between groups of bars. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    BarGapFactor: Configure the gap between Bars within a group
			</para>
		    </listitem>
		    <listitem>
			<para>
			    DrawSolidExcessArrow: Specify whether the arrows showing excess values
			    should be drawn solidly or split.
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="barattributessample" xreflabel="codesample">Bar Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located in the <filename>examples/Bars/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files we need and bring KD Chart namespace.
		</para>
		<programlisting>
#include &lt;QtGui&gt;
#include &lt;KDChartChart&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;KDChartDataValueAttributes&gt;

using namespace KDChart;
                </programlisting>
		<para>
		    We have included <classname>KDChartDataValueAttributes</classname> to be able 
		    to display our data values. Those attributes are of course used by all types of
		    charts and are not specifical to the Bar diagrams.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram
		</para>
		<programlisting>
class ChartWidget : public QWidget {
Q_OBJECT
public:
    explicit ChartWidget(QWidget* parent=0)
    : QWidget(parent)
    {
        m_model.insertRows( 0, 2, QModelIndex() );
        m_model.insertColumns(  0,  3,  QModelIndex() );
        for (int row = 0; row &lt; 3; ++row) {
            for (int column = 0; column &lt; 3; ++column) {
                QModelIndex index = m_model.index(row, column, QModelIndex());
                m_model.setData(index, QVariant(row+1 * column) );
            }
        }

        BarDiagram* diagram = new KDChart::BarDiagram;
        diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having store our data into the model, we create a diagram, in this 
		    case, we want to display a <classname>KDChartBarDiagram</classname> and 
		    assing the model to our diagram. The procedure is of course similar for 
		    all types of diagrams. 
		</para>
		<para>
		    We are no ready to configure our bar specifics attributes using a 
		    <classname>KDChartBarAttributes</classname> to do so. 
		</para>
		<programlisting>
        BarAttributes ba;
        //set the bar width and
        //implicitely enable it
        ba.setFixedBarWidth( 500 );
        ba.setUseFixedBarWidth( true );
        //configure gab between values
        //and blocks
        ba.setGroupGapFactor( 0.50 );
        ba.setBarGapFactor( 0.125 );

        //assign to the diagram
        diagram->setBarAttributes(  ba );
                </programlisting>
		<para>
		    We want to configure our bars width so that they get displayed a bit larger.
		    The Width of a bar is calculated automatically depending on the gaps between 
		    each bar and the gaps between groups of bars as well as the space available 
		    horizontally in the plane. So those values interact with each other so that 
		    your bars does not exceed the plane surface horizontally.
		    Here we are increasing the value of my bars width and at the same time set 
		    some lower values for the gaps. Which will give us larger bars	    
		</para>
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			<classname>BarAttributes</classname> object to the diagram.
			This can be done for the whole diagram, at a specific index 
			or for a column. See <filename>KDChartBarDiagram.h</filename> and
			look at the methods available there to find out those setters and
			getters.
		    </para>   
		</note>
		<para>
		    We will now display the data values related to each bar making use of
		    KD Chart 2.0 API <classname>KDChartDataValueAttributes</classname>. Those
		    attributes are not specifics to the Bar Chart types but can be used by any 
		    type of charts. The procedure is very similar.
		</para>
		<programlisting>
        // display the values
        DataValueAttributes dva;
        TextAttributes ta = dva.textAttributes();
        //rotate if you wish
        //ta.setRotation( 0 );
        ta.setFont( QFont( "Comic", 9 ) );
        ta .setPen( QPen( QColor( Qt::darkGreen ) ) );
        ta.setVisible( true );
        dva.setTextAttributes( ta );
        dva.setVisible( true );
        diagram->setDataValueAttributes( dva );
		</programlisting>
		<para>
		    We could have displayed the data values without caring about settings its 
		    <classname>KDChartTextAttributes</classname>, but we wanted to do so in 
		    order to demonstrate this feature too. Notice that you have to implicitely
		    enable your attributes ( DataValue and Text) by calling their 
		    <methodname>setVisible()</methodname> methods. After it is configured as we
		    want it is just to assign to the diagram as for all other attributes.  
		</para>
		<para>
		    Finally I want to paint a ligne around one of the datasets bars. In order to
		    keep the attention of the public on this specific set of data. To do so I need to 
		    change the default pen used by my bars for this data set exclusively. Of course we
		    could  also have changed the pen for all datasets or for a specifical index or value.
		</para>
		<programlisting>
        //draw a surrounding line around bars
        QPen linePen;
        linePen.setColor( Qt::magenta );
        linePen.setWidth( 4 );
        linePen.setStyle( Qt::DotLine );
        //draw only around a dataset
        //to draw around all the bars
        // call setPen( myPen );
        diagram->setPen( 1,  linePen );
		</programlisting>
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level in 
			our <classname>KDChartAbstractDiagram</classname> class for a cleaner code 
			structure. Those methods are of course used by all types of diagram and their 
			configuration is very simple and straight forward as you can see in the above 
			sample code. Create a Pen, configure it, call one of the setters methods 
			available (See <filename>KDChartAbstractDiagram.h</filename> about those 
			methods).		
		    </para>
		</note>
		<para>
		    Our attribute having been configured and assigned we just need to assign the Bar 
		    diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
        m_chart.coordinatePlane()->replaceDiagram(diagram);

        QVBoxLayout* l = new QVBoxLayout(this);
        l->addWidget(&amp;m_chart);
        setLayout(l);
    }

    private:
    Chart m_chart;
    QStandardItemModel m_model;
};

int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    ChartWidget w;
    w.show();

    return app.exec();
}

#include "main.moc"
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes relative 
		    to the chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Bars/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-barparameters">
		    <title>Bar with Configured Attributes</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barparameters.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    The subtype of a bar chart (Normal, Stacked or Percent) is not set via its 
		    attribute class, but directly by using the diagram 
		    <methodname>KDChartBarDiagram::setType</methodname> method.  
		</para>
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>		    
	    <sect2>
		<title id="barstips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.
		</para>	
	    </sect2>
	    <sect2>
		<title id="bartipssample" xreflabel="codexample">A complete Bar Example</title>
		<para>		    
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the bar chart subtype (Normal, percent, Stacked).
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Select a column and mark it by changing the generic pen attributes.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display in ThreeD mode and change the Bars depth dynamically. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the Bars width dynamically. 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    To do so we will need to use several types of attributes. Generics one 
		    available to all chart types (e.g 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname>,
		    <classname>KDCHartDataValueAttributes</classname> and 
		    <classname>KDChartTextAttributes</classname> as well as typical bar attributes 
		    only applyable to the Bar types as 
		    <methodname>KDChartBarAttributes::setWidth()</methodname> or 
		    <classname>KDChartThreeDBarAttributes</classname>
		</para>
		<para>
		    We are making use of a <classname>KDChartChart</classname> class and also of 
		    an home made <classname>TableModel</classname> for the convenience and derived 
		    from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Bar chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Bars/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullbar_mainwindow_h">
<textobject><textdata fileref="../../examples/Bars/Advanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The prupose is to let the user configure its bar chart attributes 
		    manually . As you can see we are using a KDChartChart object ( m_chart ),
		    a KDChartBarDiagram object ( m_bars ), and our home made TableModel ( m_model ).		    
		</para>
		<para>
		    The implementation is also straight forward as we will see below:
		</para>
		<programlisting linenumbering="numbered" id="fullbar_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Bars/Advanced/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our bar diagram. We 
		    also want to configure a Pen and surround the displayed bars by a darkGray line
		    to make it somewhat nicer. Finally we assign the diagram to our chart.
		</para>
		<programlisting>
//draw a surrounding line around bars
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );

m_model.loadFromCSV( ":/data" );

// Set up the diagram
m_bars = new BarDiagram();
m_bars->setModel( &amp;m_model );

QPen pen;
pen.setColor( Qt::darkGray );
pen.setWidth( 1 );
m_bars->setPen( pen );

m_chart->coordinatePlane()->replaceDiagram( m_bars );
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
....
if ( text == "Normal" )
    m_bars->setType( BarDiagram::Normal );
else if ( text == "Stacked" )
    m_bars->setType( BarDiagram::Stacked );
....
m_chart->update();
		</programlisting>
		<para>
		    We set the DataValueAttributes on a per-column basis here, because we want the 
		    texts to be printed in different colours - according to their respective 
		    dataset's colour. The user will be able to display or hide the values. 
		</para>
		<programlisting>
...
const QFont font(QFont( "Comic", 10 ));
const int colCount = m_bars->model()->columnCount();
for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
    QBrush brush( m_bars->brush( iColumn ) );
    DataValueAttributes a( m_bars->dataValueAttributes( iColumn ) );
    TextAttributes ta( a.textAttributes() );
    ta.setRotation( 0 );
    ta.setFont( font );
    ta .setPen( QPen( brush.color() ) );
    if ( checked )
    ta.setVisible( true );
    else
    ta.setVisible( false );

    a.setTextAttributes( ta );
    a.setVisible( true );
    m_bars->setDataValueAttributes( iColumn, a);
}

m_chart->update();
....
		</programlisting>
		<para>
		    As you can see in the above code we are changing the default values for 
		    <classname>DataValuesAttributes</classname> <classname>TextAttributes</classname>.
		    Also we allow the usert to display or not the texts dynamically. see 
		    <methodname>KDChartTextAttributes::setVisible()</methodname>.
		</para>
		<para>
		    In order to be able to display our diagram in threeD mode we need to bring 
		    <classname>KDChartThreeDBarAttributes</classname>, and configure it. Here we are 
		    enabling or disabling and change its Depth parameter according to the user 
		    interaction.
		</para>
		<programlisting>
...
ThreeDBarAttributes td( m_bars->threeDBarAttributes() );
double defaultDepth = td.depth();
if ( checked ) {
    td.setEnabled( true );
    if ( threeDDepthCB->isChecked() )
        td.setDepth( depthSB->value() );
    else
        td.setDepth( defaultDepth );
} else {
    td.setEnabled( false );
}
m_bars->setThreeDBarAttributes( td );
m_chart->update();
...
		</programlisting>
		<para>
		    ThreeDBarAttributes are as simple to use as all other Attributes types. 
		    Our next lines of code will make use of the generic 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname> available to
		    all diagram types, to allow the user to mark a column or reset it to 
		    the original Pen interactively. 
		</para>
		<programlisting>
...
const int column = markColumnSB->value();
QPen pen( m_bars->pen( column ) );
if ( checked ) {
    pen.setColor( Qt::yellow );
    pen.setStyle( Qt::DashLine );
    pen.setWidth( 3 );
    m_bars->setPen( column, pen );
}  else {
    pen.setColor( Qt::darkGray );
    pen.setStyle( Qt::SolidLine );
    pen.setWidth( 1 );
    m_bars->setPen( column, pen );
}
m_chart->update();
...
		</programlisting>
		<note>
		    <para>
			It is important to know that have three levels of precedence when setting the 
		    attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    Finally we configure a typical <classname>KDChartBarAttributes</classname>, the Bar 
		    Width, for the user to be able to change the width of the bars dynamically increasing
		    or decreasing its value via the Gui.
		</para>
		<programlisting>
if (  widthCB->isChecked() ) {
    BarAttributes ba( m_bars->barAttributes() );
    ba.setFixedBarWidth( value );
    ba.setUseFixedBarWidth( true );
    m_bars->setBarAttributes( ba  );
}
m_chart->update();
		</programlisting>
		<para>
		    Here we are making use of the 
		    <methodname>KDChartBarAttributes::setUseFixedBarWidth()</methodname> method to 
		    enable or disable the effect. The Bar Width value being passed by the value of 
		    a Spin Box.		    
		</para>
		<para>
		   See how this widget having some attributes enabled is displayed in the following 
		    screen-shot.
		</para>
		<figure float="0" id="fig-fullbar">
		    <title>A Full featured Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullbarchart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Bars/Advanced</filename> directory in your KD Chart installation.
		    We recommend you to run it.
		</para>
	    </sect2>		    	    
            <sect2>
		<title id="lines">Line Charts</title>
		<tip>
		<para>
		    Line charts usually show numerical values and their development in time.
                    Like the Bar Charts they can be used to compare multiple series of data.
		</para>
		<para>
		    An example might be the development of stock values over a longer period of 
		    time or the water level rise on several gauges.	
		</para>
		</tip>
		<para>
		    As for Bar types, &kdchart; can generate line charts of different kind of line 
		    charts. <classname>KDChartLineDiagram</classname> supports the following 
		    subtypes explained below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Normal Line Chart
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Stacked Line Chart 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Percent Line chart
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>	   
	     <sect2>
		<title id="linenormal">Normal Line Charts</title>
		<tip>
		    <para>
			Normal line charts are the most common type of line charts and are used 
			when the datasets are compared to each other individually. For example, if 
			you want to visualize the development of sales figures over time for each 
			department separately, you might have one line per department.
                    </para>
		</tip>
		<figure float="0" id="fig-linenormal">
		    <title>A Normal Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simpleline.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart; draws normal line charts by default when in line chart mode so no 
		    method needs to be called to get one, however after having used your 
                   <classname>KDChartLineDiagram</classname> to display another line chart subtype 
		    you can reset it by calling <methodname>setType( Normal )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="linestacked">Stacked Line Charts</title>
		<tip>
		    <para>
			Stacked line charts allow you to compare the development of a series of 
			values summarized over all datasets. You could use this if you are only 
			interested in the development of total sales figures in your company, but 
			have the data split up by department.
                    </para>
		</tip>
		<figure float="0" id="fig-linestacked">
		    <title>A Stacked Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/linestacked.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		   Stacked mode for line charts is activated by calling the 
		    <classname>KDChartLineDiagram</classname> method 
		    <methodname>setType( Stacked )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="linepercent">Percent Line Charts</title>    
		<tip>
		    <para>
			Percent line charts show how much each value contributes to the total sum, 
			similar to percent bar charts.
                    </para>
		</tip>
		<figure float="0" id="fig-linepercent">
		    <title>A Percent Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/linepercent.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Percent: Percentage mode for line charts is activated by calling
		    the <classname>KDChartLineDiagram</classname> function
		    <methodname>setType( Percent )</methodname>.
		</para>
		<note>
		    <para>
			Three-dimensional look of the lines is no special feature you can enable it
			for all types (<literal>Normal</literal>, <literal>Stacked</literal> or
			<literal>Percent</literal>) by setting its ThreeD attributes class (see 
			<filename>KDChartThreeDLineAttributes.h</filename> to consult its interface).
			We will describe it more in details  in the "Line Attributes" section further 
			on.
		    </para>
		</note>			
	    </sect2>	    
	    <sect2>
		<title id="linesample" xreflabel="codesample">Code Sample</title>
		<para>
		    For now let us make the above description  more concrete by looking at the 
		    following code sample based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example we 
		    demonstrate how to configure your  line diagram and change its attributes when 
		    working with a <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartLineDiagram&gt;
#include &lt;QPen&gt;

using namespace KDChart;
		</programlisting>                
		<para>
		    We need to include <classname>KDChartLineDiagram</classname> in order to be able
		    to configure some of its attributes as we will see further on. 
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );
    Widget widget;
    // our Widget can be configured
    // as any Qt Widget
    widget.resize( 600, 600 );
            // store the data and assign it
    QVector&lt; double &gt; vec0,  vec1;
    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
    widget.setDataset( 0, vec0, "vec0" );
    widget.setDataset( 1, vec1, "vec1" );
    widget.setDataset( 2, vec2, "vec2" );
    widget.setSubType(  Widget::Percent );
		</programlisting>
		<para>
		    We dont need to change the default chart type as Line Charts is the default . 
		    In this case we also want to display it in percent mode. 
		    <classname>KDChartWidget</classname> with its <methodname>setSubType</methodname> 
		    method allow us to achieve that the easy way.		    
		</para>
		<programlisting>
    widget.setSubType( Widget::Percent );
		</programlisting>
		<para>
		    The default sub-type being Normal for all types of charts we need to call 
		    implicitely <methodname>KDChartWidget::setSubType()</methodname> in this case.
		    We can also change the sub-type of our line chart further on by calling for example 
		    <methodname>setSubType( Widget::Stacked )</methodname> or reset its default value by
		    calling <methodname>setSubType( Widget::Normal )</methodname>.		    
		</para>
		<programlisting>
    //Configure a pen and draw
    //a dashed line for column 1
    QPen pen;
    pen.setWidth( 3 );
    pen.setStyle( Qt::DashDotLine );
    pen.setColor(  Qt::green );
    // call your diagram and set the new pen
    widget.lineDiagram()->setPen(  1 , pen );
		</programlisting>
		<para>
		     In the above code our intention is to draw a new style of line for this 
		    specific dataset in order to keep the attention of the public on it.
		    That is what we call configuring an attribute. In this case the pen attribute. 
		    To do so we configure a QPen and then assign it to our diagram. 
		    <methodname>KDChartWidget::lineDiagram()</methodname> allow us to get a pointer to 
		    our widget diagram. As you can see it is very simple to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method.
		</para>
		<programlisting>
    //Display in Area mode
    LineAttributes ld;
    ld.setDisplayArea( true );
    //configure transparency
    //it is nicer and let us
    //all the area
    ld.setTransparency( 25 );
    widget.lineDiagram()->setLineAttributes( ld );
		</programlisting>
		<para>
		    The code above makes use of typical <classname>KDChartLineAttributes</classname> and
		    let us diplay the areas as well as set up the color transparency which is very 
		    helpfull when displaying a normal chart type where the areas can hide each other. 
		    Finally we conclude our small example:
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-simplelinewidget">
		    <title>A Simple Line ChartWidget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplelinewidget.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Lines/SimpleLineWidget</filename>
		</para>
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartLineDiagram</classname> making use
			of a <classname>KDChartChart</classname> is done the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your line diagram and assign the diagram to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>
		</sect2>
	        <sect2>	
		<title id="linesattributes">Lines Attributes</title>
		<para>
		    There are only a few attributes specific to a line chart as it is using a Pen 
		    to draw the lines. Pen and Brush are generic attributes common to all types of 
		    diagrams and are handled by <classname>KDChartAbstractDiagram</classname> from 
		    which <classname>KDChartLineDiagram</classname> is derived indirectly.
		</para>
		<para>
		    However to make it simple for the user we have added some convenient functions 
		    to the <classname>KDChartLineAttributes</classname> in order to be able to 
		    display Areas and set transparency for all subtypes of a line chart. We will 
		    go through those methods further on in our Area charts section in this Chapter. 
		</para>
		<para>
		    <classname>KDChartLineDiagram</classname> combined with its attributes and 
		    methods or combined together with 
		    <classname>KDChartMarkerAttributes</classname> let us display the line chart 
		    subtypes as described above as well as Area Charts and Point charts the easy 
		    way. We will of course present all those alternatives with some sample code 
		    and ready to use examples in the next sections.
		</para>
		<para>
		    The use of LineAttributes is as simple as for the other chart types:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::LineAttributes</classname> object by 
			    calling <methodname>KDChartLineDiagram::lineAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::LineDiagram</classname>. All the attributes can 
			    be configured to be applied for the whole diagram, for a column, or at 
			    a specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Line chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			  MissingValuesPolicy: Specifies how missing values will be shown in a
			  line diagram. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			  Display area: paint the area for a dataset. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			  Area transparency: set the transparency for the displayed area color. 
			</para>
		    </listitem>
		</itemizedlist>
		<note>
		    <para>
			All other attributes as ThreeDLineAttributes (specific to line charts), 
			or MarkerAttributes, DataValueAttributes and TextAttributes ..etc..
			available to all types of charts are of course also available to the 
			line charts types and sub-types.
		    </para>
		</note>
	    </sect2>	
	    <sect2>
		<title id="lineattributessample" xreflabel="codesample">Line Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located in the <filename>examples/Lines/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files and bring KD Chart namespace.
		</para>
		<programlisting>
#include &lt;QtGui&gt;
#include &lt;KDChartChart&gt;
#include &lt;KDChartLineDiagram&gt;
#include &lt;KDChartDataValueAttributes&gt;

using namespace KDChart;
                </programlisting>
		<para>
		    We have included <classname>KDChartDataValueAttributes</classname> to be able 
		    to display our data values. Those attributes are of course used by all types of
		    charts and are not specifical to the Line diagram.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram. 
		</para>
		<programlisting>
class ChartWidget : public QWidget {
Q_OBJECT
public:
    explicit ChartWidget(QWidget* parent=0)
    : QWidget(parent)
    {
        m_model.insertRows( 0,5, QModelIndex() );
        m_model.insertColumns( 0,5, QModelIndex() );

        for( int i = 0; i &lt; 5; ++i ) {
            for( int j = 0; j &lt; 5; ++j ) {
                m_model.setData( m_model.index( i,j,QModelIndex() ), (double)i*j );
            }
        }

        LineDiagram* diagram = new LineDiagram;
        diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having stored our data into the model, we create a diagram. In this 
		    case, we want to display a <classname>KDChartLineDiagram</classname>. 
		    As always we need to assign the model to our diagram. This procedure is of 
		    course similar for all types of diagrams. 
		</para>
		<para>
		    We are now ready to configure our attributes. We want to display the data 
		    values and configure the text and font for those.
		</para>
		<programlisting>
        // Display values
        // 1 - Call the relevant attributes
        DataValueAttributes dva( diagram->dataValueAttributes() );
        // 2 - We want to configure the font and colors
        //     for the data values text.
        TextAttributes ta( dva.textAttributes() );
        //rotate if you wish
        //ta.setRotation( 0 );
        // 3 - Set up your text attributes
        ta.setFont( QFont( "Comic", 6 ) );
        ta .setPen( QPen( QColor( Qt::darkGreen ) ) );
        ta.setVisible( true );
        // 4 - Assign the text attributes to your
        //     DataValuesAttributes
        dva.setTextAttributes( ta );
        dva.setVisible( true );
        // 5 - Assign to the diagram
        diagram->setDataValueAttributes( dva );
        </programlisting>
		<para>
		    As for all attributes we call them by using the relevant method available
		    from our diagram interface, here 
		    <methodname>diagram->dataValueAttributes()</methodname>. The second step 
		    is to set it up with our own values and finally we assign it to our diagram.
		</para>
		<para>
		    We could have displayed the data values without caring about settings its 
		    <classname>KDChartTextAttributes</classname>, but we wanted to do so in 
		    order to demonstrate this feature too. Notice that you have to implicitely
		    enable your attributes ( DataValue and Text) by calling their 
		    <methodname>setVisible()</methodname> methods before we assign it to the 
		    diagram.  
		</para>
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			attributes to the diagram. This can be done for the whole diagram, at a 
			specific index or for a column. Look at the attributes interface  and look 
			at the methods available there to find out those setters and getters.
		    </para>   
		</note>
		<para>
		    We want to configure the Pen in order to draw a section of a line (dataset)
		    differently. e.g. We want to focus the attention of the reader on this 
		    particular section.
		</para>
		<programlisting>
        // Draw a the section of a line differently.
        // 1 - Retrieve the pen for the dataset and change
        //    its style.
        //    This allow us to keep the line original color.
        QPen linePen(  diagram->pen( 1 ) );
        linePen.setWidth( 3 );
        linePen.setStyle( Qt::DashLine );
        // 2 - Change the Pen for a section within a line
        while assigning it to the diagram
        diagram->setPen( m_model.index( 1, 1, QModelIndex() ), linePen );
		</programlisting>	
		<para>
		    Of course we could  also have changed the pen for a single or all datasets as
		    well. See how we call the pen for this very dataset before changing its style
 		    and width. This is done to keep its original color for consistancy. Alos
		</para>		
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level 
			in our <classname>KDChartAbstractDiagram</classname> class for a cleaner 
			code structure. Those methods are of course used by all types of diagram 
			and their configuration is very simple and straight forward as you can see 
			in the above sample code. Create or get a Pen , configure it, call one of 
			the setters methods available (See 
			<filename>KDChartAbstractDiagram.h</filename> about those methods).
		    </para>
		</note>
		<para>
		    Our attribute having been configured and assigned we just need to assign our
		    line diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
        m_chart.coordinatePlane()->replaceDiagram(diagram);

        QVBoxLayout* l = new QVBoxLayout(this);
        l->addWidget(&amp;m_chart);
        setLayout(l);
    }

private:
    Chart m_chart;
    QStandardItemModel m_model;
};

int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    ChartWidget w;
    w.show();

    return app.exec();
}

#include "main.moc"
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes for 
		    all chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Lines/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-samplelinechart">
                <title>Line With Configured Attributes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/samplelinechart.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    The subtype of a line chart (Normal, Stacked or Percent) is not set via its 
		    attribute class, but directly by using the diagram 
		    <methodname>KDChartLineDiagram::setType</methodname> method.  
		</para>
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>	
	    <sect2>
		<title id="linestips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget. 
		</para>	
	    </sect2>
	    <sect2>
		<title id="linetipssample" xreflabel="codexample">A complete Line Example</title>
		<para>		 
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the line chart subtype (Normal, percent, Stacked).
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Display Areas for one or several for one or several dataset(s). 
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Run a small animation highlighting the areas one after the other.
			</para>
		    </listitem>		    
		</itemizedlist>
		<para>
		    To do so we will need to use several types of attributes and methods, as 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname>,
		    <classname>KDCHartDataValueAttributes</classname> and 
		    <classname>KDChartTextAttributes</classname>.
		</para>
		<para>
		    We are making use of a <classname>KDChartChart</classname> class and also of 
		    an home made <classname>TableModel</classname> for the convenience and derived 
		    from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullline_mainwindow_h">
<textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually . As you can see we are using a KDChartChart object ( m_chart ),
		    a KDChartLineDiagram object ( m_lines ), and our home made TableModel ( m_model ).
		</para>
		<para>
		    The implementation is also straight forward as we will see below:
		</para>    		
		<programlisting linenumbering="numbered" id="fullline_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.cpp"/></textobject>
		</programlisting>		
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our line diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
...
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );

m_model.loadFromCSV( ":/data" );

// Set up the diagram
m_lines = new LineDiagram();
m_lines->setModel( &amp;m_model );
m_chart->coordinatePlane()->replaceDiagram( m_lines );

// Instantiate the timer
QTimer *timer = new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(slot_timerFired()));
timer->start(40);
...
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
....
if ( text == "Normal" )
m_lines->setType( LineDiagram::Normal );
else if ( text == "Stacked" )
m_lines->setType( LineDiagram::Stacked );
else if ( text == "Percent" )
m_lines->setType( LineDiagram::Percent );
....
m_chart->update();
		</programlisting>
    		<para>
		    We want the user to be able to display or hide the data values from the 
		    GUI, and also change the default font for our data values labels to make 
		    it nicer. 
		</para>
		<programlisting>
const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
    DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
    QBrush brush( m_lines->brush( iColumn ) );
    TextAttributes ta( a.textAttributes() );
    ta.setRotation( 0 );
    ta.setFont( QFont( "Comic", 10 ) );
    ta.setPen( QPen( brush.color() ) );
    
    if ( checked )
    ta.setVisible( true );
    else
    ta.setVisible( false );
    a.setVisible( true );
    a.setTextAttributes( ta );
    m_lines->setDataValueAttributes( iColumn, a );
}
m_chart->update();
		</programlisting>		
		<para>
		    In the code above, we make sure our data values labels will be painted 
		    using the dataset default color by retrieving the brush for each dataset 
		    and assigning the color of the brush to the pen.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    The user should be able to display the area for one or several dataset.  
		</para>
		<programlisting>
....
LineAttributes la = m_lines->lineAttributes(
m_lines->model()->index( 0, column, m_lines->rootIndex() ) );
if ( checked ) {
    la.setDisplayArea( true );
    la.setTransparency( opacity );
}  else {
    la.setDisplayArea( false );
}
m_lines->setLineAttributes( column, la );
...
m_chart->update();
...
		</programlisting>
		<para>
		    This is implemented by configuring our line attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting <filename>examples/Lines/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/Advanced</filename> directory in your KD Chart
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-advancedline">
		    <title>A Full featured Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/advancedlinechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<note>
		    <para>
			The following sections about Point charts and Area are tightly related to line charts. 
			Point charts are line diagrams with Markers (lines themselves are not painted). Area 
			charts are also line charts with the area below the lines, filled by the respective 
			dataset's color.
		    </para>
		</note>
	    </sect2>	  	
            <sect2>
		<title id="points">Point Charts</title>
		<tip>
		    <para>
			Point charts often are used to visualize a big number of data in 
			one or several datasets. A well known point chart example is the 
			historical first Herzsprung-Russel diagram from 1914 where circles
			represented stars with directly measured parallaxes and crosses were 
			used for guessed values of stars from star clusters similar to the 
			following simple chart.
		    </para>
		</tip>
		<figure float="0" id="fig-simplepointchart">
                <title>A Point Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/pointwidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<note>
		    <para>
			Unlike the other chart types in &kdchart; the point chart is not a type of 
			its own but actually a special kind of Line Chart. The resulting display is 
			obtained by painting markers instead of lines as we will see in the following 
			code sample. 
		    </para>
		</note>
		<para>
		    The process for creating a point chart is very simple as described below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Set up a line diagram and configure its pen to Qt::NoPen.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Display its data values marker attributes. 
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="pointsample" xreflabel="codesample">Point Sample Code</title>
		<para>
		    The following code sample is going through the process described above to obtain 
		    a very simple point chart. It is based on the 
		    <filename>examples/Widget/Simple</filename> which code has been slightly modified
		    to display a Point diagram.
		</para>
		<programlisting>
...
//  Hide the lines
widget.lineDiagram()->setPen(  Qt::NoPen );
// Set up the Attributes
DataValueAttributes dva( widget.lineDiagram()->dataValueAttributes() );
MarkerAttributes ma(  dva.markerAttributes() );
TextAttributes ta(  dva.textAttributes() );
ma.setVisible( true );
// display values or not
ta.setVisible(  false );
dva.setTextAttributes(  ta );
dva.setMarkerAttributes(  ma );
dva.setVisible( true );

widget.lineDiagram()->setDataValueAttributes( dva );
                </programlisting>
		<para>
		    This sample code is making use of a <classname>KDChartWidget</classname> and a 
		    <classname>KDChartLineDiagram</classname> but of course the process is very 
		    similar if we were working with a <classname>KDChartChart</classname>. 
		</para> 
		<para>
		    We recommend you to run the complete example presented in the following Tips 
		    section.
		</para>
	    </sect2>
	    <sect2>
		<title id="pointsattributes">Points Attributes</title>
		<para>
		    As you have probably deduced from the section above, point charts are line 
		    charts configured with no pen to avoid displaying the lines and using the 
		    generic classes <classname>KDChartDataValueAttributes</classname> and its 
		    <classname>KDChartMarkerAttributes</classname> available to all other diagram
		    types supported by KD Chart 2.0.
		</para>	
		<para>
		    For this reason we will for now point you to the sections related to those 
		    subjects and in particular to Chapter 5 - Customizing your Chart - Section 
		    Markers or Chapter 9 - Advanced Charting - Section Data Value Manipulation
		    and finalize this section by implementing a full featured point chart in the 
		    Tips section below.
		</para>
	    </sect2>	    
	    <sect2>
		<title id="pointstips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.  
		</para>	
	    </sect2>
	    <sect2>
		<title id="pointtipssample" xreflabel="codexample">A complete Point Example</title>
		<para>
		    <!-- Pending michel show a nice full featured point chart with as many 
		    attributes as possible - The following text and list has to be modified 
		    after we have written our own more complete example - 
		    see NotForCustomers/KDChart20-Manual-Examples.txt  -->
		    In the following implementation we want to be able to:			
		</para>
		<itemizedlist>		   
		    <listitem>
			<para>
			   Be able to configure the points styles, color and size.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display data values or hide it.
			</para>
		    </listitem>		  		   
		    <listitem>
			<para>			    
			  Shift between points and lines charts
			</para>
		    </listitem>		   
		</itemizedlist>		
		<para>
		    We are using a <classname>KDChartChart</classname> class and also an home made 
		    <classname>TableModel</classname> for the convenience. It is  derived from 
		    <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/PointChart</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullpoint_mainwindow_h">
<textobject><textdata fileref="../../examples/Lines/PointChart/mainwindow.h"/></textobject>
		</programlisting>   
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartLineDiagram object (m_lines), and our home made TableModel (m_model).
		</para>
		<para>
		    The implementation is similar to the line chart implementation presented earlier:
		</para>    		
		<programlisting linenumbering="numbered" id="fullpoint_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Lines/PointChart/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>
		    Here we will not comment in details the code as it is similar to what we have seen 
		    before in our line chart example, but only pick up the interesting part of it.
		</para>
		<para>
		    In order to get a point chart we paint or hide the lines by setting our line diagram
		    pen:
		</para>
		<programlisting>
void MainWindow::on_paintLinesCB_toggled(  bool checked )
{
    const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
    for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
        DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
        QBrush lineBrush( m_lines->brush( iColumn ) );
        if ( checked ) {
            QPen linePen( lineBrush.color() );
            m_lines->setPen(  iColumn,  linePen );
        }
        else
            m_lines->setPen( iColumn,  Qt::NoPen );
    }
    m_chart->update();
}
		</programlisting> 
		<para>
		    We need to retrieve the pen color before resetting it to its original value, and do 
		    that by looping through the datasets.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    For us to be able to store different Markers style we make use of 
		    <methodname>MarkerAttributes::MarkerStylesMap map</methodname> which is 
		    very convenient in this case.
		</para>
		<programlisting>
...
MarkerAttributes::MarkerStylesMap map;
map.insert( 0, MarkerAttributes::MarkerSquare );
map.insert( 1, MarkerAttributes::MarkerCircle );
map.insert( 2, MarkerAttributes::MarkerRing );
map.insert( 3, MarkerAttributes::MarkerCross );
map.insert( 4, MarkerAttributes::MarkerDiamond );
...
MarkerAttributes ma( dva.markerAttributes() );
ma.setMarkerStylesMap( map );
....
		</programlisting>
		<para>
		    The user may also change the size of the marker form the GUI and this is 
		    implemented straight forward by using 
		    <classname>KDChartMarkerAttributes</classname> method
		    <methodname>setMarkerSize()</methodname>.
		</para>
		<programlisting>
ma.setMarkerSize( QSize( markersWidthSB->value(),
                         markersHeightSB->value() ) );
		</programlisting>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/PointChart</filename> directory in your KD Chart
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullpoint">
		    <title>A Full featured Point Chart</title>
		    <mediaobject>
			<imageobject>			    
			    <imagedata width="3in" scalefit="1" fileref="images/featuredpointchart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	    </sect2>	  
	    <sect2>
		<title id="areas">Area Charts</title>
		<tip>
		    <para>
			Even more than a Line Chart (of which they are attributes) an area chart 
			can give a good visual impression of different datasets and their relation
			to each other.
		    </para>
		    <para>
			For example the area chart type might be the best choice for showing how 
			several sources contributed to increasing ozone values in a conurbation
			during a summer's months.
		    </para>
		</tip>
		<para>
		    Area charts are Line Charts and thus based upon several points which are 
		    connected by lines&mdash;the difference to the line chart is that the area 
		    below a line is filled by the respective dataset's color. This gives a clear
		    appreciation of each dataset's relative values.
	        </para>
		<para>
		    In order to make it possible to see all points, since some are covered by 
		    another dataset's area, we have introduced an attribute which allow the user 
		    to configure the level of transparency (more about that in the Attributes
		    paragraph of this section.
		    KD Chart 2.0 supports of course Area display for all subtypes of line charts 
		    and thus allow also the user to display the non-overlapping line types. The 
		    following types can be displayed very simply in Area mode:
		</para>
		<itemizedlist>		   
		    <listitem>
			<para>
			    Normal Line Area 
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Stacked Line Area.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Percent Line Area.
			</para>
		    </listitem>		    			   
		</itemizedlist>	
		<figure float="0" id="fig-simpleareachart">
                <title>An Area Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplearea.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
		</figure>
		<note>
		    <para>&kdchart; uses the term &quot;area&quot; in two different
			ways which can be distinguished easily:
		    </para>
		    <itemizedlist>
			<listitem>
			    <para>
				In this chapter it stands for a special chart type or even more
				accurately as a line diagram attribute.
			    </para>
			</listitem>
			<listitem>
			    <para>
				In other context it can also point to the different (normally 
				rectangular) parts of a chart like for example the 
				<emphasis>legend area</emphasis> or the 
				<emphasis>headers area</emphasis>.
			    </para>
			</listitem>
		    </itemizedlist>
		    <para>
			This varying usage of the word &quot;area&quot; should Not cause a lack 
			of clarity: In the context of this special section on 
			<emphasis>area charts</emphasis> the word is clear, in the rest of the 
			manual it just means a part of a chart.
		    </para>
		</note>
		<para>
		    Displaying the area for a dataset or the whole diagram is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a LineAttribute object by calling <methodname>KDChartLineDiagram::lineAttributes</methodname>
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Display it. You can also configure the level of transparency. 
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="areasample" xreflabel="codesample">Area Sample Code</title>
		<para>
		    Let us make this more concrete by looking at the following lines of code
		    and reproduce the process described above:	   
		</para>
		<programlisting>
// Create a LineAttribute object
LineAttributes la = m_lines->lineAttributes( index );
// set Display implicitely
la.setDisplayArea( true );
// Assign to the diagram
m_lines->setLineAttributes( index, la );
                </programlisting>
		<para>
		    Of course Brush and Pen settings as well as all other configurable attributes 
		    accessible by the diagram itself can be set, which give the user a lot of 
		    flexibility ( display or hide data values, markers, lines, configure colors 
		    etc ...). 
		</para>
		<note>
		    <para>
		        <classname>KDChartLineAttributes</classname> can be set for the whole diagram, 
			for a dataset or for a specific index (see sample code above), as for any 
			other attributes.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="areaattributes">Area Attributes</title>
		<para>
		    There are no specifical attributes related to the Area chart. As explained 
		    above Area charts display mode is implemented as a Line Attribute. Of course the 
		    generic attributes common to all chart types are availables, which give us full
		    flexibility to configure our Area chart.
		</para>	
	    </sect2>	    	
	    <sect2>
		<title id="areatips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.  
		</para>	
	    </sect2>
	    <sect2>
		<title id="areatipssample" xreflabel="codexample">A complete Area Example</title>
		<note>
		    <para>
			This example has already been presented in details 
			<filename>Section - A Complete Line Example</filename>.
			You dont need to go through it, if you already have studied the section above.		
		    </para>
		</note>
		<para>		  
		    In the following implementation we want to be able to:			
		</para>
		<itemizedlist>
		    <!-- Pending Michel to be implemented -->
		    <listitem>
			<para>
			   Display data values
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Shift line types (Normal, Stacked, Percent)
			</para>
		    </listitem>
		    <listitem>			
			<para>
			  Display areas for each dataset on its own and for the whole diagram
			</para>
		    </listitem>			   		    		   
		</itemizedlist>
		<para>
		    We are using a <classname>KDChartChart</classname> class and also an home made 
		    <classname>TableModel</classname> for the convenience. It is  derived from 
		    <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullarea_mainwindow_h">
<textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartLineDiagram object (m_lines), and our home made TableModel (m_model).
		</para>
		<para>
		    The implementation is similar to the line chart implementation presented earlier:
		</para>    
		<programlisting linenumbering="numbered" id="fullarea_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our line diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
...
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );

m_model.loadFromCSV( ":/data" );

// Set up the diagram
m_lines = new LineDiagram();
m_lines->setModel( &amp;m_model );
m_chart->coordinatePlane()->replaceDiagram( m_lines );

// Instantiate the timer
QTimer *timer = new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(slot_timerFired()));
timer->start(40);
...
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
....
if ( text == "Normal" )
    m_lines->setType( LineDiagram::Normal );
else if ( text == "Stacked" )
    m_lines->setType( LineDiagram::Stacked );
else if ( text == "Percent" )
    m_lines->setType( LineDiagram::Percent );
....
m_chart->update();
		</programlisting>
    		<para>
		    We want the user to be able to display or hide the data values from the 
		    GUI, and also change the default font for our data values labels to make 
		    it nicer. 
		</para>
		<programlisting>
const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
    DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
    QBrush brush( m_lines->brush( iColumn ) );
    TextAttributes ta( a.textAttributes() );
    ta.setRotation( 0 );
    ta.setFont( QFont( "Comic", 10 ) );
    ta.setPen( QPen( brush.color() ) );

    if ( checked )
        ta.setVisible( true );
    else
        ta.setVisible( false );
    a.setVisible( true );
    a.setTextAttributes( ta );
    m_lines->setDataValueAttributes( iColumn, a );
}
m_chart->update();
		</programlisting>		
		<para>
		    In the code above, we make sure our data values labels will be painted 
		    using the dataset default color by retrieving the brush for each dataset 
		    and assigning the color of the brush to the pen.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    The user should be able to display the area for one or several dataset.  
		</para>
		<programlisting>
....
LineAttributes la =
m_lines->lineAttributes(
m_lines->model()->index( 0, column, m_lines->rootIndex() ) );
if ( checked ) {
    la.setDisplayArea( true );
    la.setTransparency( opacity );
} else {
    la.setDisplayArea( false );
}
m_lines->setLineAttributes( column, la );
...
m_chart->update();
...
		</programlisting>
		<para>
		    This is implemented by configuring our line attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting <filename>examples/Lines/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/Advanced</filename> directory in your KD Chart
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullarea">
		    <title>A Full featured Area Chart</title>
		    <mediaobject>
			<imageobject>			    
			    <imagedata width="3in" scalefit="1" fileref="images/fullareachart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	    </sect2>
<!--	  	
	    <sect2>
		<title id="highlow">High/Low Charts</title>		
		<tip>
		    <para>
			High/low charts could be useful if your value's evolution during a time 
			period should be visualized looking at small segments of this time.  
			Often they are used to display a share's opening and closing value per day,
			as well as each day's maximum and minimum.  Other possible uses of high/low
			charts include the changing temperature during the months: open/close would
			stand for a month's first and last day then.
		    </para>
		</tip>
		<para>
		    Typically high/low charts are used to display one value evolving over the 
		    time&mdash;for showing more than one value consider using another chart type 
		    or use a second <classname>KDChartWidget</classname> positioned next to the
		    first one. Another option might be to show a line chart for all of your values 
		    and draw special attention to one of them by adding an extra high/low chart 
		    featuring this value.The high/low chart could be positioned above the line
		    chart&mdash;sharing its abscissa axis.
		</para>	 
		<para>
		    High/low charts are the most simple ones of &kdchart;'s statistical chart types
		    and unlike the sophisticated Box&amp;Whisker Charts they do not calculateeach 
		    dataset's high/low/open/close values but it is your obligation to pass these 
		    numbers into the data cells. This is done for optimization: most likely you 
		    have these figures anyway, if not it is extremely easy to determine them.
		</para>
		<para>
		    The advantage of not stuffing all your data values into &kdchart; is that such 
		    very small datasets (holding just four cells each) enable your high/low charts 
		    to be displayed very quickly and even when representing a large number of days 
		    they will not consume too  much memory.
		</para>
		<para>
		    High Low Charts can be configured with the following sub types as described in 
		    details below: Simple and Open/Close.
		</para>		
	    </sect2>
	    <sect2>
		<title id="hilosimple">Simple High/Low Charts</title>
                <tip>
                    <para>
			Simple high/low charts (not showing open nor close values) can be useful to
			give an overview about an item's largest and smallest values per 
			time-segment. You can use such a chart if your values beginning and end 
			values are not interesting because the important information is 
			represented by its minima and maxima: e.g. this might be the highest/lowest
			temperature reached in a year where your chart might show the evolution of 
			these values during a span of some 100 years.
                    </para>    
                </tip>	

		<figure float="0" id="fig-hilosimple">
		    <title>A Simple High/Low Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplehilo.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart; by default draws normal high/low charts without showing any open or 
		    close marks when in High/Low Chart mode so no methods need to be called to get 
		    such charts, however after having used your 
		    <classname>KDChartParams</classname> to display another high/low chart
		    type you can call
		    <methodname>setHiLoChartSubType( KDChart::HiLoNormal )</methodname>
                    to return to the default subtype.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="hiloopenclose">Open/Close High/Low Charts</title>
		<tip>
                    <para>
			Extended open/close high/low charts provide a view on the start and end 
			values as well as on the maximal and minimal values of a specific item
			per time-segment. This kind of chart is useful if your item's start and 
			end value is of special importance too, e.g. typically such charts are
			used to visualize the evolution of per-day figures in a financial share 
			value diagram displaying one or several weeks.
                    </para>
                </tip>
		 <figure float="0" id="fig-openclosehilo">
                    <title>An Open/Close High/Low Chart </title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/openclosehilo.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	        <para>
		    To make  draw the open and close lines too you call the "classname"
		    <classname>KDChartParams</classname> function
                    <methodname>setHiLoChartType( KDChart::HiLoOpenClose )</methodname>
		    "methodname". In case you are not interested in the open value (e.g. because 
		    this would always be identical to the respective previous close value) just 
		    use <literal>HiLoClose</literal> instead.  
		</para>
	    </sect2>
	    <sect2>
		<title id="hilolabels">High/Low Charts with Custom Data Labels</title>
		<tip>
                    <para>
			Adding data labels to your High/Low chart can be useful if your chart is 
			displaying a rather limited number items: otherwise it might be a better 
			idea to draw the lines without showing the data labels but show a few 
			labels instead using "method".
                    </para>
                </tip>		
                <figure float="0" id="fig-hilocustom">
                    <title>A High/Low Chart With Custom Data Labels</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/hilowithvalues.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>	
               </sect2> 	    
	    <sect2>
		<title id="hlsample" xreflabel="codexample">High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
		</para>		
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="hlattributes">High Low Attributes</title>
		<para>
		    Text ...
		</para>	
	    </sect2>
	    <sect2>
		<title id="hlattributessample" xreflabel="codexample">High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>			
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="hltips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>
	    </sect2>	
	    <sect2>
		<title id="hltipssample" xreflabel="codexample">A complete High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>			
		<para>
		    More explanation?
		</para>   
	    </sect2>	   
	    <sect2>
		<title id="boxwhisker">Box and Whisker Charts</title>
		<para>
		    This chart is called box&amp;whisker because of its look: a box in the middle 
		    and two lines looking like whiskers on each side.  While the box surrounds the
		    center half of your spreading values, the upper and lower whisker ends are 
		    framing all or most of the values, except from a few outliers indicated 
		    separately.
		</para>
		<para>
		    Box&amp;whisker charts provide detailed descriptive statistics of a variable: 
		    The height of the box shows how close together the main part of your values are
		    and the length of the whiskers indicate how far the other values spread.
		</para>
		<tip>
		    <para>
			Since box&amp;whisker charts give an overview of your values distribution 
			(plus their mean and average value) they can be used for a quick estimate 
			without looking into your statistical tables. An example might be a 
			comparison of the number of failures in a device, perhaps three datasets 
			of some 30 computer chips each to compare their errors at three different 
			temperatures. Each of the data cells containing the number of failures
			shown by one chip your chart would show three boxes: you might expect both 
			a lower error number (with the box being drawn nearer to the abscissa axis)
			and less variation (smaller box and whiskers) at lower temperature.
		    </para>
		</tip>
		<para>
		    Box&amp;whisker charts are the most sophisticated ones of &kdchart;'s 
		    statistical chart types: unlike the simple High/Low Charts 
		    <emphasis>they calculate</emphasis> each dataset's statistical values 
		    themselves.
		</para>
		<para>
		    You can activate the box&amp;whisker chart mode by calling the 
		    "classname" <classname>KDChartParams</classname> function
		    "methodname" 
		    <methodname>setChartType( KDChartParams::BoxWhisker )</methodname>. 
		</para>
		<note>
                  <para>
		      Some notes about configuring colors and lines width
	          </para>
                </note>	
	    </sect2>	    
	    <sect2>
		<title id="bwnormal">Normal Box&amp;Whisker Charts</title>
                <tip>
                    <para>
			Normal box&amp;whisker charts are used to get a quick overview about your 
			spreading data and see the show outliers.
                    </para>
                </tip>
		<figure float="0" id="fig-simplebwchart">
                    <title>A Normal Box&amp;Whisker Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
				fileref="images/simplebwchart.png"
				width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>		
            </sect2>
	    <sect2>
                <title id="bwstripped">Box&amp;Whisker Charts without Outliers</title>
                <tip>
                    <para>
			If outlier values would dilute the message of your chart or simply be 
			visually unpleasant, you can turn them off as described here.
                    </para>
                </tip>
                <figure float="0" id="fig-bwstripped">
                    <title>A Box&amp;Whisker Chart Without Outliers</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/bwstripped.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    To suppress drawing of any markers for <emphasis>outliers</emphasis> or
                    <emphasis>extremes</emphasis> just set their size to zero by calling
		    "methodname"  <methodname>setBWChartOutValMarkerSize( 0 )</methodname> 
                    as demonstrated by the tutorial file "filename", of course you could also use 
		    a value different from zero to set them to a specific size:
                    "methodename" <methodname>setBWChartOutValMarkerSize( -50
                        )</methodname>  would increase their dynamic size by factor two since 
		    -25 is the default setting (a quarter of the box width), while "methodname"
		    <methodname>setBWChartOutValMarkerSize( 15 )</methodname> would set 
		    them to a fixed size of 15pt ignoring the size of the widget.
               </para>
                <note>
                    <para>This special mode might require some additional explanation to tell your 
			users that the outliers and extremes are suppressed: otherwise the chart
                        might be interpreted wrongly since it looks like 
			<emphasis>there are no</emphasis> outliers but all values are within the 
			inner fences or the box area.
                    </para>
                </note>
            </sect2>
	     <sect2>
                <title id="bwstatistics">Box&amp;Whisker Charts with Statistics</title>
                <tip>
                    <para>
			By showing statistical values in your box&amp;whisker charts, you can make 
			your charts even more expressive - at the possible expense of readability.
                    </para>
                </tip>
                <figure float="0" id="fig-bwstatistics">
                    <title>A Box&amp;Whisker Chart With Statistical Values</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/bwstatistics.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    Box&amp;whisker charts can print up to ten different statistical figures next 
		    to the respective boxes&mdash;each of which can be shown using specific fonts, 
		    text color,and background colors.
                </para>
                <para>
		    Printing of a statistical value is enabled by passing one of the
                    <literal>KDChartParams::BWStatVal</literal> enum's descriptive names
                    (<literal>UpperOuterFence</literal>, <literal>UpperInnerFence</literal>,
                    <literal>Quartile3</literal>, <literal>Median</literal>,
                    <literal>Quartile1</literal>, <literal>LowerInnerFence</literal>,
                    <literal>LowerOuterFence</literal>, <literal>MaxValue</literal>,
                    <literal>MeanValue</literal>, <literal>MinValue</literal>)
                    to the following function:
                </para>
		<programlisting>
		    void KDChartParams::setBWChartPrintStatistics( BWStatVal statValue,
		    bool active,
		    QFont* font = 0,
		    int size = 24,
		    QColor* color = 0,
		    QBrush* brush = 0 );
		</programlisting>
                <para>
		    Parameters:
		</para>
                <variablelist>
		    <varlistentry>
			<term><literal>statValue</literal></term>
			<listitem>
			    <para>one of the enum values listed above</para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>active</literal></term>
			<listitem>
			    <para>set to true to have the <literal>statValue</literal>
				printed using either the default fond and color or the
				settings specified by the following parameters
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>font</literal></term>
                    <listitem>
			    <para>if not zero the font will be used for this
				statistical value
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>size</literal></term>
			<listitem>
			    <para>if not zero this value will be interpreted as
				percent of the actual box width: font size will
				be calculated dynamically then instead of using
				the <literal>font</literal> parameter's fixed size
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>color</literal></term>
			<listitem>
			    <para>the text color of this statistical value</para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>brush</literal></term>
			<listitem>
			    <para>the color of the background of this statistical
				value, if set to Qt::NoBrush the background is
				<emphasis>not</emphasis> erased before the text
				is printed
			    </para>
			</listitem>
		    </varlistentry>
                </variablelist>
                <para>
		    Compile and run the tutorial file

                     <ulink url="../../doc/tutorial/step01w/kdchart_step01w.cpp"> 
                        <filename>kdchart_step01w.cpp</filename>
                    </ulink>
		    
                    to see a box&amp;whisker chart featuring all possible statistical value texts 
		    using custom font settings and a special background color for the boxes 
		    (see also <xref linkend="fig-bwstatistics"/>).
                </para>
                <note>
                    <para>
			No fence values are printed for the middle series in our sample 
			(<xref linkend="fig-bwstatistics"/>) because they are outside of 
			the chart's data area.  This can occur if all values of a series are in 
			the inner fences and the box.  Since in this case there is no need to show 
			the fence values the range of the ordinate axis is <emphasis>not</emphasis>
			extended but the chart uses the available space to have more room for 
			displaying the other datasets which otherwise would have less vertical 
			space to draw their boxes and whiskers.
                    </para>
                </note>
            </sect2>
	    <sect2>
		<title id="bwsample" xreflabel="codexample">Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
	        <title id="bwattributes">Box and Whisker Attributes</title>
		<para>
	        Text ...
	        </para>	 
	    </sect2>
	    <sect2>
		<title id="bwattributessample" xreflabel="codexample">Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="bwtips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>	
	    </sect2>
	    <sect2>
		<title id="bwtipssample" xreflabel="codexample">A complete Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    -->	   
	</sect1>
	<sect1>
            <title id="polarplane">Polar coordinate plane</title>
	    <para>
                KD Chart makes use of the Polar coordinate system, and in particular its 
		<classname>KDChart::PolarCoordinatePlane</classname> class for displaying 
		chart types like Pie, Polar and Ring.
            </para>
	    <para>
		In this section we will describe and present each of the chart types which uses 
		the Polar coordinate plane.
	    </para>
	    <para>		
		In general to implement a particular type of chart, just create an object of this  
		type by calling <classname>KDChart[type]Diagram</classname>, or if your are using 
		<classname>KDChartWidget</classname> you will need to call its 
		<methodname>setType()</methodname> and specify the appropriate chart type.
 		(e.g Widget::Pie, Widget::Polar etc...)
	    </para>
	    <sect2>
		<title id="piecharts">Pie Charts</title>	    
		<tip>
		    <para>
			Pie charts can be used to visualize the relative values of a few data 
			cells (typically 2..20 values). Larger amounts of items can be hard to 
			distinguish in a pie chart, so a Percent Bar Chart might fit your needs 
			better then. Pie charts are most suitable if one of the data elements 
			covers at least one forth, preferably even more of the total area.
		    </para>
		    <para>
			A good example is the distribution of market shares among
			products or vendors.
		    </para>
		    <para>
			While pie charts are nice for displaying <emphasis>one</emphasis>
			dataset there is a complementary chart type you might choose
			to visualize several datasets: the Ring Chart, a circular multi dataset
			chart type described in the <filename>Ring Charts</filename> section furhter 
			on.
		    </para>
		</tip>	
		<para>
		    Pie charts typically consist of two or more pieces any number of which can be 
		    shown 'exploded' (shifted away from the center) at different amounts, starting
		    position of the first pie can be specified and your pie chart can be drawn in 
		    three-D look. Activating the pie chart mode is done by calling the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType( KDChartWidget::Pie )</methodname> or by creating an object
		    of this type using the <classname>KDChartPieDiagram</classname> class.
		</para>
		<note>
		    <para>
			Three-dimensional look of the pies is no special feature you can enable 
			by setting its ThreeD attributes, we will describe that more in details
			Chapter 5 - Customizing your Chart - ThreeD section further on.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="piesimple">Simple Pie Charts</title>
                <tip>
                    <para>
			A simple pie chart shows the data without emphasizing a special item.
                    </para>
                </tip>
		<!-- change this example against one with legends and datavalue display -->
                <figure float="0" id="fig-simplepiechart">
                    <title>A Simple Pie Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/simplepie.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    &kdchart; by default draws two-dimensional pie charts when in pie chart mode 
		    so no method needs to be called to get one. We are describing more in details
		    about how to obtain three dimensional look for a pie chart in the following 
		    Pie Attributes section.
                </para>		               
	    </sect2>
	    <sect2>
                <title id="pieexploding">Exploding Pie Charts</title>
                <tip>
                    <para>
			Explode individual segments to emphasize individual data.
                    </para>
                </tip>
                <figure float="0" id="fig-pieexplode">
                    <title>An Exploding Pie Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/pieexploding.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>                                
                <para>
                    We will go through all the configuration possibilities in the Pie Attributes
		    section below, but let us study some code sample first.
                </para>
            </sect2>	   
	    <sect2>
		<title id="piesample" xreflabel="wcodesample">Code Sample</title>
		<para>
		    For now let us make the above description  more concrete by looking at the 
		    following code sample based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example we 
		    demonstrate how to configure your Pie diagram and change its attributes when 
		    working with a <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartPieDiagram&gt;
#include &lt;QPen&gt;

using namespace KDChart;
		</programlisting>                
		<para>
		    We need to include <classname>KDChartPieDiagram</classname> in order to be able
		    to configure some of its attributes as we will see further on. 
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );
    Widget widget;
    // our Widget can be configured
    // as any Qt Widget
    widget.resize( 600, 600 );
    // store the data and assign it
    QVector&lt; double &gt; vec0,  vec1;
    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
    widget.setDataset( 0, vec0, "vec0" );
    widget.setDataset( 1, vec1, "vec1" );
    widget.setDataset( 2, vec2, "vec2" );
    widget.setType(  Widget::Pie );
		</programlisting>
		<para>
		    We just need to change the default chart type (Line Charts) by calling  
		    the <methodname>KDChartWidget::setType</methodname> method.     
		</para>		
		<para>
		    Now let us configure a Pen to draw a line arount the Pie and its section
		</para>
		<programlisting>		   
    QPen piePen( widget.pieDiagram()->pen() );
    piePen.setWidth( 3 );
    piePen.setColor( Qt::yellow );
    // call your diagram and set the new pen
    widget.pieDiagram()->setPen( 2, piePen );
		</programlisting>		
		<para>
		    Here we are configuring the pen "attribute". As you can see it is straight forward.
		    <methodname>KDChartWidget::pieDiagram()</methodname> allow us to get a pointer to 
		    our widget diagram. As you can see it is very simple to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method. 
		</para>			
		<para>
		    Finally we conclude our small example:
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-samplepiewidget">
                <title>A Simple Pie Widget</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplepiewidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Pie/Simple</filename>
		</para>	
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartPieDiagram</classname> making use
			of a <classname>KDChartChart</classname> is done the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your pie diagram and assign the diagram to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>	
	    </sect2>
	    <sect2>
		<title id="pieattributes">Pies Attributes</title>
		<para>
		    By "Pie attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Pie Chart type.
		    KD Chart 2.0 API separates the attributes specifics to a chart type itself and 
		    the generic attributes which are common to all chart types as for example the 
		    setters and getters for a brush or a pen (See 
		    <classname>KDChartAbstractDiagram</classname> or 
		    <classname>KDChartPieAbstractDiagram</classname> etc...		    
		</para>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartPieDiagram::setPieAttributes()</methodname>.
		</para>
		<para>
		    The procedure is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::PieAttributes</classname> object by 
			    calling <methodname>KDChartPieDiagram::pieAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::PieDiagram</classname>. All the attributes can be
			    configured to be applied for the whole diagram, for a column, or at a 
			    specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Pie chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Explode: Enable/Disable exploding pie piece(s)
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Explode factor: The explode factor is a qreal between 0 and 1, it 
			    is interpreted as a percentage of the total available radius.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   StartPosition: Set the starting angle for the first dataset. 
			    Can only be specified for the whole diagram.
			</para>
		    </listitem>
		     <listitem>
			<para>
			   Granularity: Set the granularity: the smaller the granularity the 
			    more your diagramsegments will show facettes instead of rounded 
			    segments. Can only be specified for the whole diagram.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    PieAttributes: set or retrieve the pie diagram Attributes.
			    ( see: <classname>KDChartAbstractPieDiagram</classname> )
			</para>
		    </listitem>
		    <listitem>
			<para>
			    ThreeDPieAttributes: set or retrieve the diagram ThreeDAttributes.
			    ( see: <classname>KDChartAbstractPieDiagram</classname> )
			</para>
		    </listitem>		    
		</itemizedlist>
		<tip>
		    <para>
			The default explode factor is 10 percent; use 
			<methodname>setExplodeFactor</methodname> to specify a different factor.
			This is a convenience function: Calling 
			<methodname>setExplode( true )</methodname> does the same as calling 
			<methodname>setExplodeFactor( 0.1 )</methodname>, and calling 
			<methodname>setExplode( false )</methodname> does the same as calling 
			<methodname>setExplodeFactor( 0.0 )</methodname>.
		    </para>
		</tip>
		<para>
		    To get a pie chart like the one presented above (having one or several of the 
		    pieces separated from the others in <emphasis>exploded</emphasis> mode) you 
		    would have to set its attributes by calling 
		    <methodname>KDChartPieAttributes::setExplode </methodname> or 
		    <methodname>KDChartPieAttributes::setExplodeFactor</methodname> if you want to
		    change the explode factore default value and then use the available methods to 
		    assing those attributes to your diagram as shown in the following code sample 
                </para>
		<programlisting>
// 1 - Create a PieAttribute object
PieAttributes pa (m_pie->PieAttributes());
// 2 - Enable exploding, point to a dataset and give the
// explode factor passing the dataset number and the factor
pa.setExplodeFactor( 0.5 );
// 3 - Assign to your diagram
m_pie->setPieAttributes( column, pa);
		</programlisting>	
		<note>
		    <para>
			Three-dimensional look of the pies can be enable and configured  
			by setting its ThreeD attributes the same way as we are setting the 
			PieAttributes in the code sample above, we will describe that more in 
			details	Chapter 5 - Customizing your Chart - ThreeD section further on.
		    </para>
		</note>		
	    </sect2>
	   <sect2>
		<title id="pieattributessample" xreflabel="acodesample">Pie Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located in the <filename>examples/Lines/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files and bring KD Chart namespace.
		</para>
		<programlisting>
#include &lt;QtGui&gt;
#include &lt;KDChartChart&gt;
#include &lt;KDChartPieDiagram&gt;
#include &lt;KDChartPieAttributes&gt;

using namespace KDChart;
                </programlisting>
		<para>
		    We have included <classname>KDChartPieAttributes</classname> to be able 
		    to configure exploding for one of the pie slice. Those attributes are 
		    specifical to the Pie types.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram. 
		</para>
		<programlisting>
    m_model.insertRows( 0, 1, QModelIndex() );
    m_model.insertColumns(  0,  6,  QModelIndex() );
    for (int row = 0; row &lt; 1; ++row) {
        for (int column = 0; column &lt; 6; ++column) {
            QModelIndex index =
            m_model.index(row, column, QModelIndex());
            m_model.setData(index, QVariant(row+1 * column+1) );
        }
    }
    // We need a Polar plane for the Pie type
    PolarCoordinatePlane* polarPlane =
    new PolarCoordinatePlane( &amp;m_chart );
    // replace the default Cartesian plane with
    // our Polar plane
    m_chart.replaceCoordinatePlane( polarPlane );

    // assign the model to our pie diagram
    PieDiagram* diagram = new PieDiagram;
    diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having stored our data into the model, we create a need to replace 
		    the default Cartesian plane against a Polar plane before creating our Pie diagram. 
		    In this case, we want to display a <classname>KDChartPieDiagram</classname>. 
		    As always we need to assign the model to our diagram. This procedure is of course 
		    similar for all types of diagrams. 
		</para>
		<para>
		    We are now ready to configure our attributes. We want to explode a section and 
		    configure a Pen to surround it. Let us begin with the specifical 
		    <methodname>PieAttributes</methodname>.
		</para>
		<programlisting>
    // Configure some Pie specifical attributes

    // explode a section
    PieAttributes pa(  diagram->pieAttributes() );
    pa.setExplodeFactor( 0.1 );

    // Assign the attributes
    // to the diagram
    diagram->setPieAttributes( 1,  pa );
                </programlisting>
		<para>
		    As for all attributes we call them by using the relevant method available
		    from our diagram interface, here 
		    <methodname>diagram->PieAttributes()</methodname>. The second step is to 
		    set it up with our own values and finally we assign it to our diagram.
		    In the above code we explode the second slice (dataset) in our Pie.
		</para>	
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			attributes to the diagram. This can be done for the whole diagram, at a 
			specific index or for a column. Look at the attributes interface  and look 
			at the methods available there to find out those setters and getters.
		    </para>   
		</note>
		<para>
		    We want to configure the Pen in order to draw a surrounding line around the 
		    exploded section (dataset) to focus the attention of the reader on this particular 
		    section.
		</para>
		<programlisting>
    // Configure a generic attribute
    // available to all chart types
    QPen sectionPen;
    sectionPen.setWidth( 5 );
    sectionPen.setStyle( Qt::DashLine );
    sectionPen.setColor( Qt::magenta );

    diagram->setPen( 1, sectionPen );
		</programlisting>	
		<para>
		    Of course we could  also have changed the pen for all datasets as well.
		</para>		
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level 
			in our <classname>KDChartAbstractDiagram</classname> class for a cleaner 
			code structure. Those methods are of course used by all types of diagram 
			and their configuration is very simple and straight forward as you can see 
			in the above sample code. Create or get a Pen , configure it, call one of 
			the setters methods available (See 
			<filename>KDChartAbstractDiagram.h</filename> about those methods).
		    </para>
		</note>
		<para>
		    Our attributes having been configured and assigned we just need to assign our
		    Pie diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
    // Assign our diagram to the Chart
    m_chart.coordinatePlane()->replaceDiagram(diagram);

    QVBoxLayout* l = new QVBoxLayout(this);
    l->addWidget(&amp;m_chart);
    setLayout(l);
}
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes for 
		    all chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Pie/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-samplepiechart">
                <title>Pie With Configured Attributes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/samplepiechart.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>		
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>	
	    <sect2>
		<title id="pietips">Tips and Tricks</title>
		<para>
		    In this section we want to go through some examples about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.   
		</para>	
	    </sect2>
	    <sect2>
		<title id="pietipsample" xreflabel="codexample">A complete Pie Example</title>
		<para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
<!-- Pending Michel not implemented yet -->
<!--
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
-->
		     <listitem>
			<para>
			   Configure the Start position .
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display a Pie chart and shift between normal and threeD look.
			</para>
		    </listitem>
<!-- Pending Michel not implemented yet is that still actual ? -->
<!--
		     <listitem>
			<para>
			   Enable or disable the use of shadow colors when in threeD mode 
			</para>
		    </listitem>
-->		    
		    <listitem>
			<para>			    
			   Explode one or several slices and  set a surrounding line 
			   around  exploded sections
			</para>
		    </listitem>	
		    <listitem>
			<para>			    
			   Run an animation (exploding). 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Pie chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Pie/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullpie_mainwindow_h">
<textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartPieDiagram object (m_pie), and our home made TableModel (m_model).
		</para>
		<note>
		    <para>
			Before diplaying our Pie diagram we need to implicitely replace the default 
			cartesian plane by a Polar plane.
		    </para>
		</note>
        <programlisting linenumbering="numbered" id="fullpie_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our pie diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
...
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );

m_model.loadFromCSV( ":/data" );

// Set up the plane
PolarCoordinatePlane* polarPlane = new PolarCoordinatePlane( m_chart );
m_chart->replaceCoordinatePlane( polarPlane );

// Set up the diagram
m_pie = new LineDiagram();
m_pie->setModel( &amp;m_model );
m_chart->coordinatePlane()->replaceDiagram( m_pie );

// Instantiate the timer
QTimer *timer = new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(slot_NextFrame() ) );
...
		</programlisting>
		<para>
		    The user should be able to change the start position from the GUI. This can 
		    be implemented by using <classname>KDChartPieAttributes</classname> 
		    as shown below and by updating the view.
		</para>
		<programlisting>
....
PieAttributes pa( m_pie->pieAttributes() );
pa.setStartPosition( pos );
m_pie->setPieAttributes( pa );
m_chart->update();
        ....
		</programlisting>
    		<para>
		    We want the user to be able to shift between 3D mode display  or the normal  
		    standard display from the GUI. 
		</para>
		<programlisting>
// note: We use the global getter method here, it will fall back
// automatically to return the default settings.
ThreeDPieAttributes tda( m_pie->threeDPieAttributes() );
tda.setEnabled( toggle );
tda.setDepth( threeDFactorSB->value() );
m_pie->setThreeDPieAttributes( tda );
m_chart->update();
		</programlisting>				
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    We want the user to be able to explode one or several slice(s) (dataset) and
		    to configure the exploding factor.
		</para>
		<programlisting>
....
// note: We use the per-column getter method here, it will fall back
// automatically to return the global (or even the default) settings.
PieAttributes pa( m_pie->pieAttributes( column ) );
pa.setExplodeFactor( value );
m_pie->setPieAttributes( column, pa );
...
m_chart->update();
...
		</programlisting>
		<para>
		    This is implemented by configuring our pie attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting 
		    <filename>examples/Pie/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Pie/Advanced</filename> directory in your KD Chart
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullpie">
		    <title>A Full featured Pie Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullpiechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>	    	  	
	    </sect2>
<!-- comment for now not implemented yet -->
<!--	  
            <sect2>
		<title id="rings">Ring Charts</title>
		 <tip>
		    <para>
			While a Pie Chart might be a good choice when displaying a single data 
			series, using a ring chart might be ideal for visualizing a small amount 
			of data cells stored in several datasets: ring charts can show both the
			relative values of the cells compared to their dataset's total value 
			<emphasis>and</emphasis> the relation of the series totals compared to 
			each other. This is done by using relative ring widths as shown below.
		    </para>
		</tip>
		<para>
		    Ring charts (like Pie Charts ) typically consist of two or more segments any 
		    number of which can be shown 'exploded' (shifted away from the center).
		    To activate the ring chart mode simple call the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType(Widget::Ring)</methodname> or create an object of type 
		    <classname>KDChartRingDiagram</classname>
		</para>
	    </sect2>
	     <sect2>
                <title id="ringsimple">Simple Ring Charts</title>
                <tip>
                    <para>
			If you do not care about the relative size of the sums of values in each 
			datasets, simple ring charts are is the good choice.
                    </para>
                </tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-simpleringchart">
                    <title>A Simple Ring Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/simplering.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    &kdchart; by default draws non-exploded rings with equal thickness when in 
		    ring chart mode so no methods need to be called.
                </para>
                <para>
		    Compile and run the example file "SimpleRing" to see obtain normal ring chart.
                </para>
            </sect2>
	    <sect2>
                <title id="ringrelative">Ring Charts with Relative Thickness</title>
                <tip>
                    <para>
			Looking similar to a tree's annual rings these charts might be a good 
			choice for displaying several years-related volumes of data like sales
			numbers.  The segments could stand for the different product lines in a 
			sortiment of goods. Looking at a ring's thicknesses you then could see
			the change in sales for <emphasis>all</emphasis> of your goods while a 
			segment's length would show you how much this product line has contributed 
			to the respective year's total turnover&mdash;compared to your other 
			products.
                    </para>
                </tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-ringrelative">
                    <title>A Ring Chart With Relative Thickness</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/ringrelativethickness.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    Relative thickness mode is activated by calling the 
		    <classname>KDChartRingAttributes</classname> function 
                    <methodname>setRelativeThickness( true )</methodname>
                    where each ring represents one dataset and the ring widths show the relations 
		    of the dataset totals to each other.
                </para>
                <para>
		    Compile and run the example RingRelativeThickness to see a ring chart 
		    featuring three datasets: the thickness of the middle ring shows clearly 
		    that this series represents the biggest total value.
                </para>
            </sect2>
	     <sect2>
                <title id="ringexploding">Ring Charts Exploding Segments</title>
                <tip>
                    <para>
			<emphasis>Explode</emphasis> one or several of the segments of your ring 
			chart to emphasize the respective data cell(s).  You might use this for
                        drawing attention to sales figures below a critical level of for 
			highlighting a very successful item.
                    </para>
                </tip>
                <para>
		    To have one or several segments of your ring chart shown exploded you need to
		    to set its attributes and implicitely enable exploding, by calling  
		    <methodname>KDChartPieAttributes::setExplode </methodname> and then use the 
		    available methods to set the exploding factor for a particular dataset. 
		    as shown in the Ring Attribute section coming next. 
                </para>	        
                <para>
		    In case you want to apply <emphasis>different</emphasis> explode factors to the
                    segments just call the 
		    <methodname>KDChartRingAttributes::setExplodeFactors()</methodname> function 
		    and pass to it a <literal>KDChartRingAttributes::ExplodeFactorsMap</literal>
                    with one <literal>double</literal> value for every segment. The following ring 
		    chart has exploded all segments with values less than their ring's average 
		    while the smallest value is exploded even more.
                </para>
		<tip>
		    <para>
			You will find all you need to know for configuring your ring chart in our 
			Ring Attribute section below.
		    </para>    
		</tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-ringexplode">
                    <title>A Ring Chart With Exploding Segments</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/ringexploded.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    Compile and run the example RingExploded to see a ring chart featuring both 
		    relative thickness  of the rings and differently exploded segments on the 
                    outer ring. 
                </para>                
            </sect2>
-->
	    <!-- commenting this part until we have something to show -->
	    <!--
	    <sect2>
		<title id="ringsample" xreflabel="codexample">Ring Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.		   
		</para>		
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    -->
<!--
	    <sect2>
		<title id="ringsattributes">Rings Attributes</title>
		<para>
		    By "Ring Attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Ring Chart type.
		    KD Chart 2.0 API separates the attributes specifics to a chart type itself and 
		    the generic attributes which are common to all chart types as for example the 
		    setters and getters for a brush or a pen.		    
		</para>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartRingDiagram::setRingAttributes()</methodname>.
		</para>
		<para>
		    The procedure is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::RingAttributes</classname> object by 
			    calling <methodname>KDChartRingDiagram::ringAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::RingDiagram</classname>. All the attributes can 
			    be configured to be applied for the whole diagram, for a column, or at 
			    a specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Ring chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Not implemented yet
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Not implemented yet
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Not implemented yet 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Not implemented yet
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    To get a ring chart like the one presented above (having one or several of the 
		    pieces separated from the others in <emphasis>exploded</emphasis> mode) you 
		    would have to set its attributes and implicitely enable exploding, by calling  
		    <methodname>KDChartRingAttributes::setExplode </methodname> and then use the 
		    available methods to set the exploding factor for a particular dataset. 
		    as shown in the following code sample 
                </para>
		<programlisting>
		    // 1 - Create a RingAttributes object
		    RingAttributes ra = m_ring->RingAttributes( index );
		    // 2 - Enable exploding, point to a dataset and give the 
		    // explode factor passing the dataset number and the factor 
		    ra.setExplode( true );
		    ra.setExplodeFactor( 2, 0.5 );
		    // 3 - Assign to your diagram
		    m_ring->setRingAttributes( index, pa);
		</programlisting>  
-->
      		<!-- Pending Michel Is that still true ? -->
<!--
		<note>
                    <para>
			Only segments that are located on the <emphasis>outer</emphasis>
                        ring can be exploded.
                    </para>
                </note>
	    </sect2>
	     <sect2>
		<title id="ringstips">Tips and Tricks</title>
		<para>
		    In this section we want to go through some examples about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.   
		</para>	
	    </sect2>
	    <sect2>
		<title id="ringtipsample" xreflabel="codexample">A complete Ring Example</title>
		<para>
-->
		    <!-- Pending michel show a nice full featured Ring chart with as many 
		    attributes as possible - The following text and list has to be modified 
		    after we have written our own more complete example - 
		    see NotForCustomers/KDChart20-Manual-Examples.txt  -->
<!--
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		     <listitem>
			<para>
			   Display a ring using most of its attributes
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Run an animation (exploding). 
			</para>
		    </listitem>
		</itemizedlist>
		<programlisting linenumbering="numbered" id="fullring_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>
		    More explanation h file?
		</para>
		<programlisting linenumbering="numbered" id="fullring_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    More explanation cpp file?
		</para>
		<figure float="0" id="fig-fullring">
		    <title>A Full featured Ring Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullpiechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>	    	  	
	    </sect2>
-->
<!--
	    <sect2>
		<title id="polarchart">Polar Charts</title>
		 <tip>
		    <para>
			Polar charts got their name from displaying &quot;polar coordinates&quot; 
			instead of Cartesian coordinates. Currently only normalized polar charts 
			can be shown: all values advance by the same number of polar degrees
			and there is no way to specify a data cell's angle individually. While 
			this is ideal for some situations it is not possible to display true world 
			map data like this since you can not specify each cell's rotation angle.
			Transforming your coordinates to the Cartesian system and using a
			Point Chart might be a solution in such cases.
		    </para>
		</tip>
		<para>		    
		    To activate the polar chart mode simply call the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType(Widget::Polar)</methodname> or create an object of type 
		    <classname>KDChartPolarDiagram</classname> and assign it to your 
		    <classname>KDChartChart</classname> by calling its 
		    <methodname>replaceDiagram()</methodname> method.
		</para>	
	    </sect2>
	    <sect2>
		<title id="simplepolarchart">A Simple Polar Charts</title>
		<para>
		    Just like the Line Charts to which they can be compared the polar chart type is
		    divided into three sub types which can be activated by calling 
		    <methodname>setType( KDChartPolarDiagram::Normal )</methodname>
		    or <literal>Stacked</literal> or <literal>Percent</literal>.
		</para>
		<para>
		    Compile and run the example file "PolarSimple" to see a normal polar chart as 
		    shown below. 		
		</para>
-->
		<!-- temporarely commented until we have an example to show -->
		<!--
		 <figure float="0" id="fig-simplepolarchart">
                <title>A Normal Polar Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplepolar.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		-->
<!--
		<note>
		    <para>
			Data Values are shown by default in polar charts even if drawing of the 
			markers is suppressed by <methodname>setPolarMarker( false )</methodname>, 
			you can  hide them by calling the 
			<classname>KDChartPolarAttributes</classname> function 
			<methodname>setPrintDataValues( false )</methodname>.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="polarsattributes">Polars Attributes</title>
		<para>
		    Text ...
		</para>
	    </sect2>	    
	    <sect2>
		<title id="polarstips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>
	    </sect2>
	    <sect2>
		<title id="polartipssample" xreflabel="codexample">A complete Polar Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
-->
		    <!--
		    <link linkend=""></link>
		    <link linkend=""></link>
		    -->
<!--
		</para>
-->
		<!--
		<programlisting linenumbering="numbered" id="">
		<textobject>
		<textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
		-->
<!--
		<para>
		    More explanation?
		</para>   	
	    </sect2>
-->
	</sect1>
	<sect1>
            <title>What's next</title>
            <para>
                For our diagram to be useful we need to be able to display its axis. That 
		will be the subject of our next section.
            </para>
        </sect1>
    </chapter>
     <chapter id="chapter_axes">
        <title id="chtxt_axes">Axes</title>
        <titleabbrev id="chnum_axes">Chapter 5</titleabbrev>
	<para>
	    Axes are implemented at different levels in the KD Chart 2.0 API. KD Chart make 
	    use of Cartesian axis - see <classname>KDChartCartesianAxis</classname> and Polar 
	    Axis which are derived from the base class for axes 
	    <classname>KDChartAbstractAxis</classname>.
	    <!-- Pending Michel Polar axis are not implemented yet -->.
        </para>
	<para>
	    The user may specify its own set of strings to be used as Axis labels with the
	    <methodname>KDChartAbstractAxis::setLabels( const QStringList )</methodname>
	    method.
	</para>
	<note>
	    <para>
		Labels specified via setLabels take precedence: If a non-empty list is passed, 
		KD Chart will use these strings as axis labels, instead of calculating them.
		By passing an empty QStringList you can reset the default behaviour.
	    </para>
	</note>
	<para>
	    For the convenience we can also specify short labels in our own set of string to
	    be used as axis labels,in case the normal labels are too long by using  
	    <methodname>KDChartAbstractAxis::setShortLabels( const QStringList )</methodname>
	</para>
	<para>
	    Axis values and labels text attributes can also be configured. Thus the labels of 
	    all of your axes in all of your diagrams  within that Chart will be drawn in same 
	    font size, by default.
	</para>
	<para>
	    The setters and getters for axis labels and their text attributes are implemented 
	    in the axis base class <classname>KDChartAbstractAxis</classname>, we recommend you 
	    to study its interface - See <filename>KDChartAbstractAxis.h</filename>.
	</para>
	<tip>
	    <para>
		If you a smaller number of strings than the number od labels drawn at this
		axis, KD Chart will iterate over the list, repeating the strings, until all
		labels are drawn. 
	    </para>
	    <para>
		As an example you could specify the seven days of the week as abscissa labels,
		which would be repeatedly used then.
	    </para>
	</tip>
	<sect1>
	   <title id="cartesianaxes">Cartesian Axis</title>
            <para>
                The class <classname>KDChartCartesianAxis</classname> is used together with 
		the diagrams displayed in a cartesian coordinate plane and contains the setters
		and getters related to the axis specifics to those chart types.
            </para> 
	    <para>
		It allows the user to set and retrieve the position (top, bottom, left or right), 
		or the type (abscissa, ordinate) of the axis, assign or retrieve a title and its 
		text attributes. That is where the axis are painted.
	    </para>
	    <para>
		The setters and getters for those specifics cartesian features are implemented 
		in <classname>KDChartCartesianAxis</classname>, we recommend you 
		to study its interface - See <filename>KDChartCaretesianAxis.h</filename>.
	    </para>
	</sect1>
	<sect1>
            <title id="caxeshowtoconfigure">How to configure</title>
            <para>
                In order to add axis to a cartesian diagram we need to use 
		<methodname>KDChartAbstractCartesianDiagram::AddAxis()</methodname> method.
		The diagram takes ownership of the axis and will delete it by itself.
            </para>
	    <para>
		To gain back ownership (e.g. for assigning the axis to another diagram)
		use the <methodname>KDChartAbstractDiagram::takeAxis()</methodname> method, 
		before calling addAxis on the other diagram.
	    </para>
	    <note>
		<para>
		    <methodname>KDChartAbstractDiagram::takeAxis()</methodname>Removes the 
		    axis from the diagram, without deleting it. The diagram no longer owns 
		    the axis, so it is the caller's responsibility to delete the axis.
		</para>
	    </note>
            <sect2>
                <title id="caxessample" xreflabel="codsample">Cartesian Axes sample</title>
                <para>
                    Let us make the above description more concrete by looking at the following
                    lines of code based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example 
		    we demonstrate how to add an X axis and a Y axis to your diagram and set the 
		    Axis titles when working with a <classname>KDChartWidget</classname>..
		</para>
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartLineDiagram&gt;
#include &lt;KDChartCartesianAxis&gt;

using namespace KDChart;
		</programlisting>                
		<para>
		    We need to include <classname>KDChartLineDiagram</classname> in order to be 
		    able to add the Axis as we will see further on. 
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );
    Widget widget;
    // our Widget can be configured
    // as any Qt Widget
    widget.resize( 600, 600 );
    // store the data and assign it
    QVector&lt; double &gt; vec0,  vec1;
    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
    widget.setDataset( 0, vec0, "vec0" );
    widget.setDataset( 1, vec1, "vec1" );
    widget.setDataset( 2, vec2, "vec2" );
		</programlisting>
		<note>
		    <para>
			We don't need to change the default chart type (Line Charts) by calling  
			the <methodname>KDChartWidget::setType</methodname> method.     
		    </para>
		</note>
		    <para>
		    Now let us create our axis, position them and set their titles:
		</para>
		<programlisting>
    CartesianAxis *xAxis = new CartesianAxis( widget.lineDiagram() );
    CartesianAxis *yAxis = new CartesianAxis (widget.lineDiagram() );
    xAxis->setPosition ( CartesianAxis::Bottom );
    yAxis->setPosition ( CartesianAxis::Left );
    xAxis->setTitleText ( "Abscissa bottom position" );
    yAxis->setTitleText ( "Ordinate left position" );
		</programlisting>		
		<para>
		    And add them to our diagram which will take the ownership:
		</para>			
		<programlisting>
    widget.lineDiagram()->addAxis( xAxis );
    widget.lineDiagram()->addAxis( yAxis );
		</programlisting>
		<para>
		    Finally we conclude our small example:
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-sampleaxiswidget">
                <title>A Simple Widget With Axis</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simpleaxiswidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Axis/Widget</filename>, we recommend you to do so.
		</para>			             
                <para>
                    In the Tips section below we will present you a more elaborate example which uses 
		    <classname>KDChartChart</classname> and where we are configuring our axis title
		    text attributes. We also use our own labels and their shortened version. 	    
                </para>
            </sect2>
        </sect1>
<!--
	<sect1>
	   <title id="partesianaxes">Polar Axis</title>
            <para>
                
            </para> 
	</sect1>
	<sect1>
            <title id="paxeshowtoconfigure">How to configure</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="paxessample" xreflabel="codsample">Polar Axes sample</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.	
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
-->
	<sect1>
            <title id="axistips">Tips</title>
	    <para>
		In this section we want to give you some example about how to use some 
		interesting features offered by the KD Chart 2.0 API. We will study the 
		code and display a screen-shot showing the resulting widget. 
	    </para>	
            <sect2>
                <title id="axistipsample" xreflabel="codexample">Axis Example</title>           
		<para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			   Add axes at different positions.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Set the axis title and configure their text attributes. 
			</para>
		    </listitem>		    
		    <listitem>
			<para>			    
			   Use our own labels and their shortened versions.
			</para>
		    </listitem>
		     <listitem>
			<para>			    
			   Configure our labels text attributes.
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our diagram _with_ axis implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Axis/Chart</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="axislabels_mainwindow_h">
<textobject><textdata fileref="../../examples/Axis/Chart/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual. As you can see we are 
		    using a KDChartChart object (m_chart), a KDChartLineDiagram object (m_lines), and 
		    our home made TableModel (m_model). 
		</para>	
		<programlisting linenumbering="numbered" id="axeslabels_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Axis/Chart/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our diagram.		   
		</para>
		<programlisting>
...
QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
m_chart = new Chart();
chartLayout->addWidget( m_chart );
hSBar->setVisible( false );
vSBar->setVisible( false );

m_model.loadFromCSV( ":/data" );

// Set up the diagram
m_lines = new LineDiagram();
m_lines->setModel( &amp;m_model );
...
		</programlisting>
		<para>
		    We want to display three axis, respectively positionned at
		    the top, left and bottom side of our diagram. This is straight
		    forward:
		</para>
		<programlisting>
....
CartesianAxis *topAxis = new CartesianAxis( m_lines );
CartesianAxis *leftAxis = new CartesianAxis ( m_lines );
CartesianAxis *bottomAxis = new CartesianAxis ( m_lines );
topAxis->setPosition ( CartesianAxis::Top );
leftAxis->setPosition ( CartesianAxis::Left );
bottomAxis->setPosition ( CartesianAxis::Bottom );
....
		</programlisting>
    		<para>
		    In the code above we are declaring our axis and make use of 
		    <methodname>KDChartCartesianAxis::setPosition()</methodname> to
		    give their location.
		</para>
		<para>
		    Let us now define the title text for each of those axis:
		</para>
		<programlisting>
...
topAxis->setTitleText ( "Abscissa color configured top position" );
leftAxis->setTitleText ( "Ordinate font configured" );
bottomAxis->setTitleText ( "Abscissa Bottom" );
...
		</programlisting>				
		<para>
		    <methodname>setTitleText()</methodname> and 
		    <methodname>setTitleTextAttributes()</methodname> are implemented in 
		    <classname>KDChartCartesianAxis</classname>, we recommend you to 
		    consult its interface ( see <filename>KDChartCartesianAxis.h</filename>
		</para>
		<para>
		    In this example and to demonstrate the text configuration for the title 
		    and the labels we want to have a different configuration for each of 
		    our tilte axis and also for our labels. The process is the same as for 
		    configuring any type of attributes, as follow:
		</para>
		<para>
		    Create an attribute object, configure it and assign it.
		</para>
		<programlisting>
...
// configure titles text attributes
TextAttributes taTop ( topAxis->titleTextAttributes () );
// color configuration
taTop.setPen( QPen( Qt::red ) );
// assign to the axis
topAxis->setTitleTextAttributes ( taTop );

TextAttributes taLeft ( leftAxis->titleTextAttributes () );
// Font configuration
Measure me( taLeft.fontSize() );
me.setValue( me.value() * 1.5 );
taLeft.setFontSize( me );
leftAxis->setTitleTextAttributes ( taLeft );

TextAttributes taBottom ( bottomAxis->titleTextAttributes () );
taBottom.setPen(  QPen( Qt::blue ) );
bottomAxis->setTitleTextAttributes ( taBottom );

// configure labels text attributes
TextAttributes taLabels;
taLabels.setPen(  QPen( Qt::darkGreen ) );
topAxis->setTextAttributes( taLabels );
leftAxis->setTextAttributes( taLabels );
bottomAxis->setTextAttributes( taLabels );
...
		</programlisting>
		<para>
		    We want our top and bottom axis to display different types of labels
		    as well as to make sure those labels will be shortened in case the 
		    normal labels are too long ( see setShortLabels() ).
		</para>
		<programlisting>
// configure labels and their shortened versions
QStringList daysOfWeek;
daysOfWeek &lt;&lt; "Monday" &lt;&lt; "Tuesday" &lt;&lt; "Wednesday"
&lt;&lt; "Thursday" &lt;&lt; "Friday" ;
topAxis->setLabels( daysOfWeek );

QStringList shortDays;
shortDays &lt;&lt; "Mon" &lt;&lt; "Tue" &lt;&lt; "Wed"
&lt;&lt; "Thu" &lt;&lt; "Fri";
topAxis->setShortLabels( shortDays );

QStringList bottomLabels;
bottomLabels &lt;&lt; "Day 1" &lt;&lt; "Day 2" &lt;&lt; "Day 3"
&lt;&lt; "Day 4" &lt;&lt; "Day 5";
bottomAxis->setLabels( bottomLabels );

QStringList shortBottomLabels;
shortBottomLabels &lt;&lt; "D1" &lt;&lt; "D2" &lt;&lt; "D3"
&lt;&lt; "D4" &lt;&lt; "D5";
bottomAxis->setShortLabels( shortBottomLabels );
		</programlisting>
		<note>
		    <para>
			Labels specified via setLabels take precedence: if a non-empty 
			list is passed, KD Chart will use these strings as axis labels,
			instead of calculating them.
		    </para>
		</note>
		<para>
		    Finally the last step i to assign our axis to the diagram and the 
		    diagram to our chart view.
		</para>
		<programlisting>
// add axis
m_lines->addAxis( topAxis );
m_lines->addAxis( leftAxis );
m_lines->addAxis( bottomAxis );

// assign diagram to chart view
m_chart->coordinatePlane()->replaceDiagram( m_lines );
		</programlisting>		
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Axis/Chart</filename> directory in your KD Chart
		    installation. We recommend you to run it. The widget displayed by the 
		    above code is shown in the figure below.
		</para>
		<figure float="0" id="fig-axisconfiguredtitles">
		    <title>Axis with configured Labels and Titles</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/axisconfiguredtitles.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Several ready to run examples related to axis are available at the following 
		    location <filename>examples/Axis</filename>, we recommend you to run them all
		    and consult their implementation.
		</para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Legends are also an important element. In the next section we will describe how to 
		add and configure your chart legend.
            </para>
        </sect1>
    </chapter>
        <chapter id="chapter_legends">
        <title id="chtxt_legends">Legends</title>
        <titleabbrev id="chnum_legends">Chapter 6</titleabbrev>
	<para>
	    Legends can be drawn for all kind of diagrams and are drawn at the chart 
	    level (in relation to diagram level). We can have more than one legend per 
	    chart and add it to our chart or our widget view by using respectively 
	    <methodname>KDChartChart::addLegend()</methodname> or  
	    <methodname>KDChartWidget::addLegend()</methodname>
	</para>
	<note>
	    <para>
		Legend is different from all other classes ofd KD Chart, since it 
		can be displayed outside of the Chart's area. If we want to, we 
		can embedd the legend into your own widget, or into another part 
		of a bigger grid, into which we might have inserted the Chart.
	    </para>
	    <para>
		On the other hand, please note that we need to (MUST) call 
		<methodname>KDChartChart::addLegend()</methodname> to get our legend 
		positioned at the correct position in our chart in case we want to 
		display the legend inside of the chart which is probably true for most 
		cases.
	    </para>
	</note>
	<para>
	    Let us go through the main configuration features offered by
	    <classname>KDChartLegend</classname>. Of course we also recommend you to 
	    consult its interface see <filename>KDChartLegend.h</filename> as well as
	    the interfaces for <classname>KDChartChart</classname> and 
	    <classname>KDChartWidget</classname> to have a complete idea over how to
	    handle legends and what are the configurations parameters available.
	</para>
	<sect1>
            <title id="legendshowtoconfigure">How to configure</title>
             <para>
                In order to add a legend to our chart we need to use the  
		<methodname>KDChartChart::AddLegend()</methodname> method.
		The chart takes ownership of the legend and will take care of
		removing it by itself. The <classname>KDChartChart</classname> method 
		above and the ones discussed in the paragraphs are similar for the
		<classname>KDChartWidget</classname> class. In order to make the 
		following description simpler we will only mention 
		<classname>KDChartChart</classname> in the following paragraphs.
            </para>
	    <tip>		
		<para>
		    You may also wish to use <classname>KDChartChart</classname>
		    <methodname>replaceLegend( Legend newLegend , Legend oldLegend)</methodname> 
		    which is also available for the convenience:
		</para>
		<para>
		    The old legend will be deleted automatically. If its parameter is 
		    omitted, the very first legend will be replaced. In case, there was 
		    no legend yet, the new legend will just be added.
		</para>
	    </tip>
	     <para>
		If you want to re-use the old legend, call takeLegend and addLegend, instead of 
		using replaceLegend.
	    </para>
	    <note>
		<para>
		    <methodname>KDChartChart::takeLegend()</methodname>Removes the 
		    legend from the chart without deleting it. The chart no longer owns 
		    the legend, it is the caller's responsibility to delete the legend.
		</para>
	    </note>	   
	    <para>
		The main configurations elements for <classname>KDChartLegend</classname> are:
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			ReferenceArea: Specifies or retrieve the reference area for font size 
			of title text and for font size of the item texts.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Diagrams: Add, retrieve, replace or remove diagrams associated to 
			the legends.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Position, Alignment and Orientation are of course configurable.
		    </para>
		</listitem>
		<listitem>
		    <para>			    
			Show Lines: Paint lines between the different items of a legend.
		    </para>
		</listitem>
		<listitem>
		    <para>			    
			Title, Markers and Text attributes can be set, as well as colors and 
			spacing.
		    </para>
		</listitem>
	    </itemizedlist>
	    <note>
		<para>
		    The <classname>KDChartPosition</classname> class, defines positions, 
		    using compass terminologie. Using this class you can specify one of 
		    nine pre-defined, logical points , in a similar way, as you would use 
		    a compass to navigate on a map. We recommend you to consult its interface 
		    to learn more about it (<filename>KDChartPosition.h</filename>).
		</para>
	    </note>
	    <para>
		Please consult the setters and getters methods available in the 
		<classname>KDChartLegend</classname> interface. See 
		<filename>KDChartLegend.h</filename>.
	    </para>
            <sect2>
                <title id="legendsconfiguresample" xreflabel="codexample">Legend Sample</title>
                <para>
                    We will now describe those features a more concrete way by looking at the following
                    sample code based on the <filename>Simple Widget</filename> example we have been 
		    demonstrating above <filename>Chapter 3 - Two Ways - Widget Example</filename>.
		    Through the following code we demonstrate how to add and position a Legend to your
		    chart Widget using a KDChartWidget.		    
                </para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    		 	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;KDChartPosition&gt;

using namespace KDChart;
		</programlisting>     	    
		<para>
		    In this sample code we want to display a bar chart and need to include our
		    <classname>KDChartBarDiagram</classname> class. In order to be able to 
		    give a location (position) to our legend in the widget view we also include  
		    <classname>KDChartPosition</classname>.
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    Widget widget;
    widget.resize( 600, 600 );

    QVector&lt; double &gt; vec0,  vec1,  vec2;

    vec0 &lt;&lt; -5 &lt;&lt; -4 &lt;&lt; -3 &lt;&lt; -2 &lt;&lt; -1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5;
    vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 4 &lt;&lt; 9 &lt;&lt; 16 &lt;&lt; 25;
    vec2 &lt;&lt; -125 &lt;&lt; -64 &lt;&lt; -27 &lt;&lt; -8 &lt;&lt; -1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 8 &lt;&lt; 27 &lt;&lt; 64 &lt;&lt; 125;

    widget.setDataset( 0, vec0, "v0" );
    widget.setDataset( 1, vec1, "v1" );
    widget.setDataset( 2, vec2, "v2" );
    widget.setType( Widget::Bar );
		</programlisting>  	
		<note>
		    <para>
			We need to change the default chart type (Line Charts) by calling  
			the <methodname>KDChartWidget::setType</methodname> method in order 
			to display a bar type diagram.     
		    </para>
		</note>
		<para>
		    Now let us add our legend, set its position and orientation, its title 
		    and dataset labels text:
		</para>    	    
		<programlisting>
    widget.addLegend(Position::North);
    widget.firstLegend()->setOrientation( Qt::Horizontal );
    widget.firstLegend()->setTitleText( "Bars Legend" );
    widget.firstLegend()->setText( 0,  "Vector 1" );
    widget.firstLegend()->setText( 1,  "Vector 2" );
    widget.firstLegend()->setText( 2,  "Vector 3" );
    widget.firstLegend()->setShowLines(  true );
		</programlisting>    
		<para>
		    The interesting point here is how we call 
		    <methodname>KDChartWidget::firstlegend()</methodname> to get a pointer to 
		    to our legend object and be able to set up and configure it. We will see 
		    further on in the next code example (see - Section Tips - how to configure 
		    the elements of a legend (e.g Title text, markers, etc....).
		</para>
		<para>
		    Finally we conclude our small application by runnig the usual lines of 
		    code.
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting> 
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-samplelegendwidget">
                <title>A Widget With a simply configured Legend</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/legendsimple.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your 
		    KD Chart installation <filename>examples/Legends/LegendSimple</filename>, 
		    we recommend you to do so.
		</para>			             
                <para>
                    In the Tips section below we will present you a more elaborate example 
		    which uses  <classname>KDChartChart</classname> and where we are setting
		    up our legend elements ( title, texts, markers, etc...). 
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="legendstips">Tips</title>
	     <para>
		In this section we want to give you some example about how to use some 
		interesting features offered by the KD Chart 2.0 API. We will study the 
		code and display a screen-shot showing the resulting widget. 
	    </para>
	    <para>
		Before we go through this example, let us study a very simple chart 
		implementation with its legend by looking at the following line of codes 
		which we will comment. 
	    </para>
	    <para>
	        First and as we always do, we set up a model, declare our diagram, and 
		assign the model to it and the diagram to our chart after having 
		included the relevant header files.
	    </para>
	    <programlisting>
#include &lt;QtGui&gt;
#include &lt;KDChartChart&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;KDChartLegend&gt;
#include &lt;KDChartPosition&gt;
#include &lt;KDChartBackgroundAttributes&gt;
#include &lt;KDChartFrameAttributes&gt;

using namespace KDChart;

class ChartWidget : public QWidget {
Q_OBJECT
public:
    explicit ChartWidget(QWidget* parent=0) : QWidget(parent)
    {
        m_model.insertRows( 0, 2, QModelIndex() );
        m_model.insertColumns(  0,  3,  QModelIndex() );
        for (int row = 0; row &lt; 3; ++row) {
            for (int column = 0; column &lt; 3; ++column) {
                QModelIndex index = m_model.index(row, column, QModelIndex());
                m_model.setData(index, QVariant(row+1 * column) );
            }
        }

        BarDiagram* diagram = new BarDiagram;
        diagram-&gt;setModel(&amp;m_model);

        m_chart.coordinatePlane()-&gt;replaceDiagram(diagram);
	    </programlisting>
	    <para>
		We will set the legend position as well as its  Background and Frame
		attributes and includes those header files on this purpose. That will 
		allow us to make use of the methods available in those classes.
	    </para>
	    <para>
		We will now add a legend and set it up (positions, orientations, etc...):
	    </para>
	    <programlisting>
        // Add a legend and set it up
        Legend* legend = new Legend( diagram, &amp;m_chart );
        legend->setPosition( Position::NorthEast );
        legend->setAlignment( Qt::AlignCenter );
        legend->setShowLines( false );
        legend->setTitleText( tr( "Bars" ) );
        legend->setOrientation( Qt::Vertical );
        m_chart.addLegend( legend );
	    </programlisting>
	    <para>
		The code above handle the attributes specific to a legend, the setters
		and getters for the methods we have been used here are implemented 
		in the <classname>KDChartLegend</classname> class. We recommend you
		to consult its interface. See <filename>KDChartLegend.h</filename>.	
	    </para>	    
	    <para>
	        Set the Legend marker attributes. We want each dataset's marker to have 
		its own marker style.
	    </para>
	     <programlisting>
        // Configure the items markers
        MarkerAttributes lma;
        lma.setMarkerStyle( MarkerAttributes::MarkerDiamond );
        legend->setMarkerAttributes( 0,  lma );
        lma.setMarkerStyle( MarkerAttributes::MarkerCircle );
        legend->setMarkerAttributes( 1,  lma );
	    </programlisting>
	    <para>
		Markers are assigned per dataset as you can see above. You can learn 
		more about the marker styles and the methods available to configure
		markers in the <classname>MarkerAttributes</classname> class interface.
		See <filename>KDChartMarkerAttributes.h</filename>.		
	    </para>
	    <para>
	        Let us now configure our legend's items text:
	    </para>
	    <programlisting>
        // Configure labels for Legend's items
        legend->setText( 0,  "Series 1" );
        legend->setText( 1,  "Series 2" );
        legend->setText( 2,  "Series 3" );
	    </programlisting>
	    <para>
		Each dataset can be assigned its own text. We want to change their 
		pen color for demonstrating this feature and also to make our legend 
		nicer. We proceed as follow and configure their text attributes.
	    </para>
	    <programlisting>
        TextAttributes lta;
        lta.setPen( QPen( Qt::darkGray ) );
        legend->setTextAttributes(  lta );
	    </programlisting>
	    <para>
		Text attributes configuration and assignment is done as for all other 
		types of attribute. Create a text attribute object, configure it and 
		assign it. In this case we assign it to our legend by using its method 
		<methodname>KDChartLegend::setTextAttributes()</methodname>.
	    </para>
	    <tip>
		<para>
		    If we wish to paint a surrounding line round our legend markers we 
		    just need to configure a pen and assign it to our legend by calling
		    <methodname>KDChartLegend::setPen()</methodname>. See the following 
		    code sample that demonstrate that.		    
		</para>
	    </tip>
	     <programlisting>
        // Configure a pen to surround
        // the markers with a border
        QPen markerPen;
        markerPen.setColor(  Qt::darkGray );
        markerPen.setWidth( 2 );
        // Pending Michel use datasetCount() here as soon
        // as it is fixed
        for (  uint i = 0; i &lt; legend->datasetCount(); i++ )
            legend->setPen( i,  markerPen );
	    </programlisting>
	    <note>
		<para>
		    Mind the call to <methodname>KDChartLegend::datasetCount()</methodname>
		    which allow you to retrieve the number of dataset and simply loop 
		    through it.
		</para>
	    </note>
	    <para>
		We want to make our legend more readable by setting a white background 
		inside its frame.
	    </para>
	    <programlisting>
        // Add a background to your legend
        BackgroundAttributes ba;
        ba.setBrush(  Qt::white );
        ba.setVisible( true );
        legend->setBackgroundAttributes(  ba );
	    </programlisting>
	    <para>
		As for all attributes settings the code is straight forward, just create 
		the attribute object, configure it and assign it. We recommend you to have 
		a look at the <classname>KDChartBackgroundAttributes</classname> interface.
		See <filename>KDChartBackgroundAttributes.h</filename>
	    </para>
	    <para>
		Let us now configure our legend's frame:
	    </para>
	     <programlisting>
        FrameAttributes fa;
        fa.setPen( markerPen );
        fa.setPadding( 5 );
        fa.setVisible( true );
        legend->setFrameAttributes(  fa );
	    </programlisting>
	    <para>
		Same procedure as above. Please note the <methodname>setVisible()</methodname>
		method which is necessary as the default value hide those attributes.
	    </para>
	    <para>
		Finally we need to conclude our small application.
	    </para>
	    <programlisting>
        QVBoxLayout* l = new QVBoxLayout(this);
        l->addWidget(&amp;m_chart);
        setLayout(l);
    }

private:
    Chart m_chart;
    QStandardItemModel m_model;
};

int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    ChartWidget w;
    w.show();

    return app.exec();
}

#include "main.moc"
	    </programlisting>
	    <para>
		See the screen-shot below to view The resulting chart displayed by the 
		above code. 
	    </para>
	    <figure float="0" id="fig-samplelegendchart">
                <title>A Chart with configured Legend</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
			    fileref="images/legendparameters.png"
			    width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
	    <para>
	   	We recommend you to compile and run the above example, it is available 
		at the following location: <filename>examples/Legends/LegendParameters
		</filename>.
	    </para>
            <sect2>
		<title id="legendtipsample" xreflabel="codexample">Legend Example</title>
		<para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			   Add, edit or remove Legends in/from our chart view.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Configure its position, and a few attributes.  
			</para>
		    </listitem>		    
		    <listitem>
			<para>			    
			   Set its Title
			</para>
		    </listitem>
		     <listitem>
			<para>			    
			   All of the above operations should be available to the user from
			   the GUI and performed dinamically. 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our diagram _with_ axis implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Legends/LegendAdvanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="legendadvanced_mainwindow_h">
<textobject><textdata fileref="../../examples/Legends/LegendAdvanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual. As you can see we are 
		    using a KDChartChart object (m_chart), a KDChartLineDiagram object (m_lines), and 
		    our home made TableModel (m_model). 
		</para>	
		<programlisting linenumbering="numbered" id="legendadvanced_mainwindow_cpp">
<textobject><textdata fileref="../../examples/Legends/LegendAdvanced/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>		    
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>     	  
		<figure float="0" id="fig-legendsconfigured">
		    <title>Legend advanced example</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/legendsconfigured.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This ready to run example is available at the following location 
		    <filename>examples/Legends/LegendAdvanced</filename> of your KD Chart 
		    installation, we recommend you to study its code, compile and run it.
		</para>
            </sect2>	    
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
		You can also add headers and/or footers to your chart to make it more 
		understandable. In the next section we will go through the several 
		features and configuration possibilities available in  KD Chart 2.0 
		about "Headers and Footers". 
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_headersfooters">
        <title id="chtxt_headersfooters">Header and Footers</title>
        <titleabbrev id="chnum_headersfooters">Chapter 7</titleabbrev>
	<para>
	    Headers and Footers can be added and configured in several ways. That will 
	    be the subject of this section where we will go through the main features 
	    and methods available. Of course we recommend you to consult the  
	    <classname>KDChartHeaderFooter</classname> class interface to learn more 
	    about those features and methods. See <filename>KDChartHeaderFooter.h</filename>
        </para>
	<sect1>
            <title id="headersfootershowtoconfigure">How to configure</title>
                <para>
                In order to add a Header or a Footer to our chart we need to use the  
		<methodname>KDChartChart::AddHeaderFooter( HeaderFooter* hf )</methodname>
		method. The chart takes ownership and will take care of removing it by itself. 
		The <classname>KDChartChart</classname> method above and the ones discussed 
		in the next paragraphs of this section are similar for the
		<classname>KDChartWidget</classname> class. In order to make this  
		description simpler we will only mention 
		<classname>KDChartChart</classname> there.
            </para>
	    <tip>		
		<para>
		    You may also wish to use <classname>KDChartChart</classname>
		    <methodname>replaceHeaderFooter( HeaderFooter newHf, HeaderFooter oldHf)</methodname> 
		    which is also available for the convenience:
		</para>
		<para>
		    The new header or footer to be used instead of the old one must not be 
		    zero, or the method will do nothing. The second parameter of this method
		    is header or footer to be removed by the new one. This header or footer 
		    will be deleted automatically. If the parameter is omitted, the very first 
		    header or footer will be replaced. In case, there was no header and no footer 
		    yet, the new header or footer will just be added.
		</para>
	    </tip>
	     <para>
		If you want to re-use the old header or footer, call takeHeaderFooter and 
		addHeaderFooter, instead of using replaceHeaderFooter.
	    </para>
	    <note>
		<para>
		    <methodname>KDChartChart::takeHeaderFooter()</methodname>Removes the 
		    header or footer from the chart without deleting it. The chart no longer 
		    owns the header or footer, it is the caller's responsibility to delete it.
		</para>
	    </note>	   
	    <para>
		The main configurations elements for <classname>KDChartHeaderFooter</classname>
		are:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Type: Can be Header or Footer. 
		    </para>
		</listitem>
		<listitem>
		    <para>
			Position: Allow the user to define or retrieve the Header or footer
			position.
		    </para>
		</listitem>	
		<listitem>
		    <para>			    
			Text and Text attributes can of course also be configured as we will see
			in the following examples.
		    </para>
		</listitem>
	    </itemizedlist>
	    <note>
		<para>
		    The <classname>KDChartPosition</classname> class, defines positions, 
		    using compass terminologie. Using this class you can specify one of 
		    nine pre-defined, logical points , in a similar way, as you would use 
		    a compass to navigate on a map. We recommend you to consult its interface 
		    to learn more about it (<filename>KDChartPosition.h</filename>).
		</para>
	    </note>
            <sect2>
                <title id="headersfootersconfiguresample" xreflabel="codexample">Headers and Footers code Sample</title>
		<para>
                    We will now describe those features a more concrete way by looking at the following
                    sample code based on the <filename>Simple Widget</filename> example we have been 
		    demonstrating above <filename>Chapter 3 - Two Ways - Widget Example</filename>.
		    Through the following code we demonstrate how to add and position a header and a 
		    footer to a chart Widget using a KDChartWidget.		    
                </para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    		 	
		<programlisting>
#include &lt;QApplication&gt;
#include &lt;KDChartWidget&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;KDChartPosition&gt;

using namespace KDChart;
		</programlisting>     	    
		<para>
		    In this sample code we want to display a bar chart and need to include our
		    <classname>KDChartBarDiagram</classname> class. In order to be able to 
		    give a location (position) to our header and our footer in the widget view we also 
		    include <classname>KDChartPosition</classname>.
		</para>
		<programlisting>
int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    Widget widget;
    widget.resize( 600, 600 );

    QVector&lt; double &gt; vec0,  vec1,  vec2;

    vec0 &lt;&lt; -5 &lt;&lt; -4 &lt;&lt; -3 &lt;&lt; -2 &lt;&lt; -1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5;
    vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 4 &lt;&lt; 9 &lt;&lt; 16 &lt;&lt; 25;
    vec2 &lt;&lt; -125 &lt;&lt; -64 &lt;&lt; -27 &lt;&lt; -8 &lt;&lt; -1 &lt;&lt; 0
         &lt;&lt; 1 &lt;&lt; 8 &lt;&lt; 27 &lt;&lt; 64 &lt;&lt; 125;

    widget.setDataset( 0, vec0, "v0" );
    widget.setDataset( 1, vec1, "v1" );
    widget.setDataset( 2, vec2, "v2" );
    widget.setType( Widget::Bar );
		</programlisting>  	
		<note>
		    <para>
			We need to change the default chart type (Line Charts) by calling  
			the <methodname>KDChartWidget::setType</methodname> method in order 
			to display a bar type diagram.     
		    </para>
		</note>
		<para>
		    Now let us add our header and footer, set its position and its text.
		</para>    	    
		<programlisting>
    widget.addHeaderFooter( "A default Header - North",
                            HeaderFooter::Header, Position::North );
    widget.addHeaderFooter( "A default Footer - South",
                            HeaderFooter::Footer, Position::South );
		</programlisting>    
		<para>
		    As you can see the code above is straight forward and we just need to call 
		    <methodname>KDChartWidget::addHeaderFooter()</methodname> passing the text, type
		    and position we want to assign to it. 
		</para>
		<para>
		    Finally we conclude our small application:
		</para>
		<programlisting>
    widget.show();

    return app.exec();
}
		</programlisting> 
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-sampleheaderfooterwidget">
                <title>A Widget With a Header and a Footer</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/headerfootersimple.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your 
		    KD Chart installation <filename>examples/HeadersFooters/HeadersFootersSimple</filename>, 
		    we recommend you to do so.
		</para>			             
                <para>
                    In the Tips section below we will present you a more elaborate example 
		    which uses  <classname>KDChartChart</classname> and where we are setting
		    up our headers and footers ( texts, background, frame etc...). 
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="headersandfooterstips">Tips</title>
	     <para>
		In this section we want to give you some example about how to use some 
		interesting features offered by the KD Chart 2.0 API. We will study the 
		code and display a screen-shot showing the resulting widget. 
	    </para>
	    <para>
		Before we go through this example, let us study a very simple chart 
		implementation with a configured header by looking at the following 
		line of codes which we will comment. 
	    </para>
	    <para>
	        First and as we always do, we set up a model, declare our diagram, and 
		assign the model to it and the diagram to our chart after having 
		included the relevant header files.
	    </para>
	    <programlisting>
#include &lt;QtGui&gt;
#include &lt;KDChartChart&gt;
#include &lt;KDChartBarDiagram&gt;
#include &lt;KDChartHeaderFooter&gt;
#include &lt;KDChartPosition&gt;
#include &lt;KDChartBackgroundAttributes&gt;
#include &lt;KDChartFrameAttributes&gt;

using namespace KDChart;

class ChartWidget : public QWidget {
Q_OBJECT
public:
    explicit ChartWidget(QWidget* parent=0)
    : QWidget(parent)
    {
        m_model.insertRows( 0, 2, QModelIndex() );
        m_model.insertColumns(  0,  3,  QModelIndex() );
        for (int row = 0; row &lt; 3; ++row) {
            for (int column = 0; column &lt; 3; ++column) {
            QModelIndex index = m_model.index(row, column, QModelIndex());
            m_model.setData(index, QVariant(row+1 * column) );
            }
        }

        BarDiagram* diagram = new BarDiagram;
        diagram-&gt;setModel(&amp;m_model);

        m_chart.coordinatePlane()-&gt;replaceDiagram(diagram);
	    </programlisting>
	    <para>
		We will configure the header position as well as its  text, Background and 
		Frame attributes and includes the header files related to those attributes
		on this purpose. That will allow us to make use of the methods available 
		in these classes.
	    </para>
	    <para>
		We will now add our header and set it up:
	    </para>
	    <programlisting>
        // Add at one Header and set it up
        HeaderFooter* header = new HeaderFooter( &amp;m_chart );
        header->setPosition( Position::North );
        header->setText( "A Simple Bar Chart" );
        m_chart.addHeaderFooter( header );
	    </programlisting>
	    <para>
		The code above handle the attributes specific to a headers and footers
		the setters and getters for the methods we have been used here are 
		implemented in the <classname>KDCharthEADERfOOTER</classname> class.
		We recommend you to consult its interface. See 
		<filename>KDChartHeaderFooter.h</filename>.	
	    </para>	    
	    <para>
		Let us configure the header text attributes and make sure the font will 
		be resized together with the widget in case the user resize it. 
	    </para>
	     <programlisting>
        // Configure the Header text attributes
        TextAttributes hta;
        hta.setPen( QPen(  Qt::blue ) );

        // let the header resize itself
        // together with the widget.
        // so-called relative size
        Measure m( 35.0 );
        m.setRelativeMode( header->autoReferenceArea(),
                           KDChartEnums::MeasureOrientationMinimum );
        hta.setFontSize( m );
        // min font size
        m.setValue( 3.0 );
        m.setCalculationMode( KDChartEnums::MeasureCalculationModeAbsolute );
        hta.setMinimalFontSize( m  );

        // assign
        header->setTextAttributes( hta );
	    </programlisting>
	    <para>
		Our header text is now displayed using a blue pen, the font are 
		configured to take a relative size. 
	    </para>
	    <para>
	        We also want to configure a white background to make it nicer, and 
		proceed as follow:
	    </para>
	    <programlisting>
        // Configure the header Background attributes
        BackgroundAttributes hba;
        hba.setBrush(  Qt::white );
        hba.setVisible( true );
        header->setBackgroundAttributes(  hba );
	    </programlisting>
	    <para>
		As for all types of attributes we just need to create the attribute
		object, configure it and assign it to our header.
	    </para>
	    <para>
		The same process is applied to configure header'sour frame attributes:
	    </para>
	    <programlisting>
        // Configure the header Frame attributes
        FrameAttributes hfa;
        hfa.setPen( QPen ( QBrush( Qt::darkGray ), 2 ) );
        hfa.setVisible( true );
        header->setFrameAttributes(  hfa );
	    </programlisting>
	    <para>
		In the code above we assign a pen to the frame attributes in order to 
		get a Gray line around the frame.
	    </para>	    
	    <note>
		<para>
		    Same procedure as above. Please note the 
		    <methodname>setVisible()</methodname> method which is necessary as 
		    the default value hide the attributes above.
		</para>
	    </note>
	    <para>
		Finally we need to conclude our small application.
	    </para>
	    <programlisting>
        QVBoxLayout* l = new QVBoxLayout(this);
        l->addWidget(&amp;m_chart);
        setLayout(l);
    }

private:
    Chart m_chart;
    QStandardItemModel m_model;
};

int main( int argc, char** argv ) {
    QApplication app( argc, argv );

    ChartWidget w;
    w.show();

    return app.exec();
}

#include "main.moc"
	    </programlisting>
	    <para>
		See the screen-shot below to view The resulting chart displayed by the 
		above code. 
	    </para>
	    <figure float="0" id="fig-sampleheaderchart">
                <title>A Chart with a configured Header</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
			    fileref="images/headerparameters.png"
			    width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
	    <para>
	   	We recommend you to compile and run the above example, it is available 
		at the following location: 
		<filename>examples/HeadersFooters/HeadersFootersParameters
		</filename>.
	    </para>
            <sect2>
                <title id="headersfooterstipsample" xreflabel="codexample">Headers and Footers Example</title>
                <para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			   Add, edit or remove headers and footers in/from our chart view.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Configure their positions.  
			</para>
		    </listitem>		    
		    <listitem>
			<para>			    
			   Set their text
			</para>
		    </listitem>
		     <listitem>
			<para>			    
			   All of the above operations should be available to the user from
			   the GUI and performed dynamically. 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our diagram _with_ axis implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Legends/LegendAdvanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="headeradvanced_mainwindow_h">
<textobject><textdata fileref="../../examples/HeadersFooters/Advanced/mainwindow.h"/></textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual. As you can see we are 
		    using a KDChartChart object (m_chart), a KDChartLineDiagram object (m_lines), and 
		    our home made TableModel (m_model). 
		</para>
		<programlisting linenumbering="numbered" id="headeradvanced_mainwindow_cpp">
<textobject><textdata fileref="../../examples/HeadersFooters/Advanced/mainwindow.cpp"/></textobject>
		</programlisting>
		<para>		    
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para> 	  
		<figure float="0" id="fig-headersconfigured">
		    <title>Headers and Footers advanced example</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/headerconfigured.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This ready to run example is available at the following location 
		    <filename>examples/HeadersFooters/Advanced</filename> of your KD Chart 
		    installation, we recommend you to study its code, compile and run it.
		</para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                The next chapter will be dedicated to KDChart 2.0 Attributes model which is derived 
		indirectly from <classname>QAbstractProxyModel</classname> and gives the user 
		all flexibility to customizing her's chart and its component at different levels 
		( whole diagram, per index, per row or column etc....).
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_customizing">
        <title id="chtxt_customizing">Customizing your Chart</title>
        <titleabbrev id="chnum_customizing">Chapter 8</titleabbrev>
	<para>
	    Customizing your chart means configuring the attributes available for the different 
	    components of a chart (e.g diagrams, legends, headers and footers etc...). In 
	    <filename>Chapter 4 - Cartesian Coordinate Plane and Polar Coordinate Plane</filename>
	    we have been looking at the different attributes specific to a certain type of 
	    diagram ( Line, Bar, Pie, etc...). In this chapter we will go through the details when 
	    it comes to the attributes related to the elements of a chart and also the ones common 
	    to all types of charts.
        </para>
	<sect1>
            <title id="customizingattributes">Attributes Model, Abstract Diagram</title>
            <para>
                The <classname>KDChartAttributesModel</classname> class is derived from 
		<classname>QAbstractProxyModel</classname> and used internally by the base 
		class for all diagrams <classname>KDChartAbstractDiagram</classname> which 
		<methodname>setAttributesModel( AttributesModel* model )</methodname> method 
		associates an AttributesModel with a diagram.
            </para>
	    <note>
		<para>
		    The diagram does _not_ take ownership of the AttributesModel. This should thus 
		    only be used with AttributesModels that have been explicitely created by the 
		    user. Setting an AttributesModel that is internal to another diagram is an error.
		</para>
	    </note>
	    <para>
		Let us illustrate the above assertion, the right way is:
	    </para>
	    <programlisting>
// correct
AttributesModel *am = new AttributesModel( model, 0 );
diagram1->setAttributesModel( am );
diagram2->setAttributesModel( am );
	    </programlisting>
	    <para>
		It would be wrong to proceed as follow:
	    </para>
	    <programlisting>
// Wrong
diagram1->setAttributesModel( diagram2->attributesModel() );
	    </programlisting>
	    <para>
		To retrieve the attribute model associated to a particular diagram, we can make 
		use of the <classname>KDChartAbstractDiagram</classname> method
		<methodname>attributesModel()</methodname>.
	    </para>
	    <note>
		<para>
		    By default each diagram owns its own AttributesModel, which should never be 
		    deleted. Only if a user-supplied AttributesModel has been set does the pointer 
		    returned here not belong to the diagram.
		</para>
	    </note>
            <sect2>
                <title id="attributeassample" xreflabel="codesample">How it Works</title>
                <para>
                    Let us make this more concrete by looking at the following methods for settings  
		    a Pen and extracted from <classname>KDChartAbstractDiagram</classname>'s 
		    interface. 
                </para>
                <programlisting>		    
void setPen( const QModelIndex&amp; index, const QPen&amp; pen );
void setPen( int dataset, const QPen&amp; pen );
void setPen( const QPen&amp; pen );
	        </programlisting>
		<note>
		    <para>
			<classname>KDChartAbstractDiagram</classname> defines the interface, that 
			needs to be implemented for the diagram, to function within the KDChart 
			framework. It extends Interview's AbstractItemView. 
		    </para>
		</note>		
                <para>
		    Those methods allow us to set the Pen to be used respectively: at a given index,
		    for a given dataset, or for all datasets in the model.
                </para>
		<para>
		    By looking at their implementations we can see how we make use of the 
		    <classname>KDChartAttributesModel</classname> methods 
		    <methodname>setData(), setHeaderData(), and setModelData()</methodname>
		    to achieve this task.
		</para>
		<programlisting>		    
void AbstractDiagram::setPen( const QModelIndex&amp; index, const QPen&amp; pen )
{
    attributesModel()->setData(
    attributesModel()->mapFromSource( index ),
    qVariantFromValue( pen ), DatasetPenRole );
}

void AbstractDiagram::setPen( const QPen&amp; pen )
{
    attributesModel()->setModelData(
    qVariantFromValue( pen ), DatasetPenRole );
}

void AbstractDiagram::setPen( int column,const QPen&amp; pen )
{
    attributesModel()->setHeaderData(
    column, Qt::Vertical,
    qVariantFromValue( pen ),
    DatasetPenRole );
}
	        </programlisting>
		<para>
		    The above description to demonstrate how it works for almost all the 
		    attributes available for the configuranble elements of a chart, and the 
		    flexibility of this approch.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when setting the 
			attributes: 
			<itemizedlist>
			    <listitem>
				<para>
				    Global: Weak
				</para>
			    </listitem>
			    <listitem>
				<para>
				    Per column: Medium
				</para>
			    </listitem>
			    <listitem>
				<para>
				    Per cell: Strong
				</para>
			    </listitem>
			</itemizedlist>
			Which means that once you have set the attributes for a column or a cell, you will
			not be able to change those settings by calling the "global" method to reset it 
			to another value, but instead call the per column or per index setter. As 
			demonstrated in the above code.
		    </para>
		</note>
		<para>
		    In the next section we will have a quick look at the attributes common to all
		    chart types and elements of a chart and learn about the way to use them.
		</para>
            </sect2>
        </sect1>
	<sect1>
            <title id="customizingdatavalue">Data Values Attributes</title>
            <para>
		The Data Value Attributes group all properties that can be set
		in relation to data value labels and if and how they are displayed. This
                includes things like the text attributes (font, color), what markers are used, 
		and how many decimal digits are displayed, etc.
            </para>
	    <para>
		We recommend you to consult <classname>KDChartDataValueAttributes</classname>' interface 
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that will demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		Data values can be set with some defined text, background, frame and markers, the list 
		below gives us an overview about the most used features. We will only list the setters 
		here and explain them - Of course each of those setters has a corresponding getter:		
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setVisible( bool visible ): Set whether data value labels should be displayed.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setTextAttributes( const TextAttributes &amp;a ): Set the text attributes to use 
			for the data value labels.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setFrameAttributes( const FrameAttributes &amp;a ): Set the frame attributes to 
			use for the data value labels area.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setBackgroundAttributes( const BackgroundAttributes &amp;a ): Set the background 
			attributes to use for the data value labels area. 
		    </para>
		</listitem>
		<listitem>
		    <para>
			setMarkerAttributes( const MarkerAttributes &amp;a ): Set the marker attributes to 
			use for the data values. This includes the marker type.
		    </para>
		</listitem>
		<listitem>
		    <para>
			void setDecimalDigits( int digits ): Set how  many decimal digits to use when 
			rendering the data value labels.
		    </para>
		</listitem>
	    </itemizedlist>
	    <para>
		The process to configure the data value attributes for a diagram is very simple, and 
		similar to all other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the relevant attributes - e.g We want to configure the font and colors
			we need to configure the Text attributes and call them as follow:
			<methodname>TextAttributes ta( datavaluesattrinbutes.textAttributes() )</methodname>
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to your data values attributes. e.g call 
			<methodname>datavalueattributes.setTextAttributes( ta )</methodname>.
		    </para>
		</listitem>
		<listitem>
		    <para>
			set them as visdible implicitly and assign them to the diagram by calling the 
			diagram method 
			<methodname>diagram->setDataValueAttributes( datavaluesattributes)</methodname>
		    </para>
		</listitem>	
	    </itemizedlist>
            <sect2>
                <title id="datavaluesample" xreflabel="codesample">DataValue Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which describe 
		    the above process. This example is based on the <filename>main.cpp</filename> file of 
		    the <filename>examples/Lines/Parameters</filename> slightly modified. We recommend you 
		    to compile and run this example and to study its code.
                </para>
		<programlisting>
....
// Display values
// 1 - Call the relevant attributes
DataValueAttributes dva( diagram->dataValueAttributes() );

// 2 - We want to configure the font and colors
//     for the data values text.
TextAttributes ta( dva.textAttributes() );
//rotate if you wish
ta.setRotation( 45 );

// 3 - Set up your text attributes
ta.setFont( QFont( "Comic", 6 ) );
ta.setPen( QPen( QColor( Qt::darkGreen ) ) );
ta.setVisible( true );

// 4 - Assign the text attributes to your
//     DataValuesAttributes
dva.setTextAttributes( ta );
dva.setDecimalDigits( 4 );
dva.setVisible( true );

// 5 - Assign to the diagram
diagram->setDataValueAttributes( dva );
        ....
// 6 - Assign the diagram to the chart
m_chart.coordinatePlane()->replaceDiagram(diagram);

// make sure there is space to display the
// data value labels at the edges of the data area
m_chart.setGlobalLeading( 15, 15, 15, 15 );
...
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-sampledatavaluesattributes">
		    <title>A Chart with a configured Data Values Labels</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/datavaluesparameters.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    <filename>examples/Lines/Parameters</filename>.
		</para>
            </sect2>
        </sect1>	
	<sect1>
            <title id="customizingtext">Text Attributes</title>
            <para>
                <classname>TextAttributes</classname> encapsulates settings that have to do with text. This includes font,
		fontsize, color, whether the text is rotated, etc...
            </para>  
             <para>
		We recommend studying the <classname>KDChart::TextAttributes</classname> API documentation
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that will demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		Text attributes can be set with some defined font, pen, rotation etc... The text font 
		size can be fixed or relative (e.g it will adapt to the widget size), the list 
		below gives us an overview about the most used features. We will only list the setters 
		here and explain them - Of course each of those setters has a corresponding getter:		
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setVisible( bool visible ): Set whether text attributes should be displayed.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setFont( const QFont&amp; font ): Set the font to be used for rendering the text. 
		    </para>
		</listitem>
		<listitem>
		    <para>
			void setFontSize( const Measure &amp; measure ): Set the size of the font used 
			for rendering text
		    </para>
		</listitem>
		<listitem>
		    <para>
			setMinimalFontSize( const Measure &amp; measure ): Set the minimal size of the font 
			used for rendering text.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setRotation( int rotation ): Set the rotation angle to use for the text.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setPen( const QPen&amp; pen ): Set the pen to use for rendering the text.
		    </para>
		</listitem>
	    </itemizedlist>
	    <para>
		The process to configure the text attributes any elements of a chart is very simple, and 
		similar to all other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the text attributes - e.g We want to configure the font and colors
			we need to configure the Text attributes and call them as follow:
			<methodname>TextAttributes ta( header.textAttributes() )</methodname>
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to your header attributes. e.g call 
			<methodname>header.setTextAttributes( ta )</methodname>.
		    </para>
		</listitem>			
	    </itemizedlist>
            <sect2>
                <title id="textsample" xreflabel="codesample">Text Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which describe 
		    the above process. This example is based on the <filename>main.cpp</filename> file of 
		    the <filename>examples/HeadersFooters/HeadersFootersParameters</filename>. We recommend 
		    you to compile and run this example and to study its code.
                </para>
		<programlisting>
....
// Configure the Header text attributes
TextAttributes hta;
hta.setPen( QPen(  Qt::blue ) );

// let the header resize itself
// together with the widget.
// so-called relative size
Measure m( 35.0 );
m.setRelativeMode( header->autoReferenceArea(),
KDChartEnums::MeasureOrientationMinimum );
hta.setFontSize( m );
// min font size
m.setValue( 3.0 );
m.setCalculationMode(
KDChartEnums::MeasureCalculationModeAbsolute );
hta.setMinimalFontSize( m  );

// Assign thre text attributes
// to our header.
header->setTextAttributes( hta );
...
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-sampletextattributes">
		    <title>A Chart with a configured Data Values Labels</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/headerparameters.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    <filename>examples/HeadersFooters/HeadersFootersParameters</filename>.
		</para>
            </sect2> 
        </sect1>
	<sect1>
            <title id="customizingmarkers">Markers Attributes</title>
             <para>
                MarkerAttributes encapsulates settings that have to do with markers. This includes 
		there types ( square, diamond, ring etc...), size and colors. For the convenience 
		the user may also set up a Map of markers...
            </para>  
             <para>
		We recommend you to consult <classname>KDChartMarkerAttributes</classname>' interface 
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that will demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		Marker attributes can be set with some defined type(s), size, color etc..., the list 
		below gives us an overview about the most used features. We will only list the setters 
		here and explain them - Of course each of those setters has a corresponding getter.	
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setMarkerStyle( const MarkerStyle style ): Set the style of the marker to be 
			used.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setMarkerSize( const QSizeF&amp; size ): Set the size of the marker.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setMarkerColor( const QColor&amp; color ): Set the color of the marker.
		    </para>
		</listitem>		
		<listitem>
		    <para>
			void setVisible( bool visible ): Set whether marker attributes should be 
			displayed.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setMarkerStylesMap( MarkerStylesMap map ): Define a map of marker to be used.
		    </para>
		</listitem>
	    </itemizedlist>
	    <note>
		<para>
		    As defined in the <classname>KDChartMarkersAttributes</classname> class'interface
		    the differnet marker types available are:
		</para>
		<programlisting>
....
enum MarkerStyle { MarkerCircle  = 0,
                   MarkerSquare  = 1,
                   MarkerDiamond = 2,
                   Marker1Pixel  = 3,
                   Marker4Pixels = 4,
                   MarkerRing    = 5,
                   MarkerCross   = 6,
                   MarkerFastCross = 7 };
...
	        </programlisting>
	    </note>
	    <para>
		The process to configure the marker attributes is very simple, and similar to all 
		other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the marker attributes - e.g We want to configure their types and sizes 
			we need to configure the data values marker attributes and call them as follow:
			<methodname>MarkerAttributes ma( dva.markerAttributes() )</methodname>
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to your data values attributes. e.g call 
			<methodname>dva.setMarkerAttributes( ma )</methodname>.
		    </para>
		</listitem>			
	    </itemizedlist>
            <sect2>
                <title id="markersample" xreflabel="codesample">Markers Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which describe 
		    the above process. This example is based on the <filename>mainwindow.cpp</filename> 
		    file of the <filename>examples/Axis/Parameters</filename>. We recommend  you to compile
		    and run this example and to study its code.
                </para>
		<programlisting>
....
// set up a map with different marker styles
MarkerAttributes::MarkerStylesMap map;
map.insert( 0, MarkerAttributes::MarkerSquare );
map.insert( 1, MarkerAttributes::MarkerCircle );
map.insert( 2, MarkerAttributes::MarkerRing );
map.insert( 3, MarkerAttributes::MarkerCross );
map.insert( 4, MarkerAttributes::MarkerDiamond );
....
// Configure mmarkers per dataset in this example
const int colCount =
    m_lines->model()-&gt;columnCount(m_lines->rootIndex());
for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
    DataValueAttributes dva
        ( m_lines->dataValueAttributes( iColumn ) );
    MarkerAttributes ma( dva.markerAttributes() );
    ma.setMarkerStylesMap( map );
    ma.setMarkerSize( QSize( markersWidthSB->value(),
    markersHeightSB->value() ) );
}
....
ma.setVisible(  true );

// Assign markers attributes
// to Data values attributes
dva.setMarkerAttributes( ma );

//Assign Data Values Attributes to
//Diagram
m_lines->setDataValueAttributes( iColumn, dva );
....
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-samplemarkerattributes">
		    <title>A Chart with configured Data Values Markers</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/markersample.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    See file: <filename>examples/Axis/Parameters/mainwindow.cpp</filename>.
		</para>
            </sect2> 
        </sect1>
	<sect1>
            <title id="customizingbackground">Background Attributes</title>
	    <para>
                Background attributes encapsulates settings that have to do with backgounds for 
		the divers elements of a chart view. This includes there modes( pixmap and its 
		sub-modes and brush)...
            </para>  
             <para>
		We recommend you to consult <classname>KDChartBackgroundAttributes</classname>'interface 
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that will demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		The list below gives us an overview about the most used features. We will only list the 
		setters here and explain them - Of course each of those setters has a corresponding getter.
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setVisible( bool visible ):
		    </para>
		</listitem>
		<listitem>
		    <para>
			setBrush( const QBrush &amp;brush ):
		    </para>
		</listitem>
		<listitem>
		    <para>
			setPixmapMode( BackgroundPixmapMode mode ):
		    </para>
		</listitem>		
		<listitem>
		    <para>
			setPixmap( const QPixmap &amp;backPixmap ):
		    </para>
		</listitem>	
	    </itemizedlist>
	    <note>
		<para>
		    As defined in the <classname>KDChartBackgroundAttributes</classname> class'interface
		    the different <filename>BackgroundPixmapMode</filename> available are:
		</para>
		<programlisting>
....
enum BackgroundPixmapMode {
    BackgroundPixmapModeNone,
    BackgroundPixmapModeCentered,
    BackgroundPixmapModeScaled,
    BackgroundPixmapModeStretched
};
...
	        </programlisting>
	    </note>
	    <para>
		The process to configure the background attributes is very simple, and similar to all 
		other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the background attributes and configure it.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to the element of a chart.
			<methodname>element.setBackgroundAttributes( ba )</methodname>.
		    </para>
		</listitem>			
	    </itemizedlist>
            <sect2>
                <title id="bgsample" xreflabel="codesample">Background Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which describe 
		    the above process. This example is based on the <filename>main.cpp</filename> 
		    file of the <filename>examples/Background</filename>. We recommend  you to compile
		    and run this example and to study its code.
                </para>
		<programlisting>
....
// Configure the plane's Background
BackgroundAttributes pba;
pba.setPixmap(  *pixmap );
pba.setPixmapMode(
BackgroundAttributes::BackgroundPixmapModeStretched );
pba.setVisible( true );
diagram->coordinatePlane()->setBackgroundAttributes(  pba );

// Configure the Header's Background
BackgroundAttributes hba;
hba.setBrush( Qt::white );
hba.setVisible( true );
header->setBackgroundAttributes(  hba );
....
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-samplebgattributes">
		    <title>A Chart with configured Back Ground Attributes</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/bgsample.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    See file: <filename>examples/Background</filename>.
		</para>
            </sect2> 
        </sect1>	
	<sect1>
            <title id="customizingframes">Frame Attributes</title>
            <para>
                Frame attributes encapsulates settings that have to do with frames for 
		the divers elements of a chart view. This includes their pen and padding 
		properties...
            </para>  
             <para>
		We recommend you to consult <classname>KDChartFrameAttributes</classname>'interface 
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that will demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		The list below gives us an overview about the most used features. We will only list the 
		setters here and explain them - Of course each of those setters has a corresponding getter.
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setVisible( bool visible ):
		    </para>
		</listitem>
		<listitem>
		    <para>
			setPen( const QPen &amp;pen ):
		    </para>
		</listitem>
		<listitem>
		    <para>
			setPadding( int padding ):
		    </para>
		</listitem>				
	    </itemizedlist>	    
	    <para>
		The process to configure the frame attributes is very simple, and similar to all 
		other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the frame attributes and configure it.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to the element of a chart.
			<methodname>element.setFrameAttributes( fa )</methodname>.
		    </para>
		</listitem>			
	    </itemizedlist>
            <sect2>
                <title id="framesample" xreflabel="codesample">Frame Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which describe 
		    the above process. This example is based on the <filename>main.cpp</filename> 
		    file of the <filename>examples/Background</filename>. We recommend  you to compile
		    and run this example and to study its code.
                </para>
		<programlisting>
....
// Configure the plane Frame attributes
FrameAttributes pfa;
pfa.setPen( QPen ( QBrush( Qt::blue ), 2 ) );
pfa.setVisible( true );
diagram->coordinatePlane()->setFrameAttributes(  pfa );

// Configure the header Frame attributes
FrameAttributes hfa;
hfa.setPen( QPen ( QBrush( Qt::darkGray ), 2 ) );
hfa.setPadding( 2 );
hfa.setVisible( true );
header->setFrameAttributes(  hfa );
....
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-sampleframeattributes">
		    <title>A Chart with configured Frame Attributes</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/framesample.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    See file: <filename>examples/Background</filename>.
		</para>
            </sect2> 
        </sect1>
	<sect1>
            <title id="customizinggrid">Grid Attributes</title>
            <para>
                Grid attributes encapsulates settings that have to do with grids. This 
		includes their pen, step width, visibility properties ...etc
            </para>  
             <para>
		We recommend you to consult <classname>KDChartGridAttributes</classname>'interface 
		to find out more in details what can be done. In this section we will describe quickly 
	        its main properties and go through a commented example that demonstrates how to 
		proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		The list below gives us an overview about the most used features. We will only list 
		the setters here and explain them - Of course each of those setters has a 
		corresponding getter.
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setGridVisible( bool visible ): set whether the grid should be painted or not 
		    </para>
		</listitem>
		<listitem>
		    <para>
			setGridStepWidth( qreal stepWidth=0.0 ): set the distance between the lines 
			of the grid
		    </para>
		</listitem>
		<listitem>
		    <para>
			setGridPen( const QPen &amp; pen ): set the main grid pen.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setSubGridVisible( bool visible ): Specify whether the sub-grid should be 
			displayed.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setSubGridPen( const QPen &amp; pen ): set the sub-grid pen.
		    </para>
		</listitem>
			<listitem>
		    <para>
			setZeroLinePen( const QPen &amp; pen ): set the zero line pen.
		    </para>
		</listitem>
	    </itemizedlist>	    
	    <para>
		The process to configure the grid attributes is very simple, and similar to all 
		other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the grid attributes and configure it.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to the plane using one of the setter 
			available, e.g
			<methodname>CartesianCoordinatePlane::setGridAttributes
			    ( Qt::Orientation orientation, const GridAttributes &amp; )</methodname>.
			or <methodname>AbstractCoordinatePlane::setGlobalGridAttributes
			    ( const GridAttributes &amp; )</methodname>
		    </para>
		</listitem>			
	    </itemizedlist>
	    <note>
		<para>
		    In case you want to set your grid attributes with orientation using the 
		    <classname>CartesianCoordinatePlane</classname> method above you will need 
		    to cast your <methodname>AbstractCoordinatePlane* coordinatePlane() const;
		    </methodname> which return a pointer to 
		    <classname>AbstractCoordinatePlane</classname> as presented in the following 
			example.
		</para>
		<para>
		    Otherwise you just need to set the grid attributes globally as follow:
		</para>
		<programlisting>
GridAttributes ga = diagram->coordinatePlane()->globalGridAttributes();
ga.setGlobalGridVisible( false );
diagram->coordinatePlane->setGlobalGridAttributes( ga );
	        </programlisting>
	    </note>
            <sect2>
                <title id="gridsample" xreflabel="codesample">Grid Attributes Sample code</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which 
		    describe the above process. This example is based on the 
		    <filename>main.cpp</filename> file of the <filename>examples/Grids</filename>. 
		    We recommend  you to compile and run this example and to study its code.
                </para>
		<programlisting>
// diagram->coordinatePlane returns an abstract plane.
// if we want to specify the orientation we need to cast
// as follow
CartesianCoordinatePlane* plane =
    static_cast &lt;CartesianCoordinatePlane*&gt;
        ( diagram->coordinatePlane() );

// retrieve your grid attributes
// display grid and sub-grid
GridAttributes ga ( plane->gridAttributes( Qt::Vertical ) );
ga.setGridVisible(  true );
ga.setSubGridVisible( true );

// Configure a grid pen
QPen gridPen(  Qt::magenta );
gridPen.setWidth( 3 );
ga.setGridPen(  gridPen );

// Configure a sub-grid pen
QPen subGridPen( Qt::darkGray );
subGridPen.setStyle( Qt::DotLine );
ga.setSubGridPen(  subGridPen );

// Display a blue zero line
ga.setZeroLinePen( QPen( Qt::blue ) );

// Assign your grid to the plane
plane->setGridAttributes( Qt::Vertical,  ga );
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-samplegridattributes">
		    <title>A Chart with configured Grid Attributes</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/gridsample.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    See file: <filename>examples/Grids</filename>.
		</para>
            </sect2> 
        </sect1>
	<sect1>
            <title id="customizingthreed">ThreeD Attributes</title>
            <para>
                ThreeDAttributes properties are defined at different levels in the KD Chart 2 API.
		We have the properties available to all types of diagram which are defined in the 
		<classname>KDChartAbstractThreeDAttributes</classname> and the ones specific to 
		a type of diagram. At the moment we support THreeD for Bar, lines and Pie diagrams
		and the ThreeD attributes for those diagrams types are defined in their own 
		attributes classes. We have <classname>KDChartThreeDBarAttributes</classname>,
		<classname>KDChartThreeDLineAttributes</classname> and 
		<classname>KDChartThreeDPieAttributes</classname>
            </para>  
	    <para>
                ThreeD attributes encapsulates settings that have to do with threeD display. This 
		includes their depth, angle, rotation etc ... depending of the chart type we are 
		working with.
            </para>  
             <para>
		We recommend you to consult the <classname>*ThreeDAttributes</classname> 
		class'interface to find out more in details what can be done. In this section we 
		will describe quickly its main properties and go through a commented example that 
		demonstrates how to proceed in order to use and configure those attributes.		
	    </para>
	    <para>
		The list below gives us an overview about the most used features. We will only list 
		the setters here and explain them - Of course each of those setters has a 
		corresponding getter.
	    </para>
	    <para>
		1 - Generic (common to all diagrams) ThreeD Attributes
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setEnabled( bool enabled ): set whether threeD display mode is on or off.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setDepth( double depth ): set the depth of the threeD effect (see example below).
		    </para>
		</listitem>		
	    </itemizedlist>	    
	     <para>
		2 - ThreeD Bar Attributes - Specific to bar diagrams.
	    </para>
	    <itemizedlist>		
		<listitem>
		    <para>
			setAngle( uint threeDAngle ): Not implemented yet
		    </para>
		</listitem>	
	    </itemizedlist>
	    <para>
		3 - ThreeD Line Attributes - Specific to line diagrams.
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setLineXRotation( const uint degrees ): rotate the x coordinate.
		    </para>
		</listitem>
		<listitem>
		    <para>
			setLineYRotation( const uint degrees ): rotate the y coordinate.
		    </para>
		</listitem>	
	    </itemizedlist>
	   <para>
		4 - ThreeD Pie Attributes - Specific to Pie diagrams.
	    </para>
	    <itemizedlist>
		<listitem>
		    <para>
			setUseShadowColors( bool useShadowColors ): Not implemented yet
		    </para>
		</listitem>
	    </itemizedlist>
	    <para>
		The process to configure the grid attributes is very simple, and similar to all 
		other kind of attributes:
	    </para>
	     <itemizedlist>
		<listitem>
		    <para>
			Call the threeD attributes and configure it.
		    </para>
		</listitem>
		<listitem>
		    <para>
			Assign the configurated attributes to the diagram by calling the available 
			method <methodname>setThreeDAttributes()</methodname> method.
		    </para>
		</listitem>			
	    </itemizedlist>
            <sect2>
                <title id="threedsample" xreflabel="threedsample">ThreeD Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following lines of code which 
		    describe the above process. This example is based on the 
		    <filename>mainwindow.cpp</filename> file of the <filename>examples/Bars/Advanced</filename>. 
		    We recommend  you to compile and run this example and to study its code.
                </para>
		<programlisting>
// Retrieve the threeD attributes for
// the diagram
ThreeDBarAttributes td( m_bars->threeDBarAttributes() );

// set its depth property
td.setDepth( depthSB->value() );

// Implicitely enable threeD Mode
td.setEnabled( true );

// Assign to the diagram
m_bars->setThreeDBarAttributes( td );

// Re-paint
m_chart->update();
	        </programlisting>
		<para>
		    As we can see the code is straight forward and the process is similar 
		    as for setting all others types of attributes.
		</para>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the 
		    above code. 
		</para>
		<figure float="0" id="fig-samplethreedattributes">
		    <title>A ThreeD Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata
				fileref="images/threedsample.png"
				width="3in" scalefit="1"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We recommend you to modify, compile and run the example at the following location: 
		    See file: <filename>examples/Bars/Advanced</filename>.
		</para>
            </sect2>
        </sect1>
        <?page-break?>
        <sect1>
            <title id="rel_abs_measures">Font Sizes and other Measures</title>
            <para>
                This chapter illustrates how to use the <classname>KDChart::Measure</classname>
                class to specify sizes. Closely related to <classname>Measure</classname> is the
                <classname>KDChart::RelativePosition</classname> class explained in the
                section <methodname>Relative and Absolute Positions</methodname> following this one.
            </para>
            <sect2>
                <title>When and how to use the Measure class</title>
                <para>
                    <classname>KDChart::Measure</classname> is used to specify
                    absolute values or relative measures to be re-calculated at runtime
                    according to the size of a reference area, e.g. for font
                    sizes or to define the distance between a text and its anchor point.
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Absolute values are used to set a fixed measure, e.g. when
                            the same font size is to be used, no matter how large the
                            chart widget is displayed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Relative measures specify values that are multiplied by 1/1000 of
                            their reference area's width (or height, resp.) at runtime.
                            &kdchart; uses this to link the default legend fonts to the
                            chart's size: The legend is adjusted when your widget is resized.
                        </para>
                    </listitem>
                </itemizedlist>
                <tip>
                    <para>
                        The <classname>KDChart::TextAttributes</classname> class can handle
                        both kinds of measures at the same time: You often might wish to
                        specify a relative size via <methodname>setFontSize</methodname> and
                        set a fixed value via <methodname>setMinimalFontSize</methodname> so
                        the font will be dynamically calculated according to the area size
                        but it will never be smaller than that specific minimum.
                    </para>
                </tip>
                <para>
                    Being a typical value class <classname>Measure</classname> is commonly
                    initialized by the copy constructor since you should modify
                    &kdchart;'s pre-defined settings rather than defining new ones from
                    scratch. File <filename>examples/Lines/Parameters/main.cpp</filename>
                    shows how to do that:
                </para>
                <programlisting>
// Retrieve the data value attrs from your diagram, and retrieve their text attrs
DataValueAttributes dva( diagram->dataValueAttributes() );
TextAttributes ta( dva.textAttributes() );

// Retrieve the font size and increase its value
Measure me( ta.fontSize() );
me.setValue( me.value() * 1.25 );

// Make the data value texts visible
ta.setVisible(  true );
dva.setVisible( true );

// Set the font size, set the text attrs, set the data value attrs
ta.setFontSize( me );
dva.setTextAttributes( ta );
diagram->setDataValueAttributes( dva );
                </programlisting>
            </sect2>
            <sect2>
                <title>How to specify absolute values</title>
                <para>
                    To specify an absolute value for a Measure that you have
                    initialized via copy constructor please use the
                    <methodname>setAbsoluteValue()</methodname> method:
                </para>
                <programlisting>
Measure me( someTextAttributes.fontSize() );
me.setAbsoluteValue( 16 );
someTextAttributes.setFontSize( me );
                </programlisting>
                <para>
                    If you want to declare a new Measure from scratch
                    just set the first two constructor parameters:
                </para>
                <programlisting>
Measure me( 16, KDChartEnums::MeasureCalculationModeAbsolute );
                </programlisting>
                <para>
                    In this case you can ommit the third parameter, since
                    the orientation setting is ignored for absolute values.
                </para>
            </sect2>
            <sect2>
                <title>How to specify relative values</title>
                <para>
                    To specify a relative value for a Measure (no matter
                    if initialized via copy constructor or not) you can
                    use <methodname>setValue()</methodname> together with
                    either <methodname>setRelativeMode()</methodname> or
                    both <methodname>setReferenceArea()</methodname> and/or
                    <methodname>setReferenceOrientation()</methodname>.
                    So if your measure was using a fixed font size before
                    you could say:
                </para>
                <programlisting>
me.setValue( 25 );
me.setRelativeMode( m_chart, KDChartEnums::MeasureOrientationMinimum );
                </programlisting>
                <para>
                    Note that <methodname>setRelativeMode()</methodname>
                    is a convenience method that will implicitely
                    enable the relative calculation mode.
                </para>
                <para>
                    When not using <methodname>setRelativeMode()</methodname> you
                    need to explicitely call <methodname>setCalculationMode(
                    KDChartEnums::MeasureCalculationModeRelative )</methodname>,
                    if your Measure was not set to this mode before:
                </para>
                <programlisting>
me.setValue( 25 );
me.setReferenceArea( m_chart );
me.setReferenceOrientation( KDChartEnums::MeasureOrientationMinimum );
me.setCalculationMode(      KDChartEnums::MeasureCalculationModeRelative );
                </programlisting>
                <para>
                    In both cases the reference area must be derived from
                    <classname>KDChart::AbstractArea</classname> or derived from
                    <classname>QWidget</classname>. The orientation can be
                    Horizontal, Vertical, Minimum, Maximum, the later ones
                    meaning the area's qMin(width, height) or its qMax(), resp.
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title id="rel_abs_positions">Relative and Absolute Positions</title>
            <para>
                This chapter covers the <classname>KDChart::Position</classname>
                and <classname>KDChart::RelativePosition</classname> classes.
                For details on the closely related <classname>KDChart::Measure</classname>
                class see the preceeding section
                <methodname>Font Sizes and other Measures</methodname>.
            </para>
            <sect2>
                <title>What is relative positioning all about?</title>
                <para>
                    Introduced for floating objects in &kdchart; 2 relative positioning
                    is defining a point in relation to a reference point that in
                    turn is specified in relation to a reference area.
                </para>
                <para>
                    This illustration shows the nine position points defined for a bar,
                    see the magnified area for the relative positioning of negative /
                    positive data value texts.
                </para>
                <figure float="0" id="fig-relativeposition">
                    <title>Data value text positions relative to compass points</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                                    fileref="images/relativeposition.png"
                                    width="4in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </sect2>
            <sect2>
                <title>How to specify a position</title>
                <orderedlist numeration="arabic">
                    <listitem>
                        <para>
                            If necessary name a reference area or define a set of reference points.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Use <classname>KDChart::Position</classname> to pick one of the
                            reference area's compass points.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Specify padding and alignment in horizontal and vertical
                            direction.
                        </para>
                    </listitem>
                </orderedlist>
            </sect2>
            <sect2>
                <title>Using Position and RelativePosition</title>
                <para>
                    Illustrated on the preceeding page you have seen the most
                    common use of these position classes: Defining the placement
                    of data value texts in relation to their respective areas.
                </para>
                <para>
                    By default positive and negative data value texts are positioned
                    in different ways: While positive texts would use the bar's
                    <varname>Position::NorthWest</varname> their negative counterparts
                    are located next to the <varname>Position::SouthEast</varname>
                    point of the bar. Also the positive texts are using another way of
                    alignment than the negative ones.
                </para>
                <para>
                    The reason for this is to make it easy to specify rotated data
                    value texts: Because of different reference points and alignment
                    the texts will look good even when rotated, without the need of
                    adjusting other settings than just the rotation angle itself.
                </para>
                <para>
                    Being a typical value class <classname>RelativePosition</classname> is
                    commonly initialized by the copy constructor since you should modify
                    &kdchart;'s pre-defined settings rather than defining new ones from
                    scratch, so you could specify non-rotated, centered texts as shown
                    in the following code, that is using extra indentation to indicate
                    get/set relationship:
                </para>
                    <programlisting>
// Retrieve the data value attrs from your diagram
DataValueAttributes dva( diagram->dataValueAttributes() );

    // Set the text rotation to Zero degrees
    TextAttributes ta = dva.textAttributes();
        ta.setRotation( 0 );
    dva.setTextAttributes( ta );

    // Retrieve the current position settings
    RelativePosition posPositive( dva.position( true ) );
    RelativePosition posNegative( dva.position( false ) );

        // Choose the centered position points
        posPositive.setReferencePosition( Position::North );
        posNegative.setReferencePosition( Position::South );

        // Adjust the alignment of the texts:
        // horizontally centered to their respective position points
        posPositive.setAlignment( Qt::AlignHCenter | Qt::AlignBottom );
        posNegative.setAlignment( Qt::AlignHCenter | Qt::AlignTop );

    // Set the positions
    dva.setPositivePosition( posPositive );
    dva.setNegativePosition( posNegative );

    // Make the data value texts visible
    dva.setVisible( true );

// Set the data value attrs
diagram->setDataValueAttributes( dva );
                </programlisting>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Advanced charting.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_advancedcharting">
        <title id="chtxt_advancedcharting">Advanced Charting</title>
        <titleabbrev id="chnum_advancedcharting">Chapter 9</titleabbrev>
	<para>
	    In this section we are presenting some examples to demonstrate interesting
	    features offered by the KD Chart 2.0 API by displaying the resulting widget and
	    giving you a link to the directory in which you can study the example code, compile 
	    and run it.
        </para>	
	<sect1>
	    <title>Example programs to consult</title>
	<para>
	    This chapter will grow in relation to the feedback and whishes we get from our 
	    customers. 
	</para>	
	<para>
	    1 - <filename>/examples/Axis/Parameters</filename>
	</para>
	    <figure float="0" id="fig-axisparameters">
		<title>/examples/Axis/Parameters</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/axisparameters.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>
	<para>
	    2 - <filename>/examples/Bars/Advanced</filename>
	</para>
	    <figure float="0" id="fig-baradvanced">
		<title>/examples/Bars/Advanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/fullbarchart.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure> 
	<para>
	    3 - <filename>/examples/HeadersFooters/HeadersFooters/Advanced</filename>
	</para>
	    <figure float="0" id="fig-headersfootersadvanced">
		<title>/examples/HeadersFooters/HeadersFooters/Advanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/headersfootersadvanced.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>  
	<para>
	    4 - <filename>/examples/Legends/LegendAdvanced</filename>
	</para>
	    <figure float="0" id="fig-legendsadvanced">
		<title>/examples/Legends/LegendAdvanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/legendsadvanced.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>  
	<para>
	    5 - <filename>/examples/Lines/Advanced</filename>
	</para>
	    <figure float="0" id="fig-linesadvanced">
		<title>/examples/Lines/Advanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/linesadvanced.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>  
	<para>
	    6 - <filename>/examples/ModelView</filename>
	</para>
	    <figure float="0" id="fig-modelview">
		<title>/examples/ModelView</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/modelview.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>  
	<para>
	    7 - <filename>/examples/Pie/Advanced</filename>
	</para>
	    <figure float="0" id="fig-pieadvanced">
		<title>/examples/Pie/Advanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/pieadvanced.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure> 
	<para>
	    8 - <filename>/examples/SharedAbscissa</filename>
	</para>
	    <figure float="0" id="fig-sharedabscissa">
		<title>/examples/SharedAbscissa</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/sharedabscissa.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>
	<para>
	    9 - <filename>/examples/Widget/Advanced</filename>
	</para>
	    <figure float="0" id="fig-widgetadvanced">
		<title>/examples/Widget/Advanced</title>
		<mediaobject>
		    <imageobject>
			<imagedata
			    fileref="images/widgetadvanced.png"
			    width="3in" scalefit="1"/>
		    </imageobject>
		</mediaobject>
	    </figure>	 
	</sect1>
        <sect1>
            <title>What's next</title>
            <para>
                FAQ.
            </para>
        </sect1>
    </chapter>
    <appendix id="appendix_qanda">
        <title>Q&amp;A section</title>
        <titleabbrev>Appendix A</titleabbrev>
        <qandaset defaultlabel="number">
            <qandadiv>
                <title>Storing / loading of &kdchart; settings</title>
                <qandaentry id="qa_serialize1">
                    <question>
                        <para>
                            How can I store &kdchart; settings to a file?
                        </para>
                    </question>
                    <answer>
                        <para>
                            This can be done by using
                            the <classname>KDChart::Serializer</classname> class.
                        </para>
                        <para>
                            Note that <classname>KDChart::Serializer</classname> is
                            dependent on your Qt library containing
                            the <classname>QtXml</classname> module which provides
                            C++ implementations of <classname>SAX</classname> and
                            <classname>DOM</classname>.
                        </para>
                        <para>
                            The decision to
                            have <classname>KDChart::Serializer</classname> in
                            a separate library was made to allow you to build &kdchart;
                            even if your version of Qt does not include the XML module.
                        </para>
                        <para>
                            To build it, just run
                        </para>
                            <programlisting>
  cd kdchartserializer
  qmake
  make   (or nmake, for Windows, resp.)
                            </programlisting>
                        <para>
                            Please refer to the examples stored in
                            <classname>kdchartserializer/examples/</classname>
                            showing how to use the serializer
                            and how to connect your diagram(s) to the correct
                            data model(s) after the serializer has finished
                            running.
                        </para>
                    </answer>
                </qandaentry>
            </qandadiv>
        </qandaset>
        <note>
            <para>
                This section will grow further according to the most frequently
                asked questions to our support.
            </para>
        </note>
    </appendix>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->

