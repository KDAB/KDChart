<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/xml/docbook/schema/dtd/4.2/docbookx.dtd" [
        <!ENTITY auml "&#x00E4;">
        <!ENTITY mdash "&#x2014;">
        <!ENTITY nbsp "&#x00A0;">
        <!ENTITY kdchart "KD&#x00A0;Chart">
]>
<book>
    <bookinfo>
	<title>&kdchart; Programmer's Manual</title>
	<corpauthor>The &kdchart; Team</corpauthor>
	<corpname>Klar&auml;lvdalens Datakonsult AB</corpname>
        <releaseinfo>Version 2.0</releaseinfo>
        <legalnotice>
            <para>
                The contents of this manual and the associated &kdchart;
                software are the property of Klar&auml;lvdalens Datakonsult AB
                and are copyrighted. Any reproduction in whole or in part is
                strictly prohibited without prior written permission by
                Klar&auml;lvdalens Datakonsult AB.
            </para>    
	    <para>
                &kdchart; and the &kdchart; logo are trademarks or registered
                trademarks of Klar&auml;lvdalens Datakonsult AB in the European
                Union, the United States, and/or other countries. Other
                product and company names and logos may be trademarks or 
		registered trademarks of their respective companies.
            </para>
        </legalnotice>
        <copyright>
            <year>2001&mdash;2006</year>
            <holder>Klar&auml;lvdalens Datakonsult AB</holder>
        </copyright>
    </bookinfo>

    <!-- =====================Introduction============================== -->

    <chapter id="chapter_introduction">
        <title id="chtxt_introduction">Introduction</title>
        <titleabbrev id="chnum_introduction">Chapter 1</titleabbrev>

        <para>
	    &kdchart; is Klar&auml;lvdalens Datakonsult AB's charting package 
	    for Qt applications.
            This is the &kdchart; Programmer's Manual. It will get you
            started with creating your charts and provides lots of pointers
	    to its many advanced features.
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Depending on your &kdchart; version, you will find
                    different <filename>INSTALL</filename> files that explain
                    how to install &kdchart; on your platform and a step by 
		    step description about how to build  it from sources.
                </para>
            </listitem>
            <listitem>
                <para>
                    &kdchart; also comes with an extensive Reference Manual
                    generated directly from the source code itself.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            You should refer to it in conjunction with this Programmer's
            Manual.
        </para>
        <itemizedlist>
         <listitem>
                <para>
                    What is &kdchart;?
                </para>
		<para>
		    &kdchart; is a tool for creating business and engineering
		    charts, and is the most powerful Qt component of its kind.
		    Besides having all the standard features, it also enables 
		    the developer to design and manage a large number of axes 
		    and provide sophisticated means of layout customization.
		    Since all configuration settings have reasonable defaults
		    you can usually get by with setting only a handful of 
		    parameters and relying on the defaults for the rest.
		</para>    
            </listitem>
            <listitem>
                <para>
                    What can we use &kdchart; for?
		</para>
		<para>
		    &kdchart; is used by a variety of programs for many 
		    different purposes. 
		</para>
		<!-- Pending Michel: insert screen-shot -->
		<!--
                 * Demonstrate in short sentences associated to screen-shots
                    that kdc can be used for both business charts and
                    engineering charts.
		-->
		<para>
		    The above example shows how &kdchart; is used for 
		    visualizing flood events in a river; other samples on our 
		    web site at <filename>http://www.kdab.net/kdchart</filename>
		    show how &kdchart; is used for monitoring seismic activity.
                    It is no coincidence that the current version of the 
		    KOffice productivity suite uses our library.
		</para>
		<para>    
		    <!-- Pending Michel -->
                    * Display a view with small diagrams and arrows showing
                    how the main classes work together
                </para>
            </listitem>
        </itemizedlist>
        <sect1>
            <title id="prerequisites">What You Should Know</title>
            <para>
                You should be familiar with writing Qt applications, as
                well as have a working C++ knowledge. When you are in
                doubt about how a Qt4 class mentioned in this Programmer's 
		Guide works, please check the Qt4 reference documentation or 
		a good book about Qt4. A more in-depth introduction to the 
		API can be found in the file 
		<filename>doc/KDChart-2.0-API-Introduction</filename>.
                Also to browse &kdchart; API Reference documentation start 
		with this file: <filename>doc/refman/index.html</filename>.
            </para>
        </sect1>
        <sect1>
            <title id="structure">The Structure of This Manual</title>
            <para>
                How we will proceed to present &kdchart; for Qt4?
            </para>
            <para>
		This manual starts with an introduction to &kdchart;2.0 API
		before going through the basic steps and methods for the user 
		to create hers own chart.
            </para>
	    <para>
		The following Chapter 4 <filename>Coordinate planes and 
		Diagrams</filename> will provide the reader with more details 
		about the different chart types supported and the information 
		you need to know in order to use &kdchart;'s features the best
		way.
	    </para>
	    <para>
		The subsequent chapters contain more advanced customizing 
		material like how to specify colors, fonts and other attributes
		if you don't want to use &kdchart;'s default settings. How to 
		create and display headers and footers, legends and configure 
		your chart axes.
	    </para>
	    <para>
		Chapter 9 <filename>Advanced Charting</filename>, will guide 
		you through &kdchart; other more advanced features and 
		describe the way to use them (frames and backgrounds, 
		data values, axis and grid manipulations etc...). It will also
		show in details different interesting features like 
		Interactive and Multiple charts or Zooming.		
	    </para>
	    <para>
                We provide you with lots of sample code combined with 
		screen-shots that show the resulting display. 
                We recommend our readers to try and run the sample code and
                experiment with the various settings.
            </para>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                In the next chapter we introduce you to &kdchart; 2.0 new API.
            </para>
       </sect1>
    </chapter>

    <!-- ============ KD Chart 2.0 API Introduction ============= -->

    <chapter id="chapter_api">
        <title id="chtxt_api">KD Chart 2 API Introduction</title>
        <titleabbrev id="chnum_api">Chapter 2</titleabbrev>
        <para>
            Version 2.0 of KD Chart fully supports and builds on the 
	    technologies introduced with Qt 4. The charting engine makes use 
	    of the Arthur and Scribe painting and text rendering frameworks 
	    to achieve high quality visual results. KD Chart 2.0 also 
	    integrates with the Interview framework for model/view separation 
	    and, much like Qt 4 itself, provides a convenience Widget class 
	    for those cases where that is too complex.
        </para>
        <sect1>
            <title id="apioverview">Overview</title>
            <para>
		&kdchart; 2.0 overall API strives for maximum consistency with 
		the concepts and API style found in Qt 4. Of course, this 
		means breaking source compatibility in several places, but 
		like Trolltech, we have made a conscious decision that it 
		would be better to clean up the API now, than to carry it 
		with us into the next &kdchart; generation. 
	    </para>
	    <note>
		<para>
		    Wherever possible, compatibility methods and classes have 
		    been, or will be, provided.		
		</para>
	    </note>
	    <para>
		The core of &kdchart;'s 2.0 API is the 
		<classname>KDChart::Chart</classname> class.
		It encapsulates the canvas onto which the individual 
		components of a chart are painted, manages them and provides 
		access to them. There can be more than one 
		<classname>KDChart::Diagram</classname> on a 
		<classname>KDChart::Chart</classname>, how they are laid out 
		is determined by which axes, if any, they share (more on axes 
		further below).
	    </para>
	    <para>
		<classname>KDChart::Diagram</classname> subclasses for the 
		various types of charts are provided, such as 
                <classname>KDChart::PieDiagram</classname>, and users can 
		subclass <classname>KDChart::AbstractDiagram</classname> (or 
		one of the other Diagram classes starting with Abstract, 
		which are designed to be base classes) to implement custom 
		chart types. A typical use of a simple BarDiagram looks like 
		this:
	    </para>
            <sect2>
                <title id="apisample" xreflabel="codesample">Code Sample</title>
		<programlisting>
		    using namespace KDChart;
		    ......
		    BarDiagram *bars = new BarDiagram;
		    bars->setModel( &amp;m_model );		    
		    chart->coordinatePlane()->replaceDiagram( bars );
		    .....
		</programlisting>
		<para>
		    You could also use the following way, to prevent your 
		    compiler from complaining about instance bars not being 
		    free'ed:
		</para>
		<programlisting>
		    BarDiagram *bars = static_cast &lt;BarDiagram *&gt;
		    (myChart->replaceDiagram( new BarDiagram ));
		    //now call the setter methods ... 
		</programlisting>
                <para>
                    In Chapter 3 
		    <filename>Basic steps: Create a Chart</filename> we will 
		    make this somewhat abstract description more concrete by 
		    looking at some complete examples (Widget and Charts), 
		    which we recommend you to compile and run.
		</para>
		<para>
		    For now, in order for you to have an understanding about  
		    KD Chart 2.0 API and its features to know the following:   
		</para> 
		<itemizedlist>
		    <listitem>
			<para>
			    Each diagram has an associated Coordinate Plane 
			    (Cartesian by default), which is responsible for 
			    the translation of data values into pixel 
			    positions. It defines the scale of the diagram, 
			    and all axes that are associated with it. This 
			    makes implementing diagram subclasses (types) much
			    easier, since the drawing code can leave all of the
			    coordinate calculation work to the coordinate 
			    plane. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Each coordinate plane can have one or more diagram 
			    associated to it. Those diagrams will share the scale 
			    provided by the plan. Also a chart can have more than 
			    one coordinate plane. This makes it possible to have 
			    multiple diagrams (e.g a line and a bar chart) using the 
			    same or different scales and displayed next to, or on top 
			    of each other in the same chart. 
			</para>
		    </listitem>		
		    <listitem>
			<para>
			    To share an axis among two planes (and also diagrams)
			    we just need to add it to both diagrams. The Chart 
			    lay-outing engine will take care of adjusting positions 
			    accordingly.
			</para>
		    </listitem>
		    </itemizedlist>
		 <!--
                Pending Michel link:
		(see src/KDChartAbstractCoordinatePlane.h and
		examples/SharedAbscissa/mainwindow.cpp)
                <programlisting linenumbering="numbered" id="">
                    <textobject>
                        <textdata fileref="../../examples/..."/>
                    </textobject>
                </programlisting>
                -->
		<para>
		    A chart can also have a number of optional components
		    such as Legends, Headers/Footers or custom 
		    <classname>KDChart::Area</classname> subclasses that
		    implement user-defined elements. The API for manipulating 
		    these is similar for all of them.
		</para>
		<para>
		    To add an additional header for example, you may proceed 
		    as follow:
		</para>
		<programlisting>
		    HeaderFooter * additionalHeader = new HeaderFooter;
		    additionalHeader->setPosition( NorthWest );
		    chart->addHeaderFooter( additionalHeader  );
		</programlisting>
		<para>
		    We will explain further on how ownership of such 
		    components is handled (next section).
		</para>
		<!--
                Pending Michel: point to those files
		(see src/{KDChartChart.h|KDChartLegend.h|KDChartHeaderFooter.h)
		-->
		<para>
		    Finally and to conclude this overview, all classes in the 
		    KD Chart 2 API are in the "KDChart" namespace, to allow 
		    short and clear class names, while still avoiding name
		    clashes. Unless you prefer to use the "KDChart::" prefix 
		    on all class names in your code, you can add the following
		    line at the top of your implementation files, to make all 
		    names in the "KDChart" namespace available in that file:
		</para>
		<programlisting>
		    using namespace KDChart;
		</programlisting>
		<para>
		    Like Qt, KD Chart provides STL-style forwarding headers, 
		    allowing you to omit the ".h" suffix when including 
		    headers. To bring the bar diagram header into your 
		    implementation file, you could therefore write:
		</para>
		<programlisting>
		    #include &lt;KDChartBarDiagram&gt;
		    or 
		    #include &lt;KDChartBarDiagram.h&gt;
		</programlisting>
		<note>
		    <para>
			File names of header and implementation files all
			have the "KDChart" prefix in the name. The definition 
			of <classname>KDChart::BarDiagram</classname> is 
			thus located in the file 
			<filename>KDChartBarDiagram.h</filename>.
		    </para>	
		</note>    
            </sect2>
        </sect1>
<!-- Pending Michel: No much to say here for now - Shall we remove this section?
        <sect1>
            <title id="apihandling">Ownership and Parameters Handling</title>
            <para>
                Text: Shift the following sections: Handling of value
                parameters (e.g Text Attributes) vs Pointer classes.
            </para>
            <sect2>
                <title id="handlingsample" xreflabel="codexample">Code Example</title>
		<para>
                    Let us make this more concrete by looking at the following
                    lines of code........                  
                </para>
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
-->
        <sect1>
            <title id="apiinterview">KD Chart and Interview </title>
            <para>
		
		KD Chart 2.0 follows the Interview model/view paradigm 
		introduced by Qt 4:
	    </para>	
	    <para>
		Any <classname>KDChart::AbstractDiagram</classname> subclass 
		(since that is derived from 
		<classname>QAbstractItemView</classname>) can display data 
		coming from any <classname>QAbstractItemModel</classname>.
		In order to use your data with KD Chart diagrams, you need 
		to either use one of Qt's builtin models to manage it, or 
		provide the <classname>QAbstractItemModel</classname> 
		interface on top of your already existing data storage by 
		implementing your own model that talks to that underlying 
		storage. 
            </para>
	    <para>
		<classname>KDChart::Widget</classname> is a convenience class 
		that provides a simpler, but less flexible way of displaying 
		data in a chart. It stores the data it displays itself, and 
		thus does not need a <classname>QAbstractItemModel</classname>.
		It should be sufficient for many basic charting needs but it 
		is not meant to handle very large amounts of data or to make 
		use of user-supplied chart types.
	    </para>
	    <para>
		<classname>KDChart::Widget</classname> is provided in order to 
		allow getting started easily without having to master the 
		complexities of the new Interview framework in Qt 4. We would 
		still advise to use KDChart::Chart so that you can make use of
		all the benefits that Interview brings you once you have 
		mastered it.
	    </para>
	    <para>
		To understand the relationship between 
		<classname>KDChart::View</classname>
		and <classname>KDChart::Widget</classname> better, compare for
		example <classname>KDChart::View</classname> and
		<classname>KDChart::Widget</classname> to 
		<classname>QListView</classname> and 
		<classname>QListWidget</classname> in the Qt 4 documentation. 
		You will clearly notice the parallels.
	    </para>	   
             <sect2>
                <title id="interviewsample" xreflabel="codesample">Code Sample</title>
                <para>		  
                    Let us make this more concrete by looking at the following
                    lines of code where we are using  
		    <classname>QStandardItemModel</classname> to store the 
		    data which will be displayed by the diagram in a 
		    <classname>KDChartChart</classname> widget. 
                </para>                
                <programlisting>
                    // set up your model
		    m_model.insertRows( 0, 2, QModelIndex() );
		    m_model.insertColumns(  0,  3,  QModelIndex() );
		    for (int row = 0; row &lt; 3; ++row) {
		       for (int column = 0; column &lt; 3; ++column) {
		          QModelIndex index = 
		          m_model.index(row, column, QModelIndex());
		          m_model.setData(index, QVariant(row+1 * column) );
                       } 
                    }
                </programlisting>                
                <para>
                    In order to assign the model above to your diagram and 
		    display it you would proceed as follow:
                </para>
		<programlisting>
		    KDChart::BarDiagram* diagram = new KDChart::BarDiagram;
		    diagram->setModel(&amp;m_model);
		    m_chart.coordinatePlane()->replaceDiagram(diagram);
                </programlisting>
		<para>
		    Using <classname>KDChartWidget</classname> we would proceed
		    as follow:
		</para>
		<programlisting>
                    KDChartWidget widget;
		    QVector&lt; double &gt; vec0,  vec1;
		    vec0 &lt;&lt; -5 &lt;&lt; -4 &lt;&lt; -3 &lt;&lt; -2 &lt;&lt; -1 &lt;&lt; 0 ...;
		    vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0 ...;      
		    widget.setDataset( 0, vec0, "Linear" );
		    widget.setDataset( 1, vec1, "Quadratic" );
		    widget.show();
                </programlisting> 
		<para>
		    We recommend you to consult 
		    <filename>KDChartChart.h</filename> and 
		    <filename>KDChartWidget.h</filename> to learn more about 
		    those classes and what they can do. Also compile and run 
		    the complete examples that describe very simply the two 
		    ways you may use to display a Chart.
		</para>
	    </sect2>
        </sect1>
        <sect1>
            <title id="apiattribute">Attribute sets</title>
            <para>
                The various components of a chart such as legends or axes have
		attribute sets associated with them that define the way they 
		are laid out and painted. For example, both the chart itself 
		and all areas have a set of 
		<classname>KDChart::BackgroundAttributes</classname>, which 
		govern whether there should be a background pixmap, or a solid
		background color. Other attribute sets include FrameAttributes
		or GridAttributes. The default attributes provide reasonable, 
		unintrusive settings, such as no visible background and no 
		visible frame.
            </para>
	    <para>
		These attribute sets are passed by value, they are intended to
		be used much like Qt's QPen or QBrush. As shown below:
	    </para>
             <sect2>
                <title id="attributesample" xreflabel="codesample">Code Sample</title>
		<programlisting>
		    KDChart::TextAttributes ta;
		    ta.setPen( Qt::red );
		    ta.setFont( QFont( "Helvetica" ) );
		    chart->legend()->setTextAttributes( ta );
		</programlisting>
                <para>
		    All attribute sets can be set per cell, per column or per 
		    model, and only be queried per cell. Access at the cell 
		    level only ensures that the proper fallback hierarchy can 
		    be observed. If there is a value set at cell level, it 
		    will be used, otherwise the dataset (column) level is 
		    checked. If nothing was set at dataset level, the model 
		    wide setting is used, and if there is none either, the 
		    default values will be applied. 
		    All of this happens automatically, so that the code using
		    these values only has to ask the cell for its attributes, 
		    and will get the correct values. This avoids duplicating 
		    the fallback logic all over the library and 
		    the application, and avoids (expensive) error handling.
                </para>
                <para>
                    When using attributes sets, you need to be aware of this 
		    fallback hierarchy, because e.g. per-cell changes will 
		    hide per-column changes.
		    <!-- Pending Michel: Add some code sample here -->
		    (see files /src/KDChart*Attributes.h)
                </para>
                </sect2>
        </sect1>
        <sect1>
            <title id="apimemory">Memory management</title>
            <para>
                As a general rule, everything in a KDChart::Chart is owned by 
		the chart. Manipulation of the built-in components of a chart,
		such as for example a legend, happens through mutable pointers
		provided by the view, but those components can also be 
		replaced. 
            </para>
             <sect2>
                <title id="memorysample" xreflabel="codesample">Code Sample</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.                   
                </para>
		<programlisting>
		    // set the built-in (default) legend visible
		    m_chart->legend()->setPosition( North );

		    // replace the default legend with a custom one 
		    //the chart view will take ownership of the allocated 
		    //memory and free the old legend
		    KDChart::Legend *myLegend = 
		    m_chart->replaceLegend( new Legend );
                </programlisting>
                <para>
		    Similarly, inserting new components into the view chart up
		    their ownership. Note that the same procedure has to be 
		    applied for a diagram too. 		    
                </para>
		<programlisting>
		    // add an additional legend, chart takes ownership
		    chart->addLegend( Legend );
                </programlisting>
		<para>
		    Removing a component does not de-allocate it. If you "take"
		    a component from a chart or diagram, you are responsible 
		    for freeing it as appropriate.
		</para> 
		<para>
		    (see files /src/{KDChartChart.h, KDChartLegend.h})
		</para>
		<para>
		    Notice how this pointer-based access to the components of a
		    chart is different from the value-based usage of the 
		    attribute classes; the latter can be copied around freely, 
		    and are meant to be transient in your code; they will be 
		    copied internally as necessary. The reason for the 
		    difference, of course, is polymorphism.
		</para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Basic steps: Create a Chart or a Widget.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_basicsteps">
        <title id="chtxt_basicsteps">Basic steps: Create a Chart</title>
        <titleabbrev id="chnum_basicsteps">Chapter 3</titleabbrev>
	<para>
	    As specified in the above Chapter, there are two ways to create a chart:
	</para>
	<itemizedlist>
	    <listitem>
		<para>
		    <classname>KDChart::Widget</classname> is providing a limited set of 
		    functions  as can be seen in <filename>KDChartWidget.h</filename>. Its 
		    purpose is a convenient and simple way of getting a chart, for people 
		    who do not want to learn about the new Qt Interview concept or who do 
		    not care about more complicated details like the Coordinate Plane and 
		    other classes provided by KD Chart 2 API.
		</para>
	    </listitem>
	    <listitem>
		<para>
		   <classname>KDChart::Chart</classname> purpose is to allow the user to
		    use the full power of both the new Qt and the new KD Chart.		
		</para>
	    </listitem>
	 </itemizedlist>
	<para>
	    Basically, <classname>KDChart::Widget</classname> has been designed for 
	    starters, while <classname>KDChart::Chart</classname> is destinated for 
	    the experienced user and/or for users who need more features and flexibility.
	    Once again we recommend you to read both interfaces for those classes in order
	    to make yourself an opinion about what you would need while developping your 
	    application.( See <filename>KDChartWidget.h</filename> and 
	    <filename>KDChartChart.h</filename> ).
	</para>
	<sect1>          
	    <title id="basicprerequiste">Prerequisite</title>
            <para>
		As described above (Section KD Chart and Interview) a
		prerequisite for using KD Chart's full API is that the data to
		be charted is provided by you through a class implementing the
		<classname>QAbstractItemModel</classname> interface.
		Before looking at code lines, let us present you a few top 
		level classes of the KD Chart 2 API:
            </para>
	    <para>
		<itemizedlist>
		    <listitem>
			<para>
			    The "chart" is the central widget acting as a 
			    container for all of the charting elements, 
			    including the diagrams themselves, its class is 
			    called <classname>KDChart::Chart</classname>.
			</para>
			<para>
			    A "chart" can hold several coordinate planes
			    (e.g cartesian and polar coordinates are supported
			    at the moment) each of which can hold several 
			    diagrams.
			</para>    
		    </listitem>
		    <listitem>
			<para>
			    The "coordinate plane" (often called the "plane")
			    represents the entity that is responsible for 
			    mapping the values into positions on the widget.
			    The plane is also showing the (sub-)grid lines.
			    There can be several planes per chart.
			</para>	
		    </listitem>
		    <listitem>
			<para>
			    The "diagram" is the actual plot (bars, lines and 
			    other chart types) representing the data.There can 
			    be several diagrams per coordinate plane.
			</para>	
		    </listitem>
		</itemizedlist>
	    </para>	
        </sect1>
        <sect1>
            <title id="basicprocedure">The Procedure</title>
            <para>
		Let us go through the general procedure for creating a chart, 
		without taking care about the details. We will then build 
		complete example and create a small application displaying a 
		chart using <classname>KDChartWidget</classname> and 
		<classname>KDChartChart</classname> respectively.
	    </para>
	    <para>
		First of all we need to include the appropriate headers, and 
		bring in the "KDChart" namespace:
	    </para>
	    <programlisting>
		#include &lt;KDChartChart&gt;
		#include &lt;KDChartLineDiagram&gt;
		using namespace KDChart;
		
		//Add the widget to your layout like for any other QWidget:
		QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		m_chart = new Chart();
		chartLayout->addWidget( m_chart );
	    </programlisting>
	    <para>
		In this example, we will create a single line diagram,
		and use the default Cartesian coordinate plane, which is 
		already contained in an empty Chart.
	    </para>
	    <programlisting>
		// Create a line diagram and associate the data model to it
		m_lines = new LineDiagram();
		m_lines->setModel( &amp;m_model );
		
		// Replace the default diagram of the default coordinate
		// plane with your newly created one.
		// Note that the plane takes ownership of the diagram,
		// so you are not allowed to delete it.
		m_chart->coordinatePlane()->replaceDiagram( m_lines );
	    </programlisting>
	    <para>
		Adding elements such as axes or legends is 
		straightforward as well:
	    </para>
	    <programlisting>
		CartesianAxis *yAxis = new CartesianAxis ( m_lines );
		yAxis->setPosition ( KDChart::CartesianAxis::Left );
		
		// the diagram takes ownership of the Axis
		m_lines->addAxis( yAxis );
		
		legend = new Legend( m_lines, m_chart );
		m_chart->addLegend( legend );
	    </programlisting> 
	    <para>
		You can adjust and fine-tune various aspects of the 
		diagrams, planes, legends, etc...
	    </para>
	    <para>
		Much like Qt itself, KD Chart uses a value-based approach 
		to these attributes. In the case of diagrams, most aspects
		can be adjusted at different levels of granularity.
		The QPen that is used for drawing datasets (lines, bars, 
		etc...) can be set either for one datapoint within a 
		dataset, for a dataset or for the whole diagram. See file 
		<filename>KDChartAbstractDiagram.h</filename>:
	    </para>
	    <programlisting>
		void setPen( const QModelIndex&amp; index, const QPen&amp; pen );
		void setPen( int dataset, const QPen&amp; pen );
		void setPen( const QPen&amp; pen );
	    </programlisting> 
	    <para>
		To use a dark gray color for all lines in your example 
		chart, you would write:
	    </para>
	    <programlisting>
		QPen pen;
		pen.setColor( Qt::darkGray );
		pen.setWidth( 1 );
		m_lines->setPen( pen );
	    </programlisting> 
	    <para>
		Attributes that form logical groupings are combined into
		collection classes, such as 
		<classname>GridAttributes</classname>, 
		<classname>DataValueAttributes</classname>,
		<classname>TextAttributes</classname>, etc....
	    </para>
	    <para>
		This makes it possible to keep sets of such properties 
		around and swap them in one step, based on program state.
		However, you might often want to adjust just one or a few 
		of the default settings, rather than specifying a complete
		new set. Thus in most cases, using the copy constructor of
		the settings class might be appropriate, so to use a 
		special font for drawing a legend, for example, you would 
		just write:    
	    </para>    
	    <programlisting>
		TextAttributes ta( legend->textAttributes() );
		ta.setFont( myfont );
		legend->setTextAttributes( ta );
	    </programlisting>
	    <para>
		We will continue with more examples and more detailed 
		information about all those points in the next sections
		and the next chapters.
		Also we recommend you to consult and run the examples 
		sent together with your KD Chart distribution package.
	    </para>
	</sect1>
	<sect1>
	    <title id="basictwoways">Two ways</title> 
	    <para>
		We will now go through the basic steps for creating a simple 
		chart widget using first <classname>KDChart::Widget</classname>
		and then <classname>KDChart::Chart</classname>, that will give
		us an overview about how to proceed in both cases.
	    </para>
	    <sect2>
                <title id="basicwidget" xreflabel="codexample">Widget Example</title>
		<para>
		    We recommend you to read, compile and run the following example.
		    It is available at the following location of your KD Chart 
		    installation: <filename>examples/Widget/Simple</filename>.
		</para>				
		<programlisting linenumbering="numbered" id="widget_simple">
		    <textobject>
			<textdata fileref="../../examples/Widget/Simple/main.cpp"/>
		    </textobject>
		</programlisting>                
		<para>
		    The result of the the code above will display the very simple 
		    widget presented in the screen-shot below.
		</para>	
		<para>
		    As we can see the code code is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Include the headers and bring the Chart namespace.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Declare your <classname>KDChartWiget</classname>
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Use a <classname>QVector</classname> to store the data to be displayed.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign the stored data to the widget, using one of
			    the available <methodname>setDataset</methodname> 
			    method to do so.
			</para>
		    </listitem>	
		</itemizedlist>
		<figure float="0" id="fig-simplewidget">
		    <title>A Simple Widget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplewidget.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Of course it is possible to add new elements like Title, Headers, Footers,
		    Legends or Axes ...etc to this very simple widget as we will see later on more in 
		    details. Notice also that the default diagram displayed by a 
		    <classname>KDChartWidget</classname> is a 
		    <classname>KDChartLineDiagram</classname>.
		    In the following example we will look at the way to display a Chart widget using
		    <classname>KDChartChart</classname>.
		</para>
	    </sect2>
	    <sect2>	
                <title id="basicchart" xreflabel="codexample">Chart Example</title>
		<para>
		    We recommend you to read, compile and run the following example. It is available
		    at the following location of your KD Chart installation: 
		    <filename>/examples/Charts/simple</filename>	    
		</para>
		<programlisting linenumbering="numbered" id="chart_main">
		    <textobject>
			<textdata fileref="../../examples/Charts/simple/main.cpp"/>
		    </textobject>
		</programlisting>                
		<para>
		    In this example we are making use of a 
		    <classname>QStandardItemModel</classname> to insert and 
		    store the data to be displayed by the diagram. We are also
		    implicitely using a <classname>KDChartBarDiagram</classname>
		    to which we assign the model. See below the resulting chart 
		    widget displayed by this implementation. 
		</para>
		<figure float="0" id="fig-simplechart">
		    <title>A Simple Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    We can of course add more elements to this chart and change its default 
		    attributes as described above in the section intituled 
		    <filename>The Procedure</filename>. 
		</para>		
		<para>
		    We will see more in details how to configure those attributes 
		    (Pen, Color, etc ...)and add the divers elements (Axes, Legend, Headers 
		    etc...) further on.
		</para>
	    </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                In the next chapter we describe the different chart types (diagrams) 
		available and their coordinate planes. For each chart type we will study 
		the attributes available for this special type and give a few example to 
		make it clear.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_planesanddiagrams">
        <title id="chtxt_planesanddiagrams">Planes and Diagrams</title>
        <titleabbrev id="chnum_planesanddiagrams">Chapter 4</titleabbrev>
	<para>
	    KD Chart supports at the moment two types of plane in order to display 
	    the different types of diagrams it supports.
        </para>
	 <itemizedlist>
            <listitem>
                <para>
                    A Cartesian coordinate plane, formed by a horizontal axis and a vertical 
		    axis, often labeled the x-axis and y-axis. 
                </para>
            </listitem>
            <listitem>
                <para>
                    A Polar coordinate plane which make use of the radius or the polar angle, 
		    that define the position of a point in a plane.
                </para>
		<para>
		    This chapter tells you how to change the chart type from the default to any
		    one of the other types. All of the chart types provided by &kdchart; are 
		    presented here with the help some sample code and/or small programs and their 
		    screen shots.
		</para>
		<para>
		    It will also give us an idea about which chart type might be appropriate for a 
		    specific purpose and provides information on the features that are available for 
		    each type of chart.
		</para>
            </listitem>
        </itemizedlist>
        <sect1>
            <title id="cartesianplane">Cartesian coordinate plane</title>
            <para>
                KD Chart uses the Cartesian coordinate system, and in particular its 
		<classname>KDChart::CartesianCoordinatePlane</classname> class for displaying 
		chart types like ( e.g: Lines, Bars, Points, etc...).
            </para>
	    <para>
		In this section we will describe and present each chart type which uses the default 
		Cartesian coordinate plane.
	    </para>
	    <para>
		In general to implement a particular type of chart, just create an object of this  
		type by calling <classname>KDChart[type]Diagram</classname>, or if your are using 
		<classname>KDChartWidget</classname> you will need to call its 
		<methodname>setType()</methodname> and specify the appropriate chart type.
 		(e.g Widget::Bar, Widget::Line etc...)		
	    </para>
	    <sect2>
		<title id="bars">Bar Charts</title>
		<tip>
		    <para>
			Bar charts are the most common type of charts and can be used for 
			visualizing almost any kind of data. Like the Line Charts, the bar 
			charts can be the ideal choice to compare multiple series of data.
		    </para>
		    <para>
			A good example for using a bar chart would be a comparison of the sales 
			figures in different departments, perhaps accompanied by a 
			High/Low Chart showing each day's key 
			figures.
		    </para>
		</tip>		
		<para>
		    Your Bar Chart can be configured with the following (sub-)types as described in 
		    details in the following sections: 
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Normal
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Stacked
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Percent
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="barnormal">Normal Bar Charts</title>
		<tip>
		    <para>
			In a normal bar chart, each individual value is displayed as a bar by 
			itself. This flexibility allows to compare both the values in one series 
			and values of different series.
                    </para>
		</tip>
		<figure float="0" id="fig-barnormal">
		    <title>A Normal Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplebar.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart;'s default type is the normal bar chart so no method needs to be 
		    called to get one, however after having used your 
		    <classname>KDChartBarDiagram</classname>. To display another sub-type 
		    you can return to the normal one by calling 
		    <methodname>setType( Normal )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="barstacked">Stacked Bar Charts</title>
		<tip>
		    <para>
			Stacked bar charts focus on comparing the sums of the individual values in 
			each data series, but also show how much each individual value contributes 
			to its sum.
                    </para>
		</tip>
		<figure float="0" id="fig-barstacked">
		    <title>A Stacked Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barstacked.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Stacked mode for bar charts is activated by calling the 
		    <classname>KDChartBarDiagram</classname> function
		    <methodname>setType( Stacked  )</methodname>.
		</para>
	    </sect2>
	    <sect2>
		<title id="barpercent">Percent Bar Charts</title>    
		<tip>
		    <para>
			Unlike stacked bar charts, percent bar charts are not suitable for 
			comparing the sums of the data series, but rather focus on the respective 
			contributions of their individual values.
                    </para>
		</tip>
		<figure float="0" id="fig-barpercent">
		    <title>A Percent Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barpercent.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Percent: Percentage mode for bar charts is activated by calling
		    the <classname>KDChartBarDiagram</classname> function
		    <methodname>setType( Percent )</methodname>.
		</para>		
		<note>
		    <para>
			Three-dimensional look of the bars is no special feature you can enable it
			for all types (<literal>Normal</literal>, <literal>Stacked</literal> or
			<literal>Percent</literal>) by setting its ThreeD attributes, we will 
			describe that in the "Bars Attributes" section further on.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="barsample" xreflabel="codesample">Code Sample</title>	
		<para>
		    For now let us make the above description  more concrete by looking at the 
		    following code sample based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above. In this example we show how to configure your 
		    bar diagram and change its attributes when working with a 
		    <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
		    #include &lt;QApplication&gt;
		    #include &lt;KDChartWidget&gt;
                    #include &lt;KDChartBarDiagram&gt;
                    #include &lt;QPen&gt;

	            using namespace KDChart;			    
		</programlisting>                
		<para>
		    We need to include <classname>KDChartBarDiagram</classname> in order to be able
		    to configure some of its attributes as we will see further on. 
		</para>
		<programlisting>
		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );                    
		    Widget widget;
		    // our Widget can be configured 
		    // as any Qt Widget 
		    widget.resize( 600, 600 );		    
                    // store the data and assign it
		    QVector&lt; double &gt; vec0,  vec1;
		    vec0 &lt;&lt; 5 &lt;&lt; 4 &lt;&lt; 3 &lt;&lt; 2 &lt;&lt; 1 &lt;&lt; 0
		    &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5;
		    vec1 &lt;&lt; 25 &lt;&lt; 16 &lt;&lt; 9 &lt;&lt; 4 &lt;&lt; 1 &lt;&lt; 0
		    &lt;&lt; 1 &lt;&lt; 4 &lt;&lt; 9 &lt;&lt; 16 &lt;&lt; 25;		    
		    widget.setDataset( 0, vec0, "vec0" );
		    widget.setDataset( 1, vec1, "vec1" );
		</programlisting>
		<para>
		    We want to change the default line chart type to a bar chart type. In this
		    case we also want to display it in stacked mode. 
		    <classname>KDChartWidget</classname> with its <methodname>setType</methodname>
		    and <methodname>setSubType</methodname> methods allow us to achieve that 
		    the easy way.		    
		</para>
		<programlisting>
		    widget.setType( Widget::Bar , Widget::Stacked );
		</programlisting>
		<para>
		    The default type being Normal type for the widget, we need to implicitely pass 
		    the second parameter when calling <methodname>KDChartWidget::setType()</methodname>
		    We can also change the sub-type of our bar chart further on by calling for example 
		    <methodname>setSubType( Widget::Percent )</methodname>.		    
		</para>
		<programlisting>
		    //Configure a pen and draw a line
		    //surrounding the bars
		    QPen pen;
		    pen.setWidth( 2 );
		    pen.setColor(  Qt::darkGray );
		    // call your diagram and set the new pen
		    widget.barDiagram()->setPen(  pen );
		</programlisting>
		<para>
		    In the above code our intention is to draw a gray line around the bars to make it
		    nicer. That is what we call configuring the attributes in a diagram.
		    To do so we configure a QPen and then assign it to our diagram. 
		    <methodname>KDChartWidget::barDiagram()</methodname> allow us to get a pointer to 
		    our widget diagram. As you can see it is very simple to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method.
		</para>
		<programlisting>
		    //Set up your ThreeDAttributes
		    //display in ThreeD mode
		    ThreeDBarAttributes td;
		    td.setDepth(  15 );
		    td.setEnabled(  true );
		    widget.barDiagram()->setThreeDBarAttributes( td );
		</programlisting>
		<para>
		    We want our bar chart to be displayed in ThreeD mode and need to configure some 
		    ThreeDBarAttributes and assing them to our diagram. Here we are configuring the 
		    depth of the ThreeD bars and enabling ThreeD mode.
		    Depth is an attribute specific to Bar charts and its setter and getter are implemented 
		    into the <classname>KDChartThreeDBarAttributes</classname>, when the 
		    <methodname>KDChartAbstractThreeDAttributes::setEnabled()</methodname> is a generic 
		    attributes available to all chart types. Both of those attribute are set very simply 
		    but are implemented at different level for a better code structure. 
		</para>
		<programlisting>
		    widget.show();

		    return app.exec();
		    }
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-widgetbar">
		    <title>A Simple Bar ChartWidget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/widgetparameters.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Widget/Parameters</filename>
		</para>
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartBarDiagram</classname> making use
			of a <classname>KDChartChart</classname> is done the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your bar diagram and assign it to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="barsattributes">Bars Attributes</title>
		<para>
		    By "Bars attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Bar Chart type.
		    The "getters" and "setters" for those attributes can be consulted by looking at
		    <filename>KDChartBarAttributes.h</filename> to get an idea about what can be 
		    configured there. 
		</para>
		<note>
		    <para>
			KD Chart 2.0 API separates the attributes specifics to a chart type itself and
			the generic attributes which are common to all chart types as for example the 
			setters and getters for a brush or a pen and that are accessible from the
			<classname>KDChartAbstractDiagram</classname> interface.  		    
		    </para>
		</note>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartBarDiagram::setBarAttributes()</methodname> or 
		    for example (to change the default Pen) directly by calling the 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname> method.
		</para>
		<para>
		    The procedure is straight forward on both cases. Let us discuss the types 
		    specifics attributes first:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::BarAttributes</classname> object by 
			    calling <methodname>KDChartBarDiagram::barAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::BarDiagram</classname>. All the attributes can be
			    configured to be applied for the whole diagram, for a column, or at a 
			    specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Bar chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    BarWidth: Specifies the width of the bars
			</para>
		    </listitem>
		    <listitem>
			<para>
			    GroupGapFactor: Configure the gap between groups of bars. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    BarGapFactor: Configure the gap between Bars within a group
			</para>
		    </listitem>
		    <listitem>
			<para>
			    DrawSolidExcessArrow: Specify whether the arrows showing excess values
			    should be drawn solidly or split.
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="barattributessample" xreflabel="codesample">Bar Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located into the <filename>examples/Bars/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files we need and bring KD Chart namespace.
		</para>
		<programlisting>
		    #include &lt;QtGui&gt;
		    #include &lt;KDChartChart&gt;
                    #include &lt;KDChartBarDiagram&gt;
                    #include &lt;KDChartDataValueAttributes&gt;

                    using namespace KDChart;		    
                </programlisting>
		<para>
		    We have included <classname>KDChartDataValueAttributes</classname> to be able 
		    to display our data values. Those attributes are of course used by all types of
		    charts and are not specifical to the Bar diagrams.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram
		</para>
		<programlisting>
		    class ChartWidget : public QWidget {
		    Q_OBJECT
		    public:
		    explicit ChartWidget(QWidget* parent=0)
		    : QWidget(parent)
		    {
		    
		    m_model.insertRows( 0, 2, QModelIndex() );
		    m_model.insertColumns(  0,  3,  QModelIndex() );
		    for (int row = 0; row &lt; 3; ++row) {
		      for (int column = 0; column &lt; 3; ++column) {
		        QModelIndex index = m_model.index(row, column, QModelIndex());
		        m_model.setData(index, QVariant(row+1 * column) );
		      }
		    }

		    BarDiagram* diagram = new KDChart::BarDiagram;
		    diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having store our data into the model, we create a diagram, in this 
		    case, we want to display a <classname>KDChartBarDiagram</classname> and 
		    assing the model to our diagram. The procedure is of course similar for 
		    all types of diagrams. 
		</para>
		<para>
		    We are no ready to configure our bar specifics attributes using a 
		    <classname>KDChartBarAttributes</classname> to do so. 
		</para>
		<programlisting>
		    BarAttributes ba;
		    //set the bar width and
		    //implicitely enable it
		    ba.setFixedBarWidth( 500 );
		    ba.setUseFixedBarWidth( true );
		    //configure gab between values
		    //and blocks
		    ba.setGroupGapFactor( 0.50 );
		    ba.setBarGapFactor( 0.125 );
		    
		    //assign to the diagram
		    diagram->setBarAttributes(  ba );
                </programlisting>
		<para>
		    We want to configure our bars width so that they get displayed a bit larger.
		    The Width of a bar is calculated automatically depending on the gaps between 
		    each bar and the gaps between groups of bars as well as the space available 
		    horizontally in the plane. So those values interact with each other so that 
		    your bars does not exceed the plane surface horizontally.
		    Here we are increasing the value of my bars width and at the same time set 
		    some lower values for the gaps. Which will give us larger bars	    
		</para>
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			<classname>BarAttributes</classname> object to the diagram.
			This can be done for the whole diagram, at a specific index 
			or for a column. See <filename>KDChartBarDiagram.h</filename> and
			look at the methods available there to find out those setters and
			getters.
		    </para>   
		</note>
		<para>
		    We will now display the data values related to each bar making use of
		    KD Chart 2.0 API <classname>KDChartDataValueAttributes</classname>. Those
		    attributes are not specifics to the Bar Chart types but can be used by any 
		    type of charts. The procedure is very similar.
		</para>
		<programlisting>
		 // display the values
		    DataValueAttributes dva;
		    TextAttributes ta = dva.textAttributes();
		    //rotate if you wish
		    //ta.setRotation( 0 );
		    ta.setFont( QFont( "Comic", 9 ) );
		    ta .setPen( QPen( QColor( Qt::darkGreen ) ) );
		    ta.setVisible( true );
		    dva.setTextAttributes( ta );
		    dva.setVisible( true );
		    diagram->setDataValueAttributes( dva );
		</programlisting>
		<para>
		    We could have displayed the data values without caring about settings its 
		    <classname>KDChartTextAttributes</classname>, but we wanted to do so in 
		    order to demonstrate this feature too. Notice that you have to implicitely
		    enable your attributes ( DataValue and Text) by calling their 
		    <methodname>setVisible()</methodname> methods. After it is configured as we
		    want it is just to assign to the diagram as for all other attributes.  
		</para>
		<para>
		    Finally I want to paint a ligne around one of the datasets bars. In order to
		    keep the attention of the public on this specific set of data. To do so I need to 
		    change the default pen used by my bars for this data set exclusively. Of course we
		    could  also have changed the pen for all datasets or for a specifical index or value.
		</para>
		<programlisting>
		     //draw a surrounding line around bars
		    QPen linePen;
		    linePen.setColor( Qt::magenta );
		    linePen.setWidth( 4 );
		    linePen.setStyle( Qt::DotLine );
		    //draw only around a dataset
		    //to draw around all the bars
		    // call setPen( myPen );
		    diagram->setPen( 1,  linePen );
		</programlisting>
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level in 
			our <classname>KDChartAbstractDiagram</classname> class for a cleaner code 
			structure. Those methods are of course used by all types of diagram and their 
			configuration is very simple and straight forward as you can see in the above 
			sample code. Create a Pen, configure it, call one of the setters methods 
			available (See <filename>KDChartAbstractDiagram.h</filename> about those 
			methods).		
		    </para>
		</note>
		<para>
		    Our attribute having been configured and assigned we just need to assign the Bar 
		    diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
		    m_chart.coordinatePlane()->replaceDiagram(diagram);

		    QVBoxLayout* l = new QVBoxLayout(this);
		    l->addWidget(&amp;m_chart);
		    setLayout(l);
		    }

		    private:
		    Chart m_chart;
		    QStandardItemModel m_model;
		    };

		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );

		    ChartWidget w;
		    w.show();

		    return app.exec();
		    }

		    #include "main.moc"
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes relative 
		    to the chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Bars/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-barparameters">
		    <title>Bar with Configured Attributes</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/barparameters.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    The subtype of a bar chart (Normal, Stacked or Percent) is not set via its 
		    attribute class, but directly by using the diagram 
		    <methodname>KDChartBarDiagram::setType</methodname> method.  
		</para>
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>		    
	    <sect2>
		<title id="barstips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.
		</para>	
	    </sect2>
	    <sect2>
		<title id="bartipssample" xreflabel="codexample">A complete Bar Example</title>
		<para>		    
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the bar chart subtype (Normal, percent, Stacked).
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Select a column and mark it by changing the generic pen attributes.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display in ThreeD mode and change the Bars depth dynamically. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the Bars width dynamically. 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    To do so we will need to use several types of attributes. Generics one 
		    available to all chart types (e.g 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname>,
		    <classname>KDCHartDataValueAttributes</classname> and 
		    <classname>KDChartTextAttributes</classname> as well as typical bar attributes 
		    only applyable to the Bar types as 
		    <methodname>KDChartBarAttributes::setWidth()</methodname> or 
		    <classname>KDChartThreeDBarAttributes</classname>
		</para>
		<para>
		    We are making use of a <classname>KDChartChart</classname> class and also of 
		    an home made <classname>TableModel</classname> for the convenience and derived 
		    from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Bar chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Bars/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullbar_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Bars/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The prupose is to let the user configure its bar chart attributes 
		    manually . As you can see we are using a KDChartChart object ( m_chart ),
		    a KDChartBarDiagram object ( m_bars ), and our home made TableModel ( m_model ).		    
		</para>
		<para>
		    The implementation is also straight forward as we will see below:
		</para>
		<programlisting linenumbering="numbered" id="fullbar_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Bars/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our bar diagram. We 
		    also want to configure a Pen and surround the displayed bars by a darkGray line
		    to make it somewhat nicer. Finally we assign the diagram to our chart.
		</para>
		<programlisting>
		    //draw a surrounding line around bars
		   QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		    m_chart = new Chart();
		    chartLayout->addWidget( m_chart );
		    
		    m_model.loadFromCSV( ":/data" );
		    
		    // Set up the diagram
		    m_bars = new BarDiagram();
		    m_bars->setModel( &amp;m_model );

		    QPen pen;
		    pen.setColor( Qt::darkGray );
		    pen.setWidth( 1 );
		    m_bars->setPen( pen );

		    m_chart->coordinatePlane()->replaceDiagram( m_bars );
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
		 ....   
		 if ( text == "Normal" )
		    m_bars->setType( BarDiagram::Normal );
		    else if ( text == "Stacked" )
		    m_bars->setType( BarDiagram::Stacked );
		 ....
		    m_chart->update();
		</programlisting>
		<para>
		    We set the DataValueAttributes on a per-column basis here, because we want the 
		    texts to be printed in different colours - according to their respective 
		    dataset's colour. The user will be able to display or hide the values. 
		</para>
		<programlisting>
		    ...
		    const QFont font(QFont( "Comic", 10 ));
		    const int colCount = m_bars->model()->columnCount();
		    for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
			QBrush brush( m_bars->brush( iColumn ) );
			DataValueAttributes a( m_bars->dataValueAttributes( iColumn ) );
			TextAttributes ta( a.textAttributes() );
			ta.setRotation( 0 );
			ta.setFont( font );
			ta .setPen( QPen( brush.color() ) );
			if ( checked )
			ta.setVisible( true );
			else
			ta.setVisible( false );
			
			a.setTextAttributes( ta );
			a.setVisible( true );
			m_bars->setDataValueAttributes( iColumn, a);
		    }

		    m_chart->update();
		    ....		
		</programlisting>
		<para>
		    As you can see in the above code we are changing the default values for 
		    <classname>DataValuesAttributes</classname> <classname>TextAttributes</classname>.
		    Also we allow the usert to display or not the texts dynamically. see 
		    <methodname>KDChartTextAttributes::setVisible()</methodname>.
		</para>
		<para>
		    In order to be able to display our diagram in threeD mode we need to bring 
		    <classname>KDChartThreeDBarAttributes</classname>, and configure it. Here we are 
		    enabling or disabling and change its Depth parameter according to the user 
		    interaction.
		</para>
		<programlisting>
		    ...
		    ThreeDBarAttributes td( m_bars->threeDBarAttributes() );
		    double defaultDepth = td.depth();
		    if ( checked ) {
		    td.setEnabled( true );
		      if ( threeDDepthCB->isChecked() )
		        td.setDepth( depthSB->value() );
		      else
		        td.setDepth( defaultDepth );
		    } else {
		      td.setEnabled( false );
		    }
		    m_bars->setThreeDBarAttributes( td );
		    m_chart->update();
		    ...
		</programlisting>
		<para>
		    ThreeDBarAttributes are as simple to use as all other Attributes types. 
		    Our next lines of code will make use of the generic 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname> available to
		    all diagram types, to allow the user to mark a column or reset it to 
		    the original Pen interactively. 
		</para>
		<programlisting>
		    ...
		    const int column = markColumnSB->value();
		    QPen pen( m_bars->pen( column ) );
		    if ( checked ) {
		    pen.setColor( Qt::yellow );
		    pen.setStyle( Qt::DashLine );
		    pen.setWidth( 3 );
		    m_bars->setPen( column, pen );
		    }  else {
		    pen.setColor( Qt::darkGray );
		    pen.setStyle( Qt::SolidLine );
		    pen.setWidth( 1 );
		    m_bars->setPen( column, pen );
		    }
		    m_chart->update();
		    ...
		</programlisting>
		<note>
		    <para>
			It is important to know that have three levels of precedence when setting the 
		    attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    Finally we configure a typical <classname>KDChartBarAttributes</classname>, the Bar 
		    Width, for the user to be able to change the width of the bars dynamically increasing
		    or decreasing its value via the Gui.
		</para>
		<programlisting>
		    if (  widthCB->isChecked() ) {
		      BarAttributes ba( m_bars->barAttributes() );
		      ba.setFixedBarWidth( value );
		      ba.setUseFixedBarWidth( true );
		      m_bars->setBarAttributes( ba  );
		    }
		    m_chart->update();
		</programlisting>
		<para>
		    Here we are making use of the 
		    <methodname>KDChartBarAttributes::setUseFixedBarWidth()</methodname> method to 
		    enable or disable the effect. The Bar Width value being passed by the value of 
		    a Spin Box.		    
		</para>
		<para>
		   See how this widget having some attributes enabled is displayed in the following 
		    screen-shot.
		</para>
		<figure float="0" id="fig-fullbar">
		    <title>A Full featured Bar Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullbarchart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Bars/Advanced</filename> directory into your KD Chart installation.
		    We recommend you to run it.
		</para>
	    </sect2>		    	    
            <sect2>
		<title id="lines">Line Charts</title>
		<tip>
		<para>
		    Line charts usually show numerical values and their development in time.
                    Like the Bar Charts they can be used to compare multiple series of data.
		</para>
		<para>
		    An example might be the development of stock values over a longer period of 
		    time or the water level rise on several gauges.	
		</para>
		</tip>
		<para>
		    As for Bar types, &kdchart; can generate line charts of different kind of line 
		    charts. <classname>KDChartLineDiagram</classname> supports the following 
		    subtypes explained below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Normal Line Chart
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Stacked Line Chart 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Percent Line chart
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>	   
	     <sect2>
		<title id="linenormal">Normal Line Charts</title>
		<tip>
		    <para>
			Normal line charts are the most common type of line charts and are used 
			when the datasets are compared to each other individually. For example, if 
			you want to visualize the development of sales figures over time for each 
			department separately, you might have one line per department.
                    </para>
		</tip>
		<figure float="0" id="fig-linenormal">
		    <title>A Normal Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simpleline.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart; draws normal line charts by default when in line chart mode so no 
		    method needs to be called to get one, however after having used your 
                   <classname>KDChartLineDiagram</classname> to display another line chart subtype 
		    you can reset it by calling <methodname>setType( Normal )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="linestacked">Stacked Line Charts</title>
		<tip>
		    <para>
			Stacked line charts allow you to compare the development of a series of 
			values summarized over all datasets. You could use this if you are only 
			interested in the development of total sales figures in your company, but 
			have the data split up by department.
                    </para>
		</tip>
		<figure float="0" id="fig-linestacked">
		    <title>A Stacked Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/linestacked.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		   Stacked mode for line charts is activated by calling the 
		    <classname>KDChartLineDiagram</classname> method 
		    <methodname>setType( Stacked )</methodname>.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="linepercent">Percent Line Charts</title>    
		<tip>
		    <para>
			Percent line charts show how much each value contributes to the total sum, 
			similar to percent bar charts.
                    </para>
		</tip>
		<figure float="0" id="fig-linepercent">
		    <title>A Percent Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/linepercent.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Percent: Percentage mode for line charts is activated by calling
		    the <classname>KDChartLineDiagram</classname> function
		    <methodname>setType( Percent )</methodname>.
		</para>
		<note>
		    <para>
			Three-dimensional look of the lines is no special feature you can enable it
			for all types (<literal>Normal</literal>, <literal>Stacked</literal> or
			<literal>Percent</literal>) by setting its ThreeD attributes class (see 
			<filename>KDChartThreeDLineAttributes.h</filename> to consult its interface).
			We will describe it more in details  in the "Line Attributes" section further 
			on.
		    </para>
		</note>			
	    </sect2>	    
	    <sect2>
		<title id="linesample" xreflabel="codesample">Code Sample</title>
		<para>
		    For now let us make the above description  more concrete by looking at the 
		    following code sample based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example we 
		    demonstrate how to configure your  line diagram and change its attributes when 
		    working with a <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
		    #include &lt;QApplication&gt;
		    #include &lt;KDChartWidget&gt;
                    #include &lt;KDChartLineDiagram&gt;
                    #include &lt;QPen&gt;

	            using namespace KDChart;			    
		</programlisting>                
		<para>
		    We need to include <classname>KDChartLineDiagram</classname> in order to be able
		    to configure some of its attributes as we will see further on. 
		</para>
		<programlisting>
		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );                    
		    Widget widget;
		    // our Widget can be configured 
		    // as any Qt Widget 
		    widget.resize( 600, 600 );		    
                    // store the data and assign it
		    QVector&lt; double &gt; vec0,  vec1;
		    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
		    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
		    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
		    widget.setDataset( 0, vec0, "vec0" );
		    widget.setDataset( 1, vec1, "vec1" );
		    widget.setDataset( 2, vec2, "vec2" );
		    widget.setSubType(  Widget::Percent );
		</programlisting>
		<para>
		    We dont need to change the default chart type as Line Charts is the default . 
		    In this case we also want to display it in percent mode. 
		    <classname>KDChartWidget</classname> with its <methodname>setSubType</methodname> 
		    method allow us to achieve that the easy way.		    
		</para>
		<programlisting>
		    widget.setSubType( Widget::Percent );
		</programlisting>
		<para>
		    The default sub-type being Normal for all types of charts we need to call 
		    implicitely <methodname>KDChartWidget::setSubType()</methodname> in this case.
		    We can also change the sub-type of our line chart further on by calling for example 
		    <methodname>setSubType( Widget::Stacked )</methodname> or reset its default value by
		    calling <methodname>setSubType( Widget::Normal )</methodname>.		    
		</para>
		<programlisting>
		   //Configure a pen and draw 
		    //a dashed line for column 1
		    QPen pen;
		    pen.setWidth( 3 );
		    pen.setStyle( Qt::DashDotLine );
		    pen.setColor(  Qt::green );
		    // call your diagram and set the new pen
		    widget.lineDiagram()->setPen(  1 , pen );
		</programlisting>
		<para>
		     In the above code our intention is to draw a new style of line for this 
		    specific dataset in order to keep the attention of the public on it.
		    That is what we call configuring an attribute. In this case the pen attribute. 
		    To do so we configure a QPen and then assign it to our diagram. 
		    <methodname>KDChartWidget::lineDiagram()</methodname> allow us to get a pointer to 
		    our widget diagram. As you can see it is very simple to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method.
		</para>
		<programlisting>
		    //Display in Area mode
		    LineAttributes ld;
		    ld.setDisplayArea( true );
		    //configure transparency 
		    //it is nicer and let us 
		    //all the area
		    ld.setTransparency( 25 );
		    widget.lineDiagram()->setLineAttributes( ld );
		</programlisting>
		<para>
		    The code above makes use of typical <classname>KDChartLineAttributes</classname> and
		    let us diplay the areas as well as set up the color transparency which is very 
		    helpfull when displaying a normal chart type where the areas can hide each other. 
		    Finally we conclude our small example:
		</para>
		<programlisting>
		    widget.show();
		    
		    return app.exec();
		    }
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-simplelinewidget">
		    <title>A Simple Line ChartWidget</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplelinewidget.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Lines/SimpleLineWidget</filename>
		</para>
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartLineDiagram</classname> making use
			of a <classname>KDChartChart</classname> is done the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your line diagram and assign the diagram to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>
		</sect2>
	        <sect2>	
		<title id="linesattributes">Lines Attributes</title>
		<para>
		    There are only a few attributes specific to a line chart as it is using a Pen 
		    to draw the lines. Pen and Brush are generic attributes common to all types of 
		    diagrams and are handled by <classname>KDChartAbstractDiagram</classname> from 
		    which <classname>KDChartLineDiagram</classname> is derived indirectly.
		</para>
		<para>
		    However to make it simple for the user we have added some convenient functions 
		    to the <classname>KDChartLineAttributes</classname> in order to be able to 
		    display Areas and set transparency for all subtypes of a line chart. We will 
		    go through those methods further on in our Area charts section in this Chapter. 
		</para>
		<para>
		    <classname>KDChartLineDiagram</classname> combined with its attributes and 
		    methods or combined together with 
		    <classname>KDChartMarkerAttributes</classname> let us display the line chart 
		    subtypes as described above as well as Area Charts and Point charts the easy 
		    way. We will of course present all those alternatives with some sample code 
		    and ready to use examples in the next sections.
		</para>
		<para>
		    The use of LineAttributes is as simple as for the other chart types:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::LineAttributes</classname> object by 
			    calling <methodname>KDChartLineDiagram::lineAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::LineDiagram</classname>. All the attributes can 
			    be configured to be applied for the whole diagram, for a column, or at 
			    a specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Line chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			  MissingValuesPolicy: Specifies how missing values will be shown in a
			  line diagram. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			  Display area: paint the area for a dataset. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			  Area transparency: set the transparency for the displayed area color. 
			</para>
		    </listitem>
		</itemizedlist>
		<note>
		    <para>
			All other attributes as ThreeDLineAttributes (specific to line charts), 
			or MarkerAttributes, DataValueAttributes and TextAttributes ..etc..
			available to all types of charts are of course also available to the 
			line charts types and sub-types.
		    </para>
		</note>
	    </sect2>	
	    <sect2>
		<title id="lineattributessample" xreflabel="codesample">Line Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located into the <filename>examples/Lines/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files and bring KD Chart namespace.
		</para>
		<programlisting>
		    #include &lt;QtGui&gt;
		    #include &lt;KDChartChart&gt;
                    #include &lt;KDChartLineDiagram&gt;
                    #include &lt;KDChartDataValueAttributes&gt;

                    using namespace KDChart;		    
                </programlisting>
		<para>
		    We have included <classname>KDChartDataValueAttributes</classname> to be able 
		    to display our data values. Those attributes are of course used by all types of
		    charts and are not specifical to the Line diagram.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram. 
		</para>
		<programlisting>
		    class ChartWidget : public QWidget {
		    Q_OBJECT
		    public:
		    explicit ChartWidget(QWidget* parent=0)
		    : QWidget(parent)
		    {
		    m_model.insertRows( 0,5, QModelIndex() );
		    m_model.insertColumns( 0,5, QModelIndex() );

		    for( int i = 0; i &lt; 5; ++i ) {
		      for( int j = 0; j &lt; 5; ++j ) {
		        m_model.setData( m_model.index( i,j,QModelIndex() ), (double)i*j );
		      } 
		    }		    

		    LineDiagram* diagram = new LineDiagram;
		    diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having stored our data into the model, we create a diagram. In this 
		    case, we want to display a <classname>KDChartLineDiagram</classname>. 
		    As always we need to assign the model to our diagram. This procedure is of 
		    course similar for all types of diagrams. 
		</para>
		<para>
		    We are now ready to configure our attributes. We want to display the data 
		    values and configure the text and font for those.
		</para>
		<programlisting>
		    // Display values
		    // 1 - Call the relevant attributes
		    DataValueAttributes dva( diagram->dataValueAttributes() );
		    // 2 - We want to configure the font and colors
		    //     for the data values text.
		    TextAttributes ta( dva.textAttributes() );
		    //rotate if you wish
		    //ta.setRotation( 0 );
		    // 3 - Set up your text attributes
		    ta.setFont( QFont( "Comic", 6 ) );
		    ta .setPen( QPen( QColor( Qt::darkGreen ) ) );
		    ta.setVisible( true );
		    // 4 - Assign the text attributes to your
		    //     DataValuesAttributes
		    dva.setTextAttributes( ta );
		    dva.setVisible( true );
		    // 5 - Assign to the diagram
		    diagram->setDataValueAttributes( dva );
                </programlisting>
		<para>
		    As for all attributes we call them by using the relevant method available
		    from our diagram interface, here 
		    <methodname>diagram->dataValueAttributes()</methodname>. The second step 
		    is to set it up with our own values and finally we assign it to our diagram.
		</para>
		<para>
		    We could have displayed the data values without caring about settings its 
		    <classname>KDChartTextAttributes</classname>, but we wanted to do so in 
		    order to demonstrate this feature too. Notice that you have to implicitely
		    enable your attributes ( DataValue and Text) by calling their 
		    <methodname>setVisible()</methodname> methods before we assign it to the 
		    diagram.  
		</para>
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			attributes to the diagram. This can be done for the whole diagram, at a 
			specific index or for a column. Look at the attributes interface  and look 
			at the methods available there to find out those setters and getters.
		    </para>   
		</note>
		<para>
		    We want to configure the Pen in order to draw a section of a line (dataset)
		    differently. e.g. We want to focus the attention of the reader on this 
		    particular section.
		</para>
		<programlisting>
		    // Draw a the section of a line differently.
		    // 1 - Retrieve the pen for the dataset and change
		    //    its style.
		    //    This allow us to keep the line original color.
		    QPen linePen(  diagram->pen( 1 ) );
		    linePen.setWidth( 3 );
		    linePen.setStyle( Qt::DashLine );
		    // 2 - Change the Pen for a section within a line 
		    while assigning it to the diagram		    
		    diagram->setPen( m_model.index( 1, 1, QModelIndex() ), linePen );		   
		</programlisting>	
		<para>
		    Of course we could  also have changed the pen for a single or all datasets as
		    well. See how we call the pen for this very dataset before changing its style
 		    and width. This is done to keep its original color for consistancy. Alos
		</para>		
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level 
			in our <classname>KDChartAbstractDiagram</classname> class for a cleaner 
			code structure. Those methods are of course used by all types of diagram 
			and their configuration is very simple and straight forward as you can see 
			in the above sample code. Create or get a Pen , configure it, call one of 
			the setters methods available (See 
			<filename>KDChartAbstractDiagram.h</filename> about those methods).
		    </para>
		</note>
		<para>
		    Our attribute having been configured and assigned we just need to assign our
		    line diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
		    m_chart.coordinatePlane()->replaceDiagram(diagram);

		    QVBoxLayout* l = new QVBoxLayout(this);
		    l->addWidget(&amp;m_chart);
		    setLayout(l);
		    }

		    private:
		    Chart m_chart;
		    QStandardItemModel m_model;
		    };

		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );

		    ChartWidget w;
		    w.show();

		    return app.exec();
		    }

		    #include "main.moc"
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes for 
		    all chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Lines/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-samplelinechart">
                <title>Line With Configured Attributes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/samplelinechart.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    The subtype of a line chart (Normal, Stacked or Percent) is not set via its 
		    attribute class, but directly by using the diagram 
		    <methodname>KDChartLineDiagram::setType</methodname> method.  
		</para>
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>	
	    <sect2>
		<title id="linestips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget. 
		</para>	
	    </sect2>
	    <sect2>
		<title id="linetipssample" xreflabel="codexample">A complete Line Example</title>
		<para>		 
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Change the line chart subtype (Normal, percent, Stacked).
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Display Areas for one or several for one or several dataset(s). 
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Run a small animation highlighting the areas one after the other.
			</para>
		    </listitem>		    
		</itemizedlist>
		<para>
		    To do so we will need to use several types of attributes and methods, as 
		    <methodname>KDChartAbstractDiagram::setPen()</methodname>,
		    <classname>KDCHartDataValueAttributes</classname> and 
		    <classname>KDChartTextAttributes</classname>.
		</para>
		<para>
		    We are making use of a <classname>KDChartChart</classname> class and also of 
		    an home made <classname>TableModel</classname> for the convenience and derived 
		    from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullline_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually . As you can see we are using a KDChartChart object ( m_chart ),
		    a KDChartLineDiagram object ( m_lines ), and our home made TableModel ( m_model ).
		</para>
		<para>
		    The implementation is also straight forward as we will see below:
		</para>    		
		<programlisting linenumbering="numbered" id="fullline_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>		
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our line diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
		   ... 
		   QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		    m_chart = new Chart();
		    chartLayout->addWidget( m_chart );

		    m_model.loadFromCSV( ":/data" );
		    
		    // Set up the diagram
		    m_lines = new LineDiagram();
		    m_lines->setModel( &amp;m_model );
		    m_chart->coordinatePlane()->replaceDiagram( m_lines );
		    
		    // Instantiate the timer
		    QTimer *timer = new QTimer(this);
		    connect(timer, SIGNAL(timeout()), this, SLOT(slot_timerFired()));
		    timer->start(40);
		    ...
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
		 ....   
		 if ( text == "Normal" )
		    m_lines->setType( LineDiagram::Normal );
		 else if ( text == "Stacked" )
		    m_lines->setType( LineDiagram::Stacked );
		 else if ( text == "Percent" )
		    m_lines->setType( LineDiagram::Percent );
		 ....
		 m_chart->update();
		</programlisting>
    		<para>
		    We want the user to be able to display or hide the data values from the 
		    GUI, and also change the default font for our data values labels to make 
		    it nicer. 
		</para>
		<programlisting>
		    const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
		    for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
			DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
			QBrush brush( m_lines->brush( iColumn ) );
			TextAttributes ta( a.textAttributes() );
			ta.setRotation( 0 );
			ta.setFont( QFont( "Comic", 10 ) );
			ta.setPen( QPen( brush.color() ) );
			
			if ( checked )
			ta.setVisible( true );
			else
			ta.setVisible( false );
			a.setVisible( true );
			a.setTextAttributes( ta );
			m_lines->setDataValueAttributes( iColumn, a );
		    }
		    m_chart->update();
		</programlisting>		
		<para>
		    In the code above, we make sure our data values labels will be painted 
		    using the dataset default color by retrieving the brush for each dataset 
		    and assigning the color of the brush to the pen.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    The user should be able to display the area for one or several dataset.  
		</para>
		<programlisting>
		    ....
		    LineAttributes la = 
		    m_lines->lineAttributes( 
		    m_lines->model()->index( 0, column, m_lines->rootIndex() ) );
		    if ( checked ) {
		     la.setDisplayArea( true );
		     la.setTransparency( opacity );
		    }  else {
		     la.setDisplayArea( false );
		    }
		    m_lines->setLineAttributes( column, la );
		    ...
		    m_chart->update();
		    ...
		</programlisting>
		<para>
		    This is implemented by configuring our line attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting <filename>examples/Lines/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/Advanced</filename> directory into your KD Chart 
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-advancedline">
		    <title>A Full featured Line Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/advancedlinechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<note>
		    <para>
			The following sections about Point charts and Area are tightly related to line charts. 
			Point charts are line diagrams with Markers (lines themselves are not painted). Area 
			charts are also line charts with the area below the lines, filled by the respective 
			dataset's color.
		    </para>
		</note>
	    </sect2>	  	
            <sect2>
		<title id="points">Point Charts</title>
		<tip>
		    <para>
			Point charts often are used to visualize a big number of data in 
			one or several datasets. A well known point chart example is the 
			historical first Herzsprung-Russel diagram from 1914 where circles
			represented stars with directly measured parallaxes and crosses were 
			used for guessed values of stars from star clusters similar to the 
			following simple chart.
		    </para>
		</tip>
		<figure float="0" id="fig-simplepointchart">
                <title>A Point Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/pointwidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<note>
		    <para>
			Unlike the other chart types in &kdchart; the point chart is not a type of 
			its own but actually a special kind of Line Chart. The resulting display is 
			obtained by painting markers instead of lines as we will see in the following 
			code sample. 
		    </para>
		</note>
		<para>
		    The process for creating a point chart is very simple as described below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Set up a line diagram and configure its pen to Qt::NoPen.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Display its data values marker attributes. 
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="pointsample" xreflabel="codesample">Point Sample Code</title>
		<para>
		    The following code sample is going through the process described above to obtain 
		    a very simple point chart. It is based on the 
		    <filename>examples/Widget/Simple</filename> which code has been slightly modified
		    to display a Point diagram.
		</para>
		<programlisting>
		    ...
		    //  Hide the lines
		    widget.lineDiagram()->setPen(  Qt::NoPen );
		    // Set up the Attributes
		    DataValueAttributes dva( widget.lineDiagram()->dataValueAttributes() );
		    MarkerAttributes ma(  dva.markerAttributes() );
		    TextAttributes ta(  dva.textAttributes() );
		    ma.setVisible( true );
		    // display values or not
		    ta.setVisible(  false );
		    dva.setTextAttributes(  ta );
		    dva.setMarkerAttributes(  ma );
		    dva.setVisible( true );
		    
		    widget.lineDiagram()->setDataValueAttributes( dva );		    	
                </programlisting>
		<para>
		    This sample code is making use of a <classname>KDChartWidget</classname> and a 
		    <classname>KDChartLineDiagram</classname> but of course the process is very 
		    similar if we were working with a <classname>KDChartChart</classname>. 
		</para> 
		<para>
		    We recommend you to run the complete example presented in the following Tips 
		    section.
		</para>
	    </sect2>
	    <sect2>
		<title id="pointsattributes">Points Attributes</title>
		<para>
		    As you have probably deduced from the section above, point charts are line 
		    charts configured with no pen to avoid displaying the lines and using the 
		    generic classes <classname>KDChartDataValueAttributes</classname> and its 
		    <classname>KDChartMarkerAttributes</classname> available to all other diagram
		    types supported by KD Chart 2.0.
		</para>	
		<para>
		    For this reason we will for now point you to the sections related to those 
		    subjects and in particular to Chapter 5 - Customizing your Chart - Section 
		    Markers or Chapter 9 - Advanced Charting - Section Data Value Manipulation
		    and finalize this section by implementing a full featured point chart in the 
		    Tips section below.
		</para>
	    </sect2>	    
	    <sect2>
		<title id="pointstips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.  
		</para>	
	    </sect2>
	    <sect2>
		<title id="pointtipssample" xreflabel="codexample">A complete Point Example</title>
		<para>
		    <!-- Pending michel show a nice full featured point chart with as many 
		    attributes as possible - The following text and list has to be modified 
		    after we have written our own more complete example - 
		    see NotForCustomers/KDChart20-Manual-Examples.txt  -->
		    In the following implementation we want to be able to:			
		</para>
		<itemizedlist>		   
		    <listitem>
			<para>
			   Be able to configure the points styles, color and size.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display data values or hide it.
			</para>
		    </listitem>		  		   
		    <listitem>
			<para>			    
			  Shift between points and lines charts
			</para>
		    </listitem>		   
		</itemizedlist>		
		<para>
		    We are using a <classname>KDChartChart</classname> class and also an home made 
		    <classname>TableModel</classname> for the convenience. It is  derived from 
		    <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/PointChart</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullpoint_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Lines/PointChart/mainwindow.h"/>
		    </textobject>
		</programlisting>   
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartLineDiagram object (m_lines), and our home made TableModel (m_model).
		</para>
		<para>
		    The implementation is similar to the line chart implementation presented earlier:
		</para>    		
		<programlisting linenumbering="numbered" id="fullpoint_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Lines/PointChart/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    Here we will not comment in details the code as it is similar to what we have seen 
		    before in our line chart example, but only pick up the interesting part of it.
		</para>
		<para>
		    In order to get a point chart we paint or hide the lines by setting our line diagram
		    pen:
		</para>
		<programlisting>
		    void MainWindow::on_paintLinesCB_toggled(  bool checked )
		    {
		    const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
		    for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
			DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
			QBrush lineBrush( m_lines->brush( iColumn ) );
			  if ( checked ) {
			    QPen linePen( lineBrush.color() );
			    m_lines->setPen(  iColumn,  linePen );
			  }
			  else
			    m_lines->setPen( iColumn,  Qt::NoPen );
			  }
		    m_chart->update();
		    }
		</programlisting> 
		<para>
		    We need to retrieve the pen color before resetting it to its original value, and do 
		    that by looping through the datasets.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    For us to be able to store different Markers style we make use of 
		    <methodname>MarkerAttributes::MarkerStylesMap map</methodname> which is 
		    very convenient in this case.
		</para>
		<programlisting>
		    ...
		    MarkerAttributes::MarkerStylesMap map;
		    map.insert( 0, MarkerAttributes::MarkerSquare );
		    map.insert( 1, MarkerAttributes::MarkerCircle );
		    map.insert( 2, MarkerAttributes::MarkerRing );
		    map.insert( 3, MarkerAttributes::MarkerCross );
		    map.insert( 4, MarkerAttributes::MarkerDiamond );
		    ...
		    MarkerAttributes ma( dva.markerAttributes() );
		    ma.setMarkerStylesMap( map );
		    ....
		</programlisting>
		<para>
		    The user may also change the size of the marker form the GUI and this is 
		    implemented straight forward by using 
		    <classname>KDChartMarkerAttributes</classname> method
		    <methodname>setMarkerSize()</methodname>.
		</para>
		<programlisting>
		     ma.setMarkerSize( QSize( markersWidthSB->value(),
                                       markersHeightSB->value() ) );
		</programlisting>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/PointChart</filename> directory into your KD Chart 
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullpoint">
		    <title>A Full featured Point Chart</title>
		    <mediaobject>
			<imageobject>			    
			    <imagedata width="3in" scalefit="1" fileref="images/featuredpointchart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	    </sect2>	  
	    <sect2>
		<title id="areas">Area Charts</title>
		<tip>
		    <para>
			Even more than a Line Chart (of which they are attributes) an area chart 
			can give a good visual impression of different datasets and their relation
			to each other.
		    </para>
		    <para>
			For example the area chart type might be the best choice for showing how 
			several sources contributed to increasing ozone values in a conurbation
			during a summer's months.
		    </para>
		</tip>
		<para>
		    Area charts are Line Charts and thus based upon several points which are 
		    connected by lines&mdash;the difference to the line chart is that the area 
		    below a line is filled by the respective dataset's color. This gives a clear
		    appreciation of each dataset's relative values.
	        </para>
		<para>
		    In order to make it possible to see all points, since some are covered by 
		    another dataset's area, we have introduced an attribute which allow the user 
		    to configure the level of transparency (more about that into the Attributes 
		    paragraph of this section.
		    KD Chart 2.0 supports of course Area display for all subtypes of line charts 
		    and thus allow also the user to display the non-overlapping line types. The 
		    following types can be displayed very simply in Area mode:
		</para>
		<itemizedlist>		   
		    <listitem>
			<para>
			    Normal Line Area 
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Stacked Line Area.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Percent Line Area.
			</para>
		    </listitem>		    			   
		</itemizedlist>	
		<figure float="0" id="fig-simpleareachart">
                <title>An Area Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplearea.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
		</figure>
		<note>
		    <para>&kdchart; uses the term &quot;area&quot; in two different
			ways which can be distinguished easily:
		    </para>
		    <itemizedlist>
			<listitem>
			    <para>
				In this chapter it stands for a special chart type or even more
				accurately as a line diagram attribute.
			    </para>
			</listitem>
			<listitem>
			    <para>
				In other context it can also point to the different (normally 
				rectangular) parts of a chart like for example the 
				<emphasis>legend area</emphasis> or the 
				<emphasis>headers area</emphasis>.
			    </para>
			</listitem>
		    </itemizedlist>
		    <para>
			This varying usage of the word &quot;area&quot; should Not cause a lack 
			of clarity: In the context of this special section on 
			<emphasis>area charts</emphasis> the word is clear, in the rest of the 
			manual it just means a part of a chart.
		    </para>
		</note>
		<para>
		    Displaying the area for a dataset or the whole diagram is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a LineAttribute object by calling <methodname>KDChartLineDiagram::lineAttributes</methodname>
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Display it. You can also configure the level of transparency. 
			</para>
		    </listitem>
		</itemizedlist>
	    </sect2>
	    <sect2>
		<title id="areasample" xreflabel="codesample">Area Sample Code</title>
		<para>
		    Let us make this more concrete by looking at the following lines of code
		    and reproduce the process described above:	   
		</para>
		<programlisting>
		    // Create a LineAttribute object
		    LineAttributes la = m_lines->lineAttributes( index );  	    	
                    // set Display implicitely 
		    la.setDisplayArea( true );
		    // Assign to the diagram 
		    m_lines->setLineAttributes( index, la );
                </programlisting>
		<para>
		    Of course Brush and Pen settings as well as all other configurable attributes 
		    accessible by the diagram itself can be set, which give the user a lot of 
		    flexibility ( display or hide data values, markers, lines, configure colors 
		    etc ...). 
		</para>
		<note>
		    <para>
		        <classname>KDChartLineAttributes</classname> can be set for the whole diagram, 
			for a dataset or for a specific index (see sample code above), as for any 
			other attributes.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="areaattributes">Area Attributes</title>
		<para>
		    There are no specifical attributes related to the Area chart. As explained 
		    above Area charts display mode is implemented as a Line Attribute. Of course the 
		    generic attributes common to all chart types are availables, which give us full
		    flexibility to configure our Area chart.
		</para>	
	    </sect2>	    	
	    <sect2>
		<title id="areatips">Tips and Tricks</title>
		<para>
		    In this section we want to give you some example about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.  
		</para>	
	    </sect2>
	    <sect2>
		<title id="areatipssample" xreflabel="codexample">A complete Area Example</title>
		<note>
		    <para>
			This example has already been presented in details 
			<filename>Section - A Complete Line Example</filename>.
			You dont need to go through it, if you already have studied the section above.		
		    </para>
		</note>
		<para>		  
		    In the following implementation we want to be able to:			
		</para>
		<itemizedlist>
		    <!-- Pending Michel to be implemented -->
		    <listitem>
			<para>
			   Display data values
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Shift line types (Normal, Stacked, Percent)
			</para>
		    </listitem>
		    <listitem>			
			<para>
			  Display areas for each dataset on its own and for the whole diagram
			</para>
		    </listitem>			   		    		   
		</itemizedlist>
		<para>
		    We are using a <classname>KDChartChart</classname> class and also an home made 
		    <classname>TableModel</classname> for the convenience. It is  derived from 
		    <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Line chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Lines/Advance</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullarea_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartLineDiagram object (m_lines), and our home made TableModel (m_model).
		</para>
		<para>
		    The implementation is similar to the line chart implementation presented earlier:
		</para>    
		<programlisting linenumbering="numbered" id="fullarea_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Lines/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our line diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
		   ... 
		   QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		    m_chart = new Chart();
		    chartLayout->addWidget( m_chart );

		    m_model.loadFromCSV( ":/data" );
		    
		    // Set up the diagram
		    m_lines = new LineDiagram();
		    m_lines->setModel( &amp;m_model );
		    m_chart->coordinatePlane()->replaceDiagram( m_lines );
		    
		    // Instantiate the timer
		    QTimer *timer = new QTimer(this);
		    connect(timer, SIGNAL(timeout()), this, SLOT(slot_timerFired()));
		    timer->start(40);
		    ...
		</programlisting>
		<para>
		    The user should be able to change the default sub-type via a combo box 
		    from the GUI. This can be done by using 
		    <methodname>KDChartBarDiagram::setType()</methodname> as shown below and
		    by updating the view.
		</para>
		<programlisting>
		 ....   
		 if ( text == "Normal" )
		    m_lines->setType( LineDiagram::Normal );
		 else if ( text == "Stacked" )
		    m_lines->setType( LineDiagram::Stacked );
		 else if ( text == "Percent" )
		    m_lines->setType( LineDiagram::Percent );
		 ....
		 m_chart->update();
		</programlisting>
    		<para>
		    We want the user to be able to display or hide the data values from the 
		    GUI, and also change the default font for our data values labels to make 
		    it nicer. 
		</para>
		<programlisting>
		    const int colCount = m_lines->model()->columnCount(m_lines->rootIndex());
		    for ( int iColumn = 0; iColumn&lt;colCount; ++iColumn ) {
			DataValueAttributes a( m_lines->dataValueAttributes( iColumn ) );
			QBrush brush( m_lines->brush( iColumn ) );
			TextAttributes ta( a.textAttributes() );
			ta.setRotation( 0 );
			ta.setFont( QFont( "Comic", 10 ) );
			ta.setPen( QPen( brush.color() ) );
			
			if ( checked )
			ta.setVisible( true );
			else
			ta.setVisible( false );
			a.setVisible( true );
			a.setTextAttributes( ta );
			m_lines->setDataValueAttributes( iColumn, a );
		    }
		    m_chart->update();
		</programlisting>		
		<para>
		    In the code above, we make sure our data values labels will be painted 
		    using the dataset default color by retrieving the brush for each dataset 
		    and assigning the color of the brush to the pen.
		</para>
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    The user should be able to display the area for one or several dataset.  
		</para>
		<programlisting>
		    ....
		    LineAttributes la = 
		    m_lines->lineAttributes( 
		    m_lines->model()->index( 0, column, m_lines->rootIndex() ) );
		    if ( checked ) {
		     la.setDisplayArea( true );
		     la.setTransparency( opacity );
		    }  else {
		     la.setDisplayArea( false );
		    }
		    m_lines->setLineAttributes( column, la );
		    ...
		    m_chart->update();
		    ...
		</programlisting>
		<para>
		    This is implemented by configuring our line attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting <filename>examples/Lines/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Lines/Advanced</filename> directory into your KD Chart 
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullarea">
		    <title>A Full featured Area Chart</title>
		    <mediaobject>
			<imageobject>			    
			    <imagedata width="3in" scalefit="1" fileref="images/fullareachart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	    </sect2>
<!--	  	
	    <sect2>
		<title id="highlow">High/Low Charts</title>		
		<tip>
		    <para>
			High/low charts could be useful if your value's evolution during a time 
			period should be visualized looking at small segments of this time.  
			Often they are used to display a share's opening and closing value per day,
			as well as each day's maximum and minimum.  Other possible uses of high/low
			charts include the changing temperature during the months: open/close would
			stand for a month's first and last day then.
		    </para>
		</tip>
		<para>
		    Typically high/low charts are used to display one value evolving over the 
		    time&mdash;for showing more than one value consider using another chart type 
		    or use a second <classname>KDChartWidget</classname> positioned next to the
		    first one. Another option might be to show a line chart for all of your values 
		    and draw special attention to one of them by adding an extra high/low chart 
		    featuring this value.The high/low chart could be positioned above the line
		    chart&mdash;sharing its abscissa axis.
		</para>	 
		<para>
		    High/low charts are the most simple ones of &kdchart;'s statistical chart types
		    and unlike the sophisticated Box&amp;Whisker Charts they do not calculateeach 
		    dataset's high/low/open/close values but it is your obligation to pass these 
		    numbers into the data cells. This is done for optimization: most likely you 
		    have these figures anyway, if not it is extremely easy to determine them.
		</para>
		<para>
		    The advantage of not stuffing all your data values into &kdchart; is that such 
		    very small datasets (holding just four cells each) enable your high/low charts 
		    to be displayed very quickly and even when representing a large number of days 
		    they will not consume too  much memory.
		</para>
		<para>
		    High Low Charts can be configured with the following sub types as described in 
		    details below: Simple and Open/Close.
		</para>		
	    </sect2>
	    <sect2>
		<title id="hilosimple">Simple High/Low Charts</title>
                <tip>
                    <para>
			Simple high/low charts (not showing open nor close values) can be useful to
			give an overview about an item's largest and smallest values per 
			time-segment. You can use such a chart if your values beginning and end 
			values are not interesting because the important information is 
			represented by its minima and maxima: e.g. this might be the highest/lowest
			temperature reached in a year where your chart might show the evolution of 
			these values during a span of some 100 years.
                    </para>    
                </tip>	

		<figure float="0" id="fig-hilosimple">
		    <title>A Simple High/Low Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/simplehilo.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    &kdchart; by default draws normal high/low charts without showing any open or 
		    close marks when in High/Low Chart mode so no methods need to be called to get 
		    such charts, however after having used your 
		    <classname>KDChartParams</classname> to display another high/low chart
		    type you can call
		    <methodname>setHiLoChartSubType( KDChart::HiLoNormal )</methodname>
                    to return to the default subtype.
		</para>	    
	    </sect2>
	    <sect2>
		<title id="hiloopenclose">Open/Close High/Low Charts</title>
		<tip>
                    <para>
			Extended open/close high/low charts provide a view on the start and end 
			values as well as on the maximal and minimal values of a specific item
			per time-segment. This kind of chart is useful if your item's start and 
			end value is of special importance too, e.g. typically such charts are
			used to visualize the evolution of per-day figures in a financial share 
			value diagram displaying one or several weeks.
                    </para>
                </tip>
		 <figure float="0" id="fig-openclosehilo">
                    <title>An Open/Close High/Low Chart </title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/openclosehilo.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
	        <para>
		    To make  draw the open and close lines too you call the "classname"
		    <classname>KDChartParams</classname> function
                    <methodname>setHiLoChartType( KDChart::HiLoOpenClose )</methodname>
		    "methodname". In case you are not interested in the open value (e.g. because 
		    this would always be identical to the respective previous close value) just 
		    use <literal>HiLoClose</literal> instead.  
		</para>
	    </sect2>
	    <sect2>
		<title id="hilolabels">High/Low Charts with Custom Data Labels</title>
		<tip>
                    <para>
			Adding data labels to your High/Low chart can be useful if your chart is 
			displaying a rather limited number items: otherwise it might be a better 
			idea to draw the lines without showing the data labels but show a few 
			labels instead using "method".
                    </para>
                </tip>		
                <figure float="0" id="fig-hilocustom">
                    <title>A High/Low Chart With Custom Data Labels</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/hilowithvalues.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>	
               </sect2> 	    
	    <sect2>
		<title id="hlsample" xreflabel="codexample">High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
		</para>		
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="hlattributes">High Low Attributes</title>
		<para>
		    Text ...
		</para>	
	    </sect2>
	    <sect2>
		<title id="hlattributessample" xreflabel="codexample">High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>			
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="hltips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>
	    </sect2>	
	    <sect2>
		<title id="hltipssample" xreflabel="codexample">A complete High/Low Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>			
		<para>
		    More explanation?
		</para>   
	    </sect2>	   
	    <sect2>
		<title id="boxwhisker">Box and Whisker Charts</title>
		<para>
		    This chart is called box&amp;whisker because of its look: a box in the middle 
		    and two lines looking like whiskers on each side.  While the box surrounds the
		    center half of your spreading values, the upper and lower whisker ends are 
		    framing all or most of the values, except from a few outliers indicated 
		    separately.
		</para>
		<para>
		    Box&amp;whisker charts provide detailed descriptive statistics of a variable: 
		    The height of the box shows how close together the main part of your values are
		    and the length of the whiskers indicate how far the other values spread.
		</para>
		<tip>
		    <para>
			Since box&amp;whisker charts give an overview of your values distribution 
			(plus their mean and average value) they can be used for a quick estimate 
			without looking into your statistical tables. An example might be a 
			comparison of the number of failures in a device, perhaps three datasets 
			of some 30 computer chips each to compare their errors at three different 
			temperatures. Each of the data cells containing the number of failures
			shown by one chip your chart would show three boxes: you might expect both 
			a lower error number (with the box being drawn nearer to the abscissa axis)
			and less variation (smaller box and whiskers) at lower temperature.
		    </para>
		</tip>
		<para>
		    Box&amp;whisker charts are the most sophisticated ones of &kdchart;'s 
		    statistical chart types: unlike the simple High/Low Charts 
		    <emphasis>they calculate</emphasis> each dataset's statistical values 
		    themselves.
		</para>
		<para>
		    You can activate the box&amp;whisker chart mode by calling the 
		    "classname" <classname>KDChartParams</classname> function
		    "methodname" 
		    <methodname>setChartType( KDChartParams::BoxWhisker )</methodname>. 
		</para>
		<note>
                  <para>
		      Some notes about configuring colors and lines width
	          </para>
                </note>	
	    </sect2>	    
	    <sect2>
		<title id="bwnormal">Normal Box&amp;Whisker Charts</title>
                <tip>
                    <para>
			Normal box&amp;whisker charts are used to get a quick overview about your 
			spreading data and see the show outliers.
                    </para>
                </tip>
		<figure float="0" id="fig-simplebwchart">
                    <title>A Normal Box&amp;Whisker Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
				fileref="images/simplebwchart.png"
				width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>		
            </sect2>
	    <sect2>
                <title id="bwstripped">Box&amp;Whisker Charts without Outliers</title>
                <tip>
                    <para>
			If outlier values would dilute the message of your chart or simply be 
			visually unpleasant, you can turn them off as described here.
                    </para>
                </tip>
                <figure float="0" id="fig-bwstripped">
                    <title>A Box&amp;Whisker Chart Without Outliers</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/bwstripped.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    To suppress drawing of any markers for <emphasis>outliers</emphasis> or
                    <emphasis>extremes</emphasis> just set their size to zero by calling
		    "methodname"  <methodname>setBWChartOutValMarkerSize( 0 )</methodname> 
                    as demonstrated by the tutorial file "filename", of course you could also use 
		    a value different from zero to set them to a specific size:
                    "methodename" <methodname>setBWChartOutValMarkerSize( -50
                        )</methodname>  would increase their dynamic size by factor two since 
		    -25 is the default setting (a quarter of the box width), while "methodname"
		    <methodname>setBWChartOutValMarkerSize( 15 )</methodname> would set 
		    them to a fixed size of 15pt ignoring the size of the widget.
               </para>
                <note>
                    <para>This special mode might require some additional explanation to tell your 
			users that the outliers and extremes are suppressed: otherwise the chart
                        might be interpreted wrongly since it looks like 
			<emphasis>there are no</emphasis> outliers but all values are within the 
			inner fences or the box area.
                    </para>
                </note>
            </sect2>
	     <sect2>
                <title id="bwstatistics">Box&amp;Whisker Charts with Statistics</title>
                <tip>
                    <para>
			By showing statistical values in your box&amp;whisker charts, you can make 
			your charts even more expressive - at the possible expense of readability.
                    </para>
                </tip>
                <figure float="0" id="fig-bwstatistics">
                    <title>A Box&amp;Whisker Chart With Statistical Values</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/bwstatistics.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    Box&amp;whisker charts can print up to ten different statistical figures next 
		    to the respective boxes&mdash;each of which can be shown using specific fonts, 
		    text color,and background colors.
                </para>
                <para>
		    Printing of a statistical value is enabled by passing one of the
                    <literal>KDChartParams::BWStatVal</literal> enum's descriptive names
                    (<literal>UpperOuterFence</literal>, <literal>UpperInnerFence</literal>,
                    <literal>Quartile3</literal>, <literal>Median</literal>,
                    <literal>Quartile1</literal>, <literal>LowerInnerFence</literal>,
                    <literal>LowerOuterFence</literal>, <literal>MaxValue</literal>,
                    <literal>MeanValue</literal>, <literal>MinValue</literal>)
                    to the following function:
                </para>
		<programlisting>
		    void KDChartParams::setBWChartPrintStatistics( BWStatVal statValue,
		    bool active,
		    QFont* font = 0,
		    int size = 24,
		    QColor* color = 0,
		    QBrush* brush = 0 );
		</programlisting>
                <para>
		    Parameters:
		</para>
                <variablelist>
		    <varlistentry>
			<term><literal>statValue</literal></term>
			<listitem>
			    <para>one of the enum values listed above</para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>active</literal></term>
			<listitem>
			    <para>set to true to have the <literal>statValue</literal>
				printed using either the default fond and color or the
				settings specified by the following parameters
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>font</literal></term>
                    <listitem>
			    <para>if not zero the font will be used for this
				statistical value
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>size</literal></term>
			<listitem>
			    <para>if not zero this value will be interpreted as
				percent of the actual box width: font size will
				be calculated dynamically then instead of using
				the <literal>font</literal> parameter's fixed size
			    </para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>color</literal></term>
			<listitem>
			    <para>the text color of this statistical value</para>
			</listitem>
		    </varlistentry>
		    <varlistentry>
			<term><literal>brush</literal></term>
			<listitem>
			    <para>the color of the background of this statistical
				value, if set to Qt::NoBrush the background is
				<emphasis>not</emphasis> erased before the text
				is printed
			    </para>
			</listitem>
		    </varlistentry>
                </variablelist>
                <para>
		    Compile and run the tutorial file

                     <ulink url="../../doc/tutorial/step01w/kdchart_step01w.cpp"> 
                        <filename>kdchart_step01w.cpp</filename>
                    </ulink>
		    
                    to see a box&amp;whisker chart featuring all possible statistical value texts 
		    using custom font settings and a special background color for the boxes 
		    (see also <xref linkend="fig-bwstatistics"/>).
                </para>
                <note>
                    <para>
			No fence values are printed for the middle series in our sample 
			(<xref linkend="fig-bwstatistics"/>) because they are outside of 
			the chart's data area.  This can occur if all values of a series are in 
			the inner fences and the box.  Since in this case there is no need to show 
			the fence values the range of the ordinate axis is <emphasis>not</emphasis>
			extended but the chart uses the available space to have more room for 
			displaying the other datasets which otherwise would have less vertical 
			space to draw their boxes and whiskers.
                    </para>
                </note>
            </sect2>
	    <sect2>
		<title id="bwsample" xreflabel="codexample">Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
	        <title id="bwattributes">Box and Whisker Attributes</title>
		<para>
	        Text ...
	        </para>	 
	    </sect2>
	    <sect2>
		<title id="bwattributessample" xreflabel="codexample">Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.			
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    <sect2>
		<title id="bwtips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>	
	    </sect2>
	    <sect2>
		<title id="bwtipssample" xreflabel="codexample">A complete Box and Whisker Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
		</para>
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    -->	   
	</sect1>
	<sect1>
            <title id="polarplane">Polar coordinate plane</title>
	    <para>
                KD Chart makes use of the Polar coordinate system, and in particular its 
		<classname>KDChart::PolarCoordinatePlane</classname> class for displaying 
		chart types like Pie, Polar and Ring.
            </para>
	    <para>
		In this section we will describe and present each of the chart types which uses 
		the Polar coordinate plane.
	    </para>
	    <para>		
		In general to implement a particular type of chart, just create an object of this  
		type by calling <classname>KDChart[type]Diagram</classname>, or if your are using 
		<classname>KDChartWidget</classname> you will need to call its 
		<methodname>setType()</methodname> and specify the appropriate chart type.
 		(e.g Widget::Pie, Widget::Polar etc...)
	    </para>
	    <sect2>
		<title id="piecharts">Pie Charts</title>	    
		<tip>
		    <para>
			Pie charts can be used to visualize the relative values of a few data 
			cells (typically 2..20 values). Larger amounts of items can be hard to 
			distinguish in a pie chart, so a Percent Bar Chart might fit your needs 
			better then. Pie charts are most suitable if one of the data elements 
			covers at least one forth, preferably even more of the total area.
		    </para>
		    <para>
			A good example is the distribution of market shares among
			products or vendors.
		    </para>
		    <para>
			While pie charts are nice for displaying <emphasis>one</emphasis>
			dataset there is a complementary chart type you might choose
			to visualize several datasets: the Ring Chart, a circular multi dataset
			chart type described in the <filename>Ring Charts</filename> section furhter 
			on.
		    </para>
		</tip>	
		<para>
		    Pie charts typically consist of two or more pieces any number of which can be 
		    shown 'exploded' (shifted away from the center) at different amounts, starting
		    position of the first pie can be specified and your pie chart can be drawn in 
		    three-D look. Activating the pie chart mode is done by calling the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType( KDChartWidget::Pie )</methodname> or by creating an object
		    of this type using the <classname>KDChartPieDiagram</classname> class.
		</para>
		<note>
		    <para>
			Three-dimensional look of the pies is no special feature you can enable 
			by setting its ThreeD attributes, we will describe that more in details
			Chapter 5 - Customizing your Chart - ThreeD section further on.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="piesimple">Simple Pie Charts</title>
                <tip>
                    <para>
			A simple pie chart shows the data without emphasizing a special item.
                    </para>
                </tip>
		<!-- change this example against one with legends and datavalue display -->
                <figure float="0" id="fig-simplepiechart">
                    <title>A Simple Pie Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/simplepie.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>
		    &kdchart; by default draws two-dimensional pie charts when in pie chart mode 
		    so no method needs to be called to get one. We are describing more in details
		    about how to obtain three dimensional look for a pie chart in the following 
		    Pie Attributes section.
                </para>		               
	    </sect2>
	    <sect2>
                <title id="pieexploding">Exploding Pie Charts</title>
                <tip>
                    <para>
			Explode individual segments to emphasize individual data.
                    </para>
                </tip>
                <figure float="0" id="fig-pieexplode">
                    <title>An Exploding Pie Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/pieexploding.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>                                
                <para>
                    We will go through all the configuration possibilities in the Pie Attributes
		    section below, but let us study some code sample first.
                </para>
            </sect2>	   
	    <sect2>
		<title id="piesample" xreflabel="wcodesample">Code Sample</title>
		<para>
		    For now let us make the above description  more concrete by looking at the 
		    following code sample based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example we 
		    demonstrate how to configure your Pie diagram and change its attributes when 
		    working with a <classname>KDChartWidget</classname>.
		</para>	
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
		    #include &lt;QApplication&gt;
		    #include &lt;KDChartWidget&gt;
		    #include &lt;KDChartPieDiagram&gt;
                    #include &lt;QPen&gt;

	            using namespace KDChart;			    
		</programlisting>                
		<para>
		    We need to include <classname>KDChartPieDiagram</classname> in order to be able
		    to configure some of its attributes as we will see further on. 
		</para>
		<programlisting>
		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );                    
		    Widget widget;
		    // our Widget can be configured 
		    // as any Qt Widget 
		    widget.resize( 600, 600 );		    
                    // store the data and assign it
		    QVector&lt; double &gt; vec0,  vec1;
		    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
		    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
		    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
		    widget.setDataset( 0, vec0, "vec0" );
		    widget.setDataset( 1, vec1, "vec1" );
		    widget.setDataset( 2, vec2, "vec2" );
		    widget.setType(  Widget::Pie );
		</programlisting>
		<para>
		    We just need to change the default chart type (Line Charts) by calling  
		    the <methodname>KDChartWidget::setType</methodname> method.     
		</para>		
		<para>
		    Now let us configure a Pen to draw a line arount the Pie and its section
		</para>
		<programlisting>		   
		    QPen piePen( widget.pieDiagram()->pen() );
                    piePen.setWidth( 3 );
		    piePen.setColor( Qt::yellow );
		    // call your diagram and set the new pen
		    widget.pieDiagram()->setPen( 2, piePen );
		</programlisting>		
		<para>
		    Here we are configuring the pen "attribute". As you can see it is straight forward.
		    <methodname>KDChartWidget::pieDiagram()</methodname> allow us to get a pointer to 
		    our widget diagram. As you can see it is very simple to assign a new pen to our 
		    diagram by calling the diagram <methodname>KDChartAbstractDiagram::setPen()</methodname>
		    method. 
		</para>			
		<para>
		    Finally we conclude our small example:
		</para>
		<programlisting>
		    widget.show();
		    
		    return app.exec();
		    }
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-samplepiewidget">
                <title>A Simple Pie Widget</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplepiewidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Pie/Simple</filename>
		</para>	
		<note>
		    <para>
			Configuring the attributes for a <classname>KDChartPieDiagram</classname> making use
			of a <classname>KDChartChart</classname> is done the same way as for a 
			<classname>KDChartWidget</classname>. You just need to assign the configured attributes 
			to your pie diagram and assign the diagram to the chart by calling 
			<methodname>KDChartChart::replaceDiagram()</methodname>.
		    </para>
		</note>	
	    </sect2>
	    <sect2>
		<title id="pieattributes">Pies Attributes</title>
		<para>
		    By "Pie attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Pie Chart type.
		    KD Chart 2.0 API separates the attributes specifics to a chart type itself and 
		    the generic attributes which are common to all chart types as for example the 
		    setters and getters for a brush or a pen (See 
		    <classname>KDChartAbstractDiagram</classname> or 
		    <classname>KDChartPieAbstractDiagram</classname> etc...		    
		</para>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartPieDiagram::setPieAttributes()</methodname>.
		</para>
		<para>
		    The procedure is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::PieAttributes</classname> object by 
			    calling <methodname>KDChartPieDiagram::pieAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::PieDiagram</classname>. All the attributes can be
			    configured to be applied for the whole diagram, for a column, or at a 
			    specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Pie chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Explode: Enable/Disable exploding pie piece(s)
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Explode factor: The explode factor is a qreal between 0 and 1, it 
			    is interpreted as a percentage of the total available radius.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   StartPosition: Set the starting angle for the first dataset. 
			    Can only be specified for the whole diagram.
			</para>
		    </listitem>
		     <listitem>
			<para>
			   Granularity: Set the granularity: the smaller the granularity the 
			    more your diagramsegments will show facettes instead of rounded 
			    segments. Can only be specified for the whole diagram.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    PieAttributes: set or retrieve the pie diagram Attributes.
			    ( see: <classname>KDChartAbstractPieDiagram</classname> )
			</para>
		    </listitem>
		    <listitem>
			<para>
			    ThreeDPieAttributes: set or retrieve the diagram ThreeDAttributes.
			    ( see: <classname>KDChartAbstractPieDiagram</classname> )
			</para>
		    </listitem>		    
		</itemizedlist>
		<tip>
		    <para>
			The default explode factor is 10 percent; use 
			<methodname>setExplodeFactor</methodname> to specify a different factor.
			This is a convenience function: Calling 
			<methodname>setExplode( true )</methodname> does the same as calling 
			<methodname>setExplodeFactor( 0.1 )</methodname>, and calling 
			<methodname>setExplode( false )</methodname> does the same as calling 
			<methodname>setExplodeFactor( 0.0 )</methodname>.
		    </para>
		</tip>
		<para>
		    To get a pie chart like the one presented above (having one or several of the 
		    pieces separated from the others in <emphasis>exploded</emphasis> mode) you 
		    would have to set its attributes by calling 
		    <methodname>KDChartPieAttributes::setExplode </methodname> or 
		    <methodname>KDChartPieAttributes::setExplodeFactor</methodname> if you want to
		    change the explode factore default value and then use the available methods to 
		    assing those attributes to your diagram as shown in the following code sample 
                </para>
		<programlisting>
		    // 1 - Create a PieAttribute object
		    PieAttributes pa (m_pie->PieAttributes());
		    // 2 - Enable exploding, point to a dataset and give the 
		    // explode factor passing the dataset number and the factor 		   
		    pa.setExplodeFactor( 0.5 );
		    // 3 - Assign to your diagram
		    m_pie->setPieAttributes( column, pa);
		</programlisting>	
		<note>
		    <para>
			Three-dimensional look of the pies can be enable and configured  
			by setting its ThreeD attributes the same way as we are setting the 
			PieAttributes in the code sample above, we will describe that more in 
			details	Chapter 5 - Customizing your Chart - ThreeD section further on.
		    </para>
		</note>		
	    </sect2>
	   <sect2>
		<title id="pieattributessample" xreflabel="acodesample">Pie Attributes Sample</title>
		<para>
		    Let us make this more concrete by looking at the following sample code that 
		    describes the above process. We recommand you to compile and run the following 
		    example which is located into the <filename>examples/Lines/Parameters</filename>
		    directory of your KD Chart installation.
		</para>
		<para>
		    First of all we are including the header files and bring KD Chart namespace.
		</para>
		<programlisting>
		    #include &lt;QtGui&gt;
		    #include &lt;KDChartChart&gt;
                    #include &lt;KDChartPieDiagram&gt;
                    #include &lt;KDChartPieAttributes&gt;

                    using namespace KDChart;		    
                </programlisting>
		<para>
		    We have included <classname>KDChartPieAttributes</classname> to be able 
		    to configure exploding for one of the pie slice. Those attributes are 
		    specifical to the Pie types.
		</para>
		<para>
		    In this example we are using a <classname>KDChartChart</classname> class as well
		    as a <classname>QStandardItemModel</classname> in order to store the data which 
		    will be assigned to our diagram. 
		</para>
		<programlisting>
		    m_model.insertRows( 0, 1, QModelIndex() );
		    m_model.insertColumns(  0,  6,  QModelIndex() );
		    for (int row = 0; row &lt; 1; ++row) {
		      for (int column = 0; column &lt; 6; ++column) {
		        QModelIndex index = 
		    m_model.index(row, column, QModelIndex());
		        m_model.setData(index, QVariant(row+1 * column+1) );
		      }
		    }
		    // We need a Polar plane for the Pie type
		    PolarCoordinatePlane* polarPlane = 
		    new PolarCoordinatePlane( &amp;m_chart );
		    // replace the default Cartesian plane with
		    // our Polar plane
		    m_chart.replaceCoordinatePlane( polarPlane );

		    // assign the model to our pie diagram
		    PieDiagram* diagram = new PieDiagram;
		    diagram->setModel(&amp;m_model);
                </programlisting>
		<para>
		    After having stored our data into the model, we create a need to replace 
		    the default Cartesian plane against a Polar plane before creating our Pie diagram. 
		    In this case, we want to display a <classname>KDChartPieDiagram</classname>. 
		    As always we need to assign the model to our diagram. This procedure is of course 
		    similar for all types of diagrams. 
		</para>
		<para>
		    We are now ready to configure our attributes. We want to explode a section and 
		    configure a Pen to surround it. Let us begin with the specifical 
		    <methodname>PieAttributes</methodname>.
		</para>
		<programlisting>
		    // Configure some Pie specifical attributes

		    // explode a section
		    PieAttributes pa(  diagram->pieAttributes() );
		    pa.setExplodeFactor( 0.1 );
		    
		    // Assign the attributes
		    // to the diagram
		    diagram->setPieAttributes( 1,  pa );
                </programlisting>
		<para>
		    As for all attributes we call them by using the relevant method available
		    from our diagram interface, here 
		    <methodname>diagram->PieAttributes()</methodname>. The second step is to 
		    set it up with our own values and finally we assign it to our diagram.
		    In the above code we explode the second slice (dataset) in our Pie.
		</para>	
		<note>
		    <para>
			After having configured our attributes we need to assign the 
			attributes to the diagram. This can be done for the whole diagram, at a 
			specific index or for a column. Look at the attributes interface  and look 
			at the methods available there to find out those setters and getters.
		    </para>   
		</note>
		<para>
		    We want to configure the Pen in order to draw a surrounding line around the 
		    exploded section (dataset) to focus the attention of the reader on this particular 
		    section.
		</para>
		<programlisting>
		    // Configure a generic attribute
		    // available to all chart types
		    QPen sectionPen;
		    sectionPen.setWidth( 5 );
		    sectionPen.setStyle( Qt::DashLine );
		    sectionPen.setColor( Qt::magenta );
		    
		    diagram->setPen( 1, sectionPen );
		</programlisting>	
		<para>
		    Of course we could  also have changed the pen for all datasets as well.
		</para>		
		<note>
		    <para>
			The Pen and the Brush setters and getters are implemented at a lower level 
			in our <classname>KDChartAbstractDiagram</classname> class for a cleaner 
			code structure. Those methods are of course used by all types of diagram 
			and their configuration is very simple and straight forward as you can see 
			in the above sample code. Create or get a Pen , configure it, call one of 
			the setters methods available (See 
			<filename>KDChartAbstractDiagram.h</filename> about those methods).
		    </para>
		</note>
		<para>
		    Our attributes having been configured and assigned we just need to assign our
		    Pie diagram to our chart and conclude the implementation.
		</para>
		<programlisting>
		     // Assign our diagram to the Chart
		    m_chart.coordinatePlane()->replaceDiagram(diagram);

		    QVBoxLayout* l = new QVBoxLayout(this);
		    l->addWidget(&amp;m_chart);
		    setLayout(l);
		    }
		</programlisting>
                <para>
		    The above procedure can be applied to any of the supported attributes for 
		    all chart types. The resulting display of the code we have gone through can be 
		    seen in the following screen-shot. We also recommend you to compile and run the 
		    example related to this section and located in the 
		    <filename>examples/Pie/Parameters</filename> directory of your KD Chart 
		    installation.
                </para>
		<figure float="0" id="fig-samplepiechart">
                <title>Pie With Configured Attributes</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/samplepiechart.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>		
		<note>
		    <para>
			ThreeDAttibutes for the different chart types are implemented has an own
			class, the same way as for the other attributes. We will talk more in 
			details about KD Chart 2.0 ThreeD features in the ThreeD section, Chapter 5
			- Customizing your Chart.  
	 	    </para>	
		</note>
	    </sect2>	
	    <sect2>
		<title id="pietips">Tips and Tricks</title>
		<para>
		    In this section we want to go through some examples about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.   
		</para>	
	    </sect2>
	    <sect2>
		<title id="pietipsample" xreflabel="codexample">A complete Pie Example</title>
		<para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
<!-- Pending Michel not implemented yet -->
<!--
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
-->
		     <listitem>
			<para>
			   Configure the Start position .
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Display a Pie chart and shift between normal and threeD look.
			</para>
		    </listitem>
<!-- Pending Michel not implemented yet is that still actual ? -->
<!--
		     <listitem>
			<para>
			   Enable or disable the use of shadow colors when in threeD mode 
			</para>
		    </listitem>
-->		    
		    <listitem>
			<para>			    
			   Explode one or several slices and  set a surrounding line 
			   around  exploded sections
			</para>
		    </listitem>	
		    <listitem>
			<para>			    
			   Run an animation (exploding). 
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our Pie chart implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Pie/Advanced</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="fullpie_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual and declare our 
		    slots. The purpose is to let the user configure its line chart attributes 
		    manually from the GUI. As you can see we are using a KDChartChart object (m_chart),
		    a KDChartPieDiagram object (m_pie), and our home made TableModel (m_model).
		</para>
		<note>
		    <para>
			Before diplaying our Pie diagram we need to implicitely replace the default 
			cartesian plane by a Polar plane.
		    </para>
		</note>	
		<programlisting linenumbering="numbered" id="fullpie_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our pie diagram. We 
		    also want to set up a <classname>QTimer</classname> to be able to run our animation. 
		    Finally we assign the diagram to our chart.
		</para>
		<programlisting>
		   ... 
		   QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		    m_chart = new Chart();
		    chartLayout->addWidget( m_chart );

		    m_model.loadFromCSV( ":/data" );
		    
		    // Set up the plane
		    PolarCoordinatePlane* polarPlane = new PolarCoordinatePlane( m_chart );
		    m_chart->replaceCoordinatePlane( polarPlane );
		    
		    // Set up the diagram
		    m_pie = new LineDiagram();
		    m_pie->setModel( &amp;m_model );
		    m_chart->coordinatePlane()->replaceDiagram( m_pie );
		    
		    // Instantiate the timer
		    QTimer *timer = new QTimer(this);
		    connect(timer, SIGNAL(timeout()), this, SLOT(slot_NextFrame() ) );		    
		    ...
		</programlisting>
		<para>
		    The user should be able to change the start position from the GUI. This can 
		    be implemented by using <classname>KDChartPieAttributes</classname> 
		    as shown below and by updating the view.
		</para>
		<programlisting>
		    ....   
		    PieAttributes pa( m_pie->pieAttributes() );
		    pa.setStartPosition( pos );
		    m_pie->setPieAttributes( pa );
		    m_chart->update();
                    ....
		</programlisting>
    		<para>
		    We want the user to be able to shift between 3D mode display  or the normal  
		    standard display from the GUI. 
		</para>
		<programlisting>
		    // note: We use the global getter method here, it will fall back
		    // automatically to return the default settings.
		    ThreeDPieAttributes tda( m_pie->threeDPieAttributes() );
		    tda.setEnabled( toggle );
		    tda.setDepth( threeDFactorSB->value() );
		    m_pie->setThreeDPieAttributes( tda );
		    m_chart->update();
		</programlisting>				
		<note>
		    <para>
			It is important to know that have three levels of precedence when 
			setting the attributes: 
		    <itemizedlist>
			<listitem>
			    <para>
				Global: Weak
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per column: Medium
			    </para>
			</listitem>
			<listitem>
			    <para>
				Per cell: Strong
			    </para>
			</listitem>
		    </itemizedlist>
		    Which means that once you have set the attributes for a column or a cell, you will
		    not be able to change those settings by calling the "global" method to reset it 
		    to another value, but instead call the per column or per index setter. As 
		    demonstrated in the above code.
		    </para>
		</note>
		<para>
		    We want the user to be able to explode one or several slice(s) (dataset) and
		    to configure the exploding factor.
		</para>
		<programlisting>
		    ....
		    // note: We use the per-column getter method here, it will fall back
		    // automatically to return the global (or even the default) settings.
		    PieAttributes pa( m_pie->pieAttributes( column ) );
		    pa.setExplodeFactor( value );
		    m_pie->setPieAttributes( column, pa );
		    ...
		    m_chart->update();
		    ...
		</programlisting>
		<para>
		    This is implemented by configuring our pie attributes and assign them by 
		    dataset to the diagram, as shown above.
		</para>
		<para>
		    The same procedure is used for us to be able to run our animation. You can 
		    of course learn more about this part of the code which is more related to 
		    Qt programming by consulting 
		    <filename>examples/Pie/Advanced/mainwindow.cpp</filename>. 
		</para>
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Pie/Advanced</filename> directory into your KD Chart 
		    installation. We recommend you to run it. The widget displayed by the above 
		    code is shown in the figure below.
		</para>
		<figure float="0" id="fig-fullpie">
		    <title>A Full featured Pie Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullpiechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>	    	  	
	    </sect2>
<!-- comment for now not implemented yet -->
<!--	  
            <sect2>
		<title id="rings">Ring Charts</title>
		 <tip>
		    <para>
			While a Pie Chart might be a good choice when displaying a single data 
			series, using a ring chart might be ideal for visualizing a small amount 
			of data cells stored in several datasets: ring charts can show both the
			relative values of the cells compared to their dataset's total value 
			<emphasis>and</emphasis> the relation of the series totals compared to 
			each other. This is done by using relative ring widths as shown below.
		    </para>
		</tip>
		<para>
		    Ring charts (like Pie Charts ) typically consist of two or more segments any 
		    number of which can be shown 'exploded' (shifted away from the center).
		    To activate the ring chart mode simple call the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType(Widget::Ring)</methodname> or create an object of type 
		    <classname>KDChartRingDiagram</classname>
		</para>
	    </sect2>
	     <sect2>
                <title id="ringsimple">Simple Ring Charts</title>
                <tip>
                    <para>
			If you do not care about the relative size of the sums of values in each 
			datasets, simple ring charts are is the good choice.
                    </para>
                </tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-simpleringchart">
                    <title>A Simple Ring Chart</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/simplering.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    &kdchart; by default draws non-exploded rings with equal thickness when in 
		    ring chart mode so no methods need to be called.
                </para>
                <para>
		    Compile and run the example file "SimpleRing" to see obtain normal ring chart.
                </para>
            </sect2>
	    <sect2>
                <title id="ringrelative">Ring Charts with Relative Thickness</title>
                <tip>
                    <para>
			Looking similar to a tree's annual rings these charts might be a good 
			choice for displaying several years-related volumes of data like sales
			numbers.  The segments could stand for the different product lines in a 
			sortiment of goods. Looking at a ring's thicknesses you then could see
			the change in sales for <emphasis>all</emphasis> of your goods while a 
			segment's length would show you how much this product line has contributed 
			to the respective year's total turnover&mdash;compared to your other 
			products.
                    </para>
                </tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-ringrelative">
                    <title>A Ring Chart With Relative Thickness</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/ringrelativethickness.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    Relative thickness mode is activated by calling the 
		    <classname>KDChartRingAttributes</classname> function 
                    <methodname>setRelativeThickness( true )</methodname>
                    where each ring represents one dataset and the ring widths show the relations 
		    of the dataset totals to each other.
                </para>
                <para>
		    Compile and run the example RingRelativeThickness to see a ring chart 
		    featuring three datasets: the thickness of the middle ring shows clearly 
		    that this series represents the biggest total value.
                </para>
            </sect2>
	     <sect2>
                <title id="ringexploding">Ring Charts Exploding Segments</title>
                <tip>
                    <para>
			<emphasis>Explode</emphasis> one or several of the segments of your ring 
			chart to emphasize the respective data cell(s).  You might use this for
                        drawing attention to sales figures below a critical level of for 
			highlighting a very successful item.
                    </para>
                </tip>
                <para>
		    To have one or several segments of your ring chart shown exploded you need to
		    to set its attributes and implicitely enable exploding, by calling  
		    <methodname>KDChartPieAttributes::setExplode </methodname> and then use the 
		    available methods to set the exploding factor for a particular dataset. 
		    as shown in the Ring Attribute section coming next. 
                </para>	        
                <para>
		    In case you want to apply <emphasis>different</emphasis> explode factors to the
                    segments just call the 
		    <methodname>KDChartRingAttributes::setExplodeFactors()</methodname> function 
		    and pass to it a <literal>KDChartRingAttributes::ExplodeFactorsMap</literal>
                    with one <literal>double</literal> value for every segment. The following ring 
		    chart has exploded all segments with values less than their ring's average 
		    while the smallest value is exploded even more.
                </para>
		<tip>
		    <para>
			You will find all you need to know for configuring your ring chart in our 
			Ring Attribute section below.
		    </para>    
		</tip>
-->
		<!-- disabling for now no example available yet -->
		<!-- 
                <figure float="0" id="fig-ringexplode">
                    <title>A Ring Chart With Exploding Segments</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata
                            fileref="images/ringexploded.png"
                            width="3in" scalefit="1"/>
                        </imageobject>
                    </mediaobject>
                </figure>
		-->
<!--
                <para>
		    Compile and run the example RingExploded to see a ring chart featuring both 
		    relative thickness  of the rings and differently exploded segments on the 
                    outer ring. 
                </para>                
            </sect2>
-->
	    <!-- commenting this part until we have something to show -->
	    <!--
	    <sect2>
		<title id="ringsample" xreflabel="codexample">Ring Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.		   
		</para>		
		<para>
		    More explanation?
		</para>   
	    </sect2>
	    -->
<!--
	    <sect2>
		<title id="ringsattributes">Rings Attributes</title>
		<para>
		    By "Ring Attributes" we are talking about all parameters that can be 
		    configured and set by the user and which are specifics to the Ring Chart type.
		    KD Chart 2.0 API separates the attributes specifics to a chart type itself and 
		    the generic attributes which are common to all chart types as for example the 
		    setters and getters for a brush or a pen.		    
		</para>
		<para>
		    All those attributes have a reasonnable default value that can simply be 
		    modified by the user by calling one of the diagram set function implemented on 
		    this purpose <methodname>KDChartRingDiagram::setRingAttributes()</methodname>.
		</para>
		<para>
		    The procedure is straight forward:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			    Create a <classname>KDChart::RingAttributes</classname> object by 
			    calling <methodname>KDChartRingDiagram::ringAttributes</methodname>.  
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Configure this object using the setters available.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Assign it to your Diagram with the help of one of the setters available 
			    in <classname>KDChart::RingDiagram</classname>. All the attributes can 
			    be configured to be applied for the whole diagram, for a column, or at 
			    a specified index (<classname>QModelIndex</classname>).
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    KD Chart 2.0 supports the following attributes for the Ring chart type. 
		    Each of those attributes can be set and retrieved the way we describe it in our 
		    example below:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Not implemented yet
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Not implemented yet
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Not implemented yet 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Not implemented yet
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    To get a ring chart like the one presented above (having one or several of the 
		    pieces separated from the others in <emphasis>exploded</emphasis> mode) you 
		    would have to set its attributes and implicitely enable exploding, by calling  
		    <methodname>KDChartRingAttributes::setExplode </methodname> and then use the 
		    available methods to set the exploding factor for a particular dataset. 
		    as shown in the following code sample 
                </para>
		<programlisting>
		    // 1 - Create a RingAttributes object
		    RingAttributes ra = m_ring->RingAttributes( index );
		    // 2 - Enable exploding, point to a dataset and give the 
		    // explode factor passing the dataset number and the factor 
		    ra.setExplode( true );
		    ra.setExplodeFactor( 2, 0.5 );
		    // 3 - Assign to your diagram
		    m_ring->setRingAttributes( index, pa);
		</programlisting>  
-->
      		<!-- Pending Michel Is that still true ? -->
<!--
		<note>
                    <para>
			Only segments that are located on the <emphasis>outer</emphasis>
                        ring can be exploded.
                    </para>
                </note>
	    </sect2>
	     <sect2>
		<title id="ringstips">Tips and Tricks</title>
		<para>
		    In this section we want to go through some examples about how to use some 
		    interesting features offered by the KD Chart 2.0 API. We will study the 
		    code and display a screen-shot showing the resulting widget.   
		</para>	
	    </sect2>
	    <sect2>
		<title id="ringtipsample" xreflabel="codexample">A complete Ring Example</title>
		<para>
-->
		    <!-- Pending michel show a nice full featured Ring chart with as many 
		    attributes as possible - The following text and list has to be modified 
		    after we have written our own more complete example - 
		    see NotForCustomers/KDChart20-Manual-Examples.txt  -->
<!--
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		    <listitem>
			<para>
			   Display the data values.
			</para>
		    </listitem>
		     <listitem>
			<para>
			   Display a ring using most of its attributes
			</para>
		    </listitem>
		    <listitem>
			<para>			    
			   Run an animation (exploding). 
			</para>
		    </listitem>
		</itemizedlist>
		<programlisting linenumbering="numbered" id="fullring_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>
		    More explanation h file?
		</para>
		<programlisting linenumbering="numbered" id="fullring_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Pie/Advanced/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    More explanation cpp file?
		</para>
		<figure float="0" id="fig-fullring">
		    <title>A Full featured Ring Chart</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/fullpiechart.png"/>
			</imageobject>
		    </mediaobject>
		</figure>	    	  	
	    </sect2>
-->
<!--
	    <sect2>
		<title id="polarchart">Polar Charts</title>
		 <tip>
		    <para>
			Polar charts got their name from displaying &quot;polar coordinates&quot; 
			instead of Cartesian coordinates. Currently only normalized polar charts 
			can be shown: all values advance by the same number of polar degrees
			and there is no way to specify a data cell's angle individually. While 
			this is ideal for some situations it is not possible to display true world 
			map data like this since you can not specify each cell's rotation angle.
			Transforming your coordinates to the Cartesian system and using a
			Point Chart might be a solution in such cases.
		    </para>
		</tip>
		<para>		    
		    To activate the polar chart mode simply call the 
		    <classname>KDChartWidget</classname> function 
		    <methodname>setType(Widget::Polar)</methodname> or create an object of type 
		    <classname>KDChartPolarDiagram</classname> and assign it to your 
		    <classname>KDChartChart</classname> by calling its 
		    <methodname>replaceDiagram()</methodname> method.
		</para>	
	    </sect2>
	    <sect2>
		<title id="simplepolarchart">A Simple Polar Charts</title>
		<para>
		    Just like the Line Charts to which they can be compared the polar chart type is
		    divided into three sub types which can be activated by calling 
		    <methodname>setType( KDChartPolarDiagram::Normal )</methodname>
		    or <literal>Stacked</literal> or <literal>Percent</literal>.
		</para>
		<para>
		    Compile and run the example file "PolarSimple" to see a normal polar chart as 
		    shown below. 		
		</para>
-->
		<!-- temporarely commented until we have an example to show -->
		<!--
		 <figure float="0" id="fig-simplepolarchart">
                <title>A Normal Polar Chart</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simplepolar.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		-->
<!--
		<note>
		    <para>
			Data Values are shown by default in polar charts even if drawing of the 
			markers is suppressed by <methodname>setPolarMarker( false )</methodname>, 
			you can  hide them by calling the 
			<classname>KDChartPolarAttributes</classname> function 
			<methodname>setPrintDataValues( false )</methodname>.
		    </para>
		</note>
	    </sect2>
	    <sect2>
		<title id="polarsattributes">Polars Attributes</title>
		<para>
		    Text ...
		</para>
	    </sect2>	    
	    <sect2>
		<title id="polarstips">Tips and Tricks</title>
		<para>
		    Some tips and tricks
		</para>
	    </sect2>
	    <sect2>
		<title id="polartipssample" xreflabel="codexample">A complete Polar Example</title>
		<para>
		    Let us make this more concrete by looking at the 
		    following lines of code.
-->
		    <!--
		    <link linkend=""></link>
		    <link linkend=""></link>
		    -->
<!--
		</para>
-->
		<!--
		<programlisting linenumbering="numbered" id="">
		<textobject>
		<textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
		-->
<!--
		<para>
		    More explanation?
		</para>   	
	    </sect2>
-->
	</sect1>
	<sect1>
            <title>What's next</title>
            <para>
                For our diagram to be useful we need to be able to display its axis. That 
		will be the subject of our next section.
            </para>
        </sect1>
    </chapter>
     <chapter id="chapter_axes">
        <title id="chtxt_axes">Axes</title>
        <titleabbrev id="chnum_axes">Chapter 5</titleabbrev>
	<para>
	    Axes are implemented at different levels in the KD Chart 2.0 API. KD Chart make 
	    use of Cartesian axis - see <classname>KDChartCartesianAxis</classname> and Polar 
	    Axis which are derived from the base class for axes 
	    <classname>KDChartAbstractAxis</classname>.
	    <!-- Pending Michel Polar axis are not implemented yet -->.
        </para>
	<para>
	    The user may specify its own set of strings to be used as Axis labels with the
	    <methodname>KDChartAbstractAxis::setLabels( const QStringList )</methodname>
	    method.
	</para>
	<note>
	    <para>
		Labels specified via setLabels take precedence: If a non-empty list is passed, 
		KD Chart will use these strings as axis labels, instead of calculating them.
		By passing an empty QStringList you can reset the default behaviour.
	    </para>
	</note>
	<para>
	    For the convenience we can also specify short labels in our own set of string to
	    be used as axis labels,in case the normal labels are too long by using  
	    <methodname>KDChartAbstractAxis::setShortLabels( const QStringList )</methodname>
	</para>
	<para>
	    Axis values and labels text attributes can also be configured. Thus the labels of 
	    all of your axes in all of your diagrams  within that Chart will be drawn in same 
	    font size, by default.
	</para>
	<para>
	    The setters and getters for axis labels and their text attributes are implemented 
	    in the axis base class <classname>KDChartAbstractAxis</classname>, we recommend you 
	    to study its interface - See <filename>KDChartAbstractAxis.h</filename>.
	</para>
	<tip>
	    <para>
		If you a smaller number of strings than the number od labels drawn at this
		axis, KD Chart will iterate over the list, repeating the strings, until all
		labels are drawn. 
	    </para>
	    <para>
		As an example you could specify the seven days of the week as abscissa labels,
		which would be repeatedly used then.
	    </para>
	</tip>
	<sect1>
	   <title id="cartesianaxes">Cartesian Axis</title>
            <para>
                The class <classname>KDChartCartesianAxis</classname> is used together with 
		the diagrams displayed in a cartesian coordinate plane and contains the setters
		and getters related to the axis specifics to those chart types.
            </para> 
	    <para>
		It allows the user to set and retrieve the position (top, bottom, left or right), 
		or the type (abscissa, ordinate) of the axis, assign or retrieve a title and its 
		text attributes. That is where the axis are painted.
	    </para>
	    <para>
		The setters and getters for those specifics cartesian features are implemented 
		in <classname>KDChartCartesianAxis</classname>, we recommend you 
		to study its interface - See <filename>KDChartCaretesianAxis.h</filename>.
	    </para>
	</sect1>
	<sect1>
            <title id="caxeshowtoconfigure">How to configure</title>
            <para>
                In order to add axis to a cartesian diagram we need to use 
		<methodname>KDChartAbstractCartesianDiagram::AddAxis()</methodname> method.
		The diagram takes ownership of the axis and will delete it by itself.
            </para>
	    <para>
		To gain back ownership (e.g. for assigning the axis to another diagram)
		use the <methodname>KDChartAbstractDiagram::takeAxis()</methodname> method, 
		before calling addAxis on the other diagram.
	    </para>
	    <note>
		<para>
		    <methodname>KDChartAbstractDiagram::takeAxis()</methodname>Removes the 
		    axis from the diagram, without deleting it. The diagram no longer owns 
		    the axis, so it is the caller's responsibility to delete the axis.
		</para>
	    </note>
            <sect2>
                <title id="caxessample" xreflabel="codsample">Cartesian Axes sample</title>
                <para>
                    Let us make the above description more concrete by looking at the following
                    lines of code based on the <filename>Simple Widget</filename> example we 
		    have been demonstrating above 
		    (<filename>Chapter 3 - Two Ways - Widget Example</filename>). In this example 
		    we demonstrate how to add an X axis and a Y axis to your diagram and set the 
		    Axis titles when working with a <classname>KDChartWidget</classname>..
		</para>
		<para>
		    First include the appropriate headers and bring in the "KDChart namespace":
		</para>	    	
		<programlisting>
		    #include &lt;QApplication&gt;
		    #include &lt;KDChartWidget&gt;
		    #include &lt;KDChartLineDiagram&gt;
                    #include &lt;KDChartCartesianAxis&gt;

	            using namespace KDChart;			    
		</programlisting>                
		<para>
		    We need to include <classname>KDChartLineDiagram</classname> in order to be 
		    able to add the Axis as we will see further on. 
		</para>
		<programlisting>
		    int main( int argc, char** argv ) {
		    QApplication app( argc, argv );                    
		    Widget widget;
		    // our Widget can be configured 
		    // as any Qt Widget 
		    widget.resize( 600, 600 );		    
                    // store the data and assign it
		    QVector&lt; double &gt; vec0,  vec1;
		    vec0 &lt;&lt; 5 &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 1;
		    vec1 &lt;&lt; 3 &lt;&lt; 6 &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 8;
		    vec2 &lt;&lt; 0 &lt;&lt; 7 &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 1;
		    widget.setDataset( 0, vec0, "vec0" );
		    widget.setDataset( 1, vec1, "vec1" );
		    widget.setDataset( 2, vec2, "vec2" );		   
		</programlisting>
		<note>
		    <para>
			We don't need to change the default chart type (Line Charts) by calling  
			the <methodname>KDChartWidget::setType</methodname> method.     
		    </para>
		</note>
		    <para>
		    Now let us create our axis, position them and set their titles:
		</para>
		<programlisting>
		    CartesianAxis *xAxis = new CartesianAxis( widget.lineDiagram() );
		    CartesianAxis *yAxis = new CartesianAxis (widget.lineDiagram() );
		    xAxis->setPosition ( CartesianAxis::Bottom );
		    yAxis->setPosition ( CartesianAxis::Left );
		    xAxis->setTitleText ( "Abscissa bottom position" );
		    yAxis->setTitleText ( "Ordinate left position" );
		</programlisting>		
		<para>
		    And add them to our diagram which will take the ownership:
		</para>			
		<programlisting>
		    widget.lineDiagram()->addAxis( xAxis );
		    widget.lineDiagram()->addAxis( yAxis );
		</programlisting>
		<para>
		    Finally we conclude our small example:
		</para>
		<programlisting>
		    widget.show();
		    
		    return app.exec();
		    }
		</programlisting>
		<para>
		    See the screen-shot below to view The resulting chart displayed by the above code. 
		</para>
		<figure float="0" id="fig-sampleaxiswidget">
                <title>A Simple Widget With Axis</title>
                <mediaobject>
                    <imageobject>
                        <imagedata
                        fileref="images/simpleaxiswidget.png"
                        width="3in" scalefit="1"/>
                    </imageobject>
                </mediaobject>
            </figure>
		<para>
		    This example can be compiled and run from the following location of your KD Chart
		    installation <filename>examples/Axis/Widget</filename>, we recommend you to do so.
		</para>			             
                <para>
                    In the Tips section below we will present you a more elaborate example which uses 
		    <classname>KDChartChart</classname> and where we are configuring our axis title
		    text attributes. We also use our own labels and their shortened version. 	    
                </para>
            </sect2>
        </sect1>
<!--
	<sect1>
	   <title id="partesianaxes">Polar Axis</title>
            <para>
                
            </para> 
	</sect1>
	<sect1>
            <title id="paxeshowtoconfigure">How to configure</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="paxessample" xreflabel="codsample">Polar Axes sample</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.	
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
-->
	<sect1>
            <title id="axistips">Tips</title>
	    <para>
		In this section we want to give you some example about how to use some 
		interesting features offered by the KD Chart 2.0 API. We will study the 
		code and display a screen-shot showing the resulting widget. 
	    </para>	
            <sect2>
                <title id="axistipsample" xreflabel="codexample">Axis Example</title>           
		<para>		  
		    In the following implementation we want to be able to:
		</para>
		<itemizedlist>
		     <listitem>
			<para>
			   Add axes at different positions.
			</para>
		    </listitem>
		    <listitem>
			<para>
			   Set the axis title and configure their text attributes. 
			</para>
		    </listitem>		    
		    <listitem>
			<para>			    
			   Use our own labels and their shortened versions.
			</para>
		    </listitem>
		     <listitem>
			<para>			    
			   Configure our labels text attributes.
			</para>
		    </listitem>
		</itemizedlist>
		<para>
		    In the example below we are using a <classname>KDChartChart</classname> class and 
		    also an home made <classname>TableModel</classname> for the convenience. It is  
		    derived from <classname>QAbstractTableModel</classname>.
		</para>
		<para>
		    TableModel uses a simple rectangular vector of vectors to represent a data
		    table that can be displayed in regular Qt Interview views. Additionally, it 
		    provides a method to load CSV files exported by OpenOffice Calc in the default 
		    configuration. This allows to prepare test data using spreadsheet software.
		</para>
		<para>
		    It expects the CSV files in the subfolder ./modeldata. If the application
		    is started from another location, it will ask for the location of the
		    model data files.
		</para>
		<para>
		    We recommend you to consult the "TableModel" interface and implementation files
		    which are located in the <filename>examples/tools</filename> directory of your 
		    KD Chart installation.
		</para>
		<para>
		    Let us concentrate on our diagram _with_ axis implementation for now and consult the 
		    following files: other needed files like the ui, pro , qrc ,CSV and main.cpp files 
		    can be consulted from the <filename>examples/Axis/Chart</filename> directory
		    of your installation.
		</para>
		<programlisting linenumbering="numbered" id="axislabels_mainwindow_h">
		    <textobject><textdata fileref="../../examples/Axis/Chart/mainwindow.h"/>
		    </textobject>
		</programlisting>                
		<para>		
		    In the above code we bring up the KDChart namespace as usual. As you can see we are 
		    using a KDChartChart object (m_chart), a KDChartLineDiagram object (m_lines), and 
		    our home made TableModel (m_model). 
		</para>	
		<programlisting linenumbering="numbered" id="axeslabels_mainwindow_cpp">
		    <textobject><textdata fileref="../../examples/Axis/Chart/mainwindow.cpp"/>
		    </textobject>
		</programlisting>
		<para>
		    First of all we are adding our chart to the layout as for any other Qt widget. Load 
		    the data to be display into our model, and assign the model to our diagram.		   
		</para>
		<programlisting>
		    ... 
		    QHBoxLayout* chartLayout = new QHBoxLayout( chartFrame );
		    m_chart = new Chart();
		    chartLayout->addWidget( m_chart );
		    hSBar->setVisible( false );
		    vSBar->setVisible( false );
		    
		    m_model.loadFromCSV( ":/data" );
		    
		    // Set up the diagram
		    m_lines = new LineDiagram();
		    m_lines->setModel( &amp;m_model );	    
		    ...
		</programlisting>
		<para>
		    We want to display three axis, respectively positionned at
		    the top, left and bottom side of our diagram. This is straight
		    forward:
		</para>
		<programlisting>
		    ....   
		    CartesianAxis *topAxis = new CartesianAxis( m_lines );
		    CartesianAxis *leftAxis = new CartesianAxis ( m_lines );
		    CartesianAxis *bottomAxis = new CartesianAxis ( m_lines );
		    topAxis->setPosition ( CartesianAxis::Top );
		    leftAxis->setPosition ( CartesianAxis::Left );
		    bottomAxis->setPosition ( CartesianAxis::Bottom );
                    ....
		</programlisting>
    		<para>
		    In the code above we are declaring our axis and make use of 
		    <methodname>KDChartCartesianAxis::setPosition()</methodname> to
		    give their location.
		</para>
		<para>
		    Let us now define the title text for each of those axis:
		</para>
		<programlisting>
		    ...		   
		    topAxis->setTitleText ( "Abscissa color configured top position" );
		    leftAxis->setTitleText ( "Ordinate font configured" );
		    bottomAxis->setTitleText ( "Abscissa Bottom" );
		    ...
		</programlisting>				
		<para>
		    <methodname>setTitleText()</methodname> and 
		    <methodname>setTitleTextAttributes()</methodname> are implemented in 
		    <classname>KDChartCartesianAxis</classname>, we recommend you to 
		    consult its interface ( see <filename>KDChartCartesianAxis.h</filename>
		</para>
		<para>
		    In this example and to demonstrate the text configuration for the title 
		    and the labels we want to have a different configuration for each of 
		    our tilte axis and also for our labels. The process is the same as for 
		    configuring any type of attributes, as follow:
		</para>
		<para>
		    Create an attribute object, configure it and assign it.
		</para>
		<programlisting>
		    ...
		     // configure titles text attributes
		    TextAttributes taTop ( topAxis->titleTextAttributes () );
		    // color configuration
		    taTop.setPen( QPen( Qt::red ) );
		    // assign to the axis 
		    topAxis->setTitleTextAttributes ( taTop );

		    TextAttributes taLeft ( leftAxis->titleTextAttributes () );
		    // Font configuration
		    Measure me( taLeft.fontSize() );
		    me.setValue( me.value() * 1.5 );
		    taLeft.setFontSize( me );
		    leftAxis->setTitleTextAttributes ( taLeft );

		    TextAttributes taBottom ( bottomAxis->titleTextAttributes () );
		    taBottom.setPen(  QPen( Qt::blue ) );
		    bottomAxis->setTitleTextAttributes ( taBottom );

		    // configure labels text attributes
		    TextAttributes taLabels;
		    taLabels.setPen(  QPen( Qt::darkGreen ) );
		    topAxis->setTextAttributes( taLabels );
		    leftAxis->setTextAttributes( taLabels );
		    bottomAxis->setTextAttributes( taLabels );
		    ...
		</programlisting>
		<para>
		    We want our top and bottom axis to display different types of labels
		    as well as to make sure those labels will be shortened in case the 
		    normal labels are too long ( see setShortLabels() ).
		</para>
		<programlisting>
		    // configure labels and their shortened versions
		    QStringList daysOfWeek;
		    daysOfWeek &lt;&lt; "Monday" &lt;&lt; "Tuesday" &lt;&lt; "Wednesday"
		    &lt;&lt; "Thursday" &lt;&lt; "Friday" ;
		    topAxis->setLabels( daysOfWeek );
		    
		    QStringList shortDays;
		    shortDays &lt;&lt; "Mon" &lt;&lt; "Tue" &lt;&lt; "Wed"
		    &lt;&lt; "Thu" &lt;&lt; "Fri";
		    topAxis->setShortLabels( shortDays );
		    
		    QStringList bottomLabels;
		    bottomLabels &lt;&lt; "Day 1" &lt;&lt; "Day 2" &lt;&lt; "Day 3"
		    &lt;&lt; "Day 4" &lt;&lt; "Day 5";
		    bottomAxis->setLabels( bottomLabels );

		    QStringList shortBottomLabels;
		    shortBottomLabels &lt;&lt; "D1" &lt;&lt; "D2" &lt;&lt; "D3"
		    &lt;&lt; "D4" &lt;&lt; "D5";
		    bottomAxis->setShortLabels( shortBottomLabels );
		</programlisting>
		<note>
		    <para>
			Labels specified via setLabels take precedence: if a non-empty 
			list is passed, KD Chart will use these strings as axis labels,
			instead of calculating them.
		    </para>
		</note>
		<para>
		    Finally the last step i to assign our axis to the diagram and the 
		    diagram to our chart view.
		</para>
		<programlisting>
		     // add axis
		    m_lines->addAxis( topAxis );
		    m_lines->addAxis( leftAxis );
		    m_lines->addAxis( bottomAxis );
		    
		    // assign diagram to chart view
		    m_chart->coordinatePlane()->replaceDiagram( m_lines );
		</programlisting>		
		<para>
		    This example is available to compile and run from the 
		    <filename>examples/Axis/Chart</filename> directory into your KD Chart 
		    installation. We recommend you to run it. The widget displayed by the 
		    above code is shown in the figure below.
		</para>
		<figure float="0" id="fig-axisconfiguredtitles">
		    <title>Axis with configured Labels and Titles</title>
		    <mediaobject>
			<imageobject>
			    <imagedata width="3in" scalefit="1" fileref="images/axisconfiguredtitles.png"/>
			</imageobject>
		    </mediaobject>
		</figure>
		<para>
		    Several ready to run examples related to axis are available at the following 
		    location <filename>examples/Axis</filename>, we recommend you to run them all
		    and consult their implementation.
		</para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Legends are also an important element. In the next section we will describe how to 
		add and configure your chart legend.
            </para>
        </sect1>
    </chapter>
        <chapter id="chapter_legends">
        <title id="chtxt_legends">Legends</title>
        <titleabbrev id="chnum_legends">Chapter 6</titleabbrev>
	<para>
	    Legends can be drawn for all kind of diagrams and are drawn on chart 
	    level (in relation to diagram level). We can have more than one
	    legend per chart, using 
	    <methodname>KDChartChart::addLegend()</methodname>.
	</para>
	<note>
	    <para>
		Legend is different from all other classes ofd KD Chart, since it 
		can be displayed outside of the Chart's area. If we want to, we 
		can embedd the legend into your own widget, or into another part 
		of a bigger grid, into which we might have inserted the Chart.
	    </para>
	    <para>
		On the other hand, please note that we need to (MUST) call 
		<methodname>Chart::addLegend()</methodname> to get our legend 
		positioned at the correct position in our chart in case we want 
		to display the legend inside of the chart which is probably true 
		for most cases.
	    </para>
	</note>
	<para>
	    Let us go through the main configuration features offered by
	    <classname>KDChartLegend</classname>. Of course we also recommend you to 
	    consult its interface see <filename>KDChartLegend.h</filename>.
	</para>
	<sect1>
            <title id="legendshowtoconfigure">How to configure</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="legendsconfiguresample" xreflabel="codexample">Legend Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="legendstips">Tips</title>
	    <para>
		some text
	    </para>
            <sect2>
                <title id="legendtipsample" xreflabel="codexample">Legend Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Headers and Footers.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_headersfooters">
        <title id="chtxt_headersfooters">Header and Footers</title>
        <titleabbrev id="chnum_headersfooters">Chapter 7</titleabbrev>
	<para>
          Introduction text
        </para>
	<sect1>
            <title id="headersfootershowtoconfigure">How to configure</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="headersfootersconfiguresample" xreflabel="codexample">Headers and Footers Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="headersandfooterstips">Tips</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="headersfooterstipsample" xreflabel="codexample">A cool headers and footers Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Customizing your chart.
            </para>
        </sect1>
    </chapter>
    <chapter id="chapter_customizing">
        <title id="chtxt_customizing">Customizing your Chart</title>
        <titleabbrev id="chnum_customizing">Chapter 8</titleabbrev>
	<para>
          Introduction text
        </para>
	<sect1>
            <title id="customizingattributes">KD Chart Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="attributeassample" xreflabel="codesample">Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="customizingdatavalue">Data Values Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="datavaluesample" xreflabel="codesample">DataValue Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>	
	<sect1>
            <title id="customizingtext">Text Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="textsample" xreflabel="codesample">Text Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="customizingmarkers">Markers Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="markersattributesample" xreflabel="markersample">Marker Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
		<sect1>
            <title id="customizingbackground">BackGround Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="backgroundsample" xreflabel="backgroundsample">Background Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="customizinggrid">Grid Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="gridsample" xreflabel="gridsample">Grid Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
		<sect1>
            <title id="customizingframes">Frame Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="framesample" xreflabel="framesample">Frame Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
		<sect1>
            <title id="customizingthreed">ThreeD Attributes</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="markerssample" xreflabel="markersample">ThreeD Attributes Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="customizingtips">Tips</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="tipsample" xreflabel="codexample">Customizing Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                Advanced charting.
            </para>
        </sect1>
    </chapter>
    
    <chapter id="chapter_advancedcharting">
        <title id="chtxt_advancedcharting">Advanced Charting</title>
        <titleabbrev id="chnum_advancedcharting">Chapter 9</titleabbrev>
	<para>
          Introduction text
        </para>
<!--
	<sect1>
            <title id="framebackground">Frame and Background</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="framebackgroundsample" xreflabel="codexample">Frame and Background Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
-->
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
<!--
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="datavaluemanipulation">Data Value Manipulation</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="datavaluemanipulationsample" xreflabel="codexample">Data Value Manipulation Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
-->
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
<!--
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title id="axismanipulation">Axis Manipulation</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="axismanipulationsample" xreflabel="codexample">Axis Manipulation Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
-->
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
<!--
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="gridmanipulation">Grid Manipulation</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="gridmanipulationsample" xreflabel="codexample">Grid Manipulation Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
-->
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
<!--
                </para>
-->
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
<!--
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
-->
	<sect1>
            <title id="interactivecharts">Interactive Charts</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="interactivechartssample" xreflabel="codexample">Interactive Chart Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="multiplechart">Multiple Charts</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="multiplechartsample" xreflabel="codexample">Multiple Chart Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
	<sect1>
            <title id="zooming">Zooming</title>
            <para>
                Text ...
            </para>  
            <sect2>
                <title id="zoomingsample" xreflabel="codexample">Zooming Example</title>
                <para>
                    Let us make this more concrete by looking at the following
                    lines of code.
		    <!--
                    <link linkend=""></link>
		    <link linkend=""></link>
                    -->
                </para>
                <!--
                <programlisting linenumbering="numbered" id="">
                <textobject>
                <textdata fileref="../../examples/..."/>
	        </textobject>
	        </programlisting>
                -->
                <para>
                    More explanation?
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>What's next</title>
            <para>
                FAQ.
            </para>
        </sect1>
    </chapter>    
    <appendix id="appendix_qanda">
        <title>Q&amp;A section</title>
        <titleabbrev>Appendix A</titleabbrev>       
        <note>
            <para>
                This section will grow further according to the most frequently
                asked questions to our support.
            </para>
        </note>
    </appendix>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
